// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = import.meta.require;

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "17.2.0",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto2 = __require("crypto");
  var packageJson = require_package();
  var version2 = packageJson.version;
  var TIPS = [
    "\uD83D\uDD10 encrypt with dotenvx: https://dotenvx.com",
    "\uD83D\uDD10 prevent committing .env to code: https://dotenvx.com/precommit",
    "\uD83D\uDD10 prevent building .env in docker: https://dotenvx.com/prebuild",
    "\uD83D\uDEE0\uFE0F  run anywhere with `dotenvx run -- yourcommand`",
    "\u2699\uFE0F  specify custom .env file path with { path: '/custom/path/.env' }",
    "\u2699\uFE0F  enable debug logging with { debug: true }",
    "\u2699\uFE0F  override existing env vars with { override: true }",
    "\u2699\uFE0F  suppress all logs with { quiet: true }",
    "\u2699\uFE0F  write to custom object with { processEnv: myObject }",
    "\u2699\uFE0F  load multiple .env files with { path: ['.env.local', '.env'] }"
  ];
  function _getRandomTip() {
    return TIPS[Math.floor(Math.random() * TIPS.length)];
  }
  function parseBoolean(value) {
    if (typeof value === "string") {
      return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
    }
    return Boolean(value);
  }
  function supportsAnsi() {
    return process.stdout.isTTY;
  }
  function dim(text) {
    return supportsAnsi() ? `\x1B[2m${text}\x1B[0m` : text;
  }
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse6(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath;
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error40) {
        if (i + 1 >= length) {
          throw error40;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.error(`[dotenv@${version2}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version2}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version2}] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error40) {
      if (error40.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error40;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (debug || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    const populated = DotenvModule.populate(processEnv, parsedAll, options);
    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
    if (debug || !quiet) {
      const keysCount = Object.keys(populated).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`(tip: ${_getRandomTip()})`)}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config2(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error40) {
      const isRange = error40 instanceof RangeError;
      const invalidKeyLength = error40.message === "Invalid key length";
      const decryptionFailed = error40.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error40;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    const populated = {};
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
          populated[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
        populated[key] = parsed[key];
      }
    }
    return populated;
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse6,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/dotenv/lib/env-options.js
var require_env_options = __commonJS((exports, module) => {
  var options = {};
  if (process.env.DOTENV_CONFIG_ENCODING != null) {
    options.encoding = process.env.DOTENV_CONFIG_ENCODING;
  }
  if (process.env.DOTENV_CONFIG_PATH != null) {
    options.path = process.env.DOTENV_CONFIG_PATH;
  }
  if (process.env.DOTENV_CONFIG_QUIET != null) {
    options.quiet = process.env.DOTENV_CONFIG_QUIET;
  }
  if (process.env.DOTENV_CONFIG_DEBUG != null) {
    options.debug = process.env.DOTENV_CONFIG_DEBUG;
  }
  if (process.env.DOTENV_CONFIG_OVERRIDE != null) {
    options.override = process.env.DOTENV_CONFIG_OVERRIDE;
  }
  if (process.env.DOTENV_CONFIG_DOTENV_KEY != null) {
    options.DOTENV_KEY = process.env.DOTENV_CONFIG_DOTENV_KEY;
  }
  module.exports = options;
});

// node_modules/dotenv/lib/cli-options.js
var require_cli_options = __commonJS((exports, module) => {
  var re = /^dotenv_config_(encoding|path|quiet|debug|override|DOTENV_KEY)=(.+)$/;
  module.exports = function optionMatcher(args) {
    const options = args.reduce(function(acc, cur) {
      const matches = cur.match(re);
      if (matches) {
        acc[matches[1]] = matches[2];
      }
      return acc;
    }, {});
    if (!("quiet" in options)) {
      options.quiet = "true";
    }
    return options;
  };
});

// node_modules/dotenv/config.js
var require_config = __commonJS(() => {
  (function() {
    require_main().config(Object.assign({}, require_env_options(), require_cli_options()(process.argv)));
  })();
});

// node_modules/kafkajs/src/loggers/index.js
var require_loggers = __commonJS((exports, module) => {
  var { assign } = Object;
  var LEVELS = {
    NOTHING: 0,
    ERROR: 1,
    WARN: 2,
    INFO: 4,
    DEBUG: 5
  };
  var createLevel = (label, level, currentLevel, namespace, logFunction) => (message, extra = {}) => {
    if (level > currentLevel())
      return;
    logFunction({
      namespace,
      level,
      label,
      log: assign({
        timestamp: new Date().toISOString(),
        logger: "kafkajs",
        message
      }, extra)
    });
  };
  var evaluateLogLevel = (logLevel) => {
    const envLogLevel = (process.env.KAFKAJS_LOG_LEVEL || "").toUpperCase();
    return LEVELS[envLogLevel] == null ? logLevel : LEVELS[envLogLevel];
  };
  var createLogger = ({ level = LEVELS.INFO, logCreator } = {}) => {
    let logLevel = evaluateLogLevel(level);
    const logFunction = logCreator(logLevel);
    const createNamespace = (namespace, logLevel2 = null) => {
      const namespaceLogLevel = evaluateLogLevel(logLevel2);
      return createLogFunctions(namespace, namespaceLogLevel);
    };
    const createLogFunctions = (namespace, namespaceLogLevel = null) => {
      const currentLogLevel = () => namespaceLogLevel == null ? logLevel : namespaceLogLevel;
      const logger2 = {
        info: createLevel("INFO", LEVELS.INFO, currentLogLevel, namespace, logFunction),
        error: createLevel("ERROR", LEVELS.ERROR, currentLogLevel, namespace, logFunction),
        warn: createLevel("WARN", LEVELS.WARN, currentLogLevel, namespace, logFunction),
        debug: createLevel("DEBUG", LEVELS.DEBUG, currentLogLevel, namespace, logFunction)
      };
      return assign(logger2, {
        namespace: createNamespace,
        setLogLevel: (newLevel) => {
          logLevel = newLevel;
        }
      });
    };
    return createLogFunctions();
  };
  module.exports = {
    LEVELS,
    createLogger
  };
});

// node_modules/kafkajs/src/instrumentation/event.js
var require_event = __commonJS((exports, module) => {
  var id = 0;
  var nextId = () => {
    if (id === Number.MAX_VALUE) {
      id = 0;
    }
    return id++;
  };

  class InstrumentationEvent {
    constructor(type, payload) {
      this.id = nextId();
      this.type = type;
      this.timestamp = Date.now();
      this.payload = payload;
    }
  }
  module.exports = InstrumentationEvent;
});

// node_modules/kafkajs/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "kafkajs",
    version: "2.2.4",
    description: "A modern Apache Kafka client for node.js",
    author: "Tulio Ornelas <ornelas.tulio@gmail.com>",
    main: "index.js",
    types: "types/index.d.ts",
    license: "MIT",
    keywords: [
      "kafka",
      "sasl",
      "scram"
    ],
    engines: {
      node: ">=14.0.0"
    },
    repository: {
      type: "git",
      url: "https://github.com/tulios/kafkajs.git"
    },
    bugs: {
      url: "https://github.com/tulios/kafkajs/issues"
    },
    homepage: "https://kafka.js.org",
    scripts: {
      jest: "export KAFKA_VERSION=${KAFKA_VERSION:='2.4'} && NODE_ENV=test echo \"KAFKA_VERSION: ${KAFKA_VERSION}\" && KAFKAJS_DEBUG_PROTOCOL_BUFFERS=1 jest",
      "test:local": "yarn jest --detectOpenHandles",
      "test:debug": "NODE_ENV=test KAFKAJS_DEBUG_PROTOCOL_BUFFERS=1 node --inspect-brk $(yarn bin 2>/dev/null)/jest --detectOpenHandles --runInBand --watch",
      "test:local:watch": "yarn test:local --watch",
      test: "yarn lint && JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh 'yarn jest --ci --maxWorkers=4 --no-watchman --forceExit'",
      lint: "find . -path ./node_modules -prune -o -path ./coverage -prune -o -path ./website -prune -o -name '*.js' -print0 | xargs -0 eslint",
      format: "find . -path ./node_modules -prune -o -path ./coverage -prune -o -path ./website -prune -o -name '*.js' -print0 | xargs -0 prettier --write",
      precommit: "lint-staged",
      "test:group:broker": "yarn jest --forceExit --testPathPattern 'src/broker/.*'",
      "test:group:admin": "yarn jest --forceExit --testPathPattern 'src/admin/.*'",
      "test:group:producer": "yarn jest --forceExit --testPathPattern 'src/producer/.*'",
      "test:group:consumer": "yarn jest --forceExit --testPathPattern 'src/consumer/.*.spec.js'",
      "test:group:others": "yarn jest --forceExit --testPathPattern 'src/(?!(broker|admin|producer|consumer)/).*'",
      "test:group:oauthbearer": "OAUTHBEARER_ENABLED=1 yarn jest --forceExit src/producer/index.spec.js src/broker/__tests__/connect.spec.js src/consumer/__tests__/connection.spec.js src/broker/__tests__/disconnect.spec.js src/admin/__tests__/connection.spec.js src/broker/__tests__/reauthenticate.spec.js",
      "test:group:broker:ci": 'JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh "yarn test:group:broker --ci --maxWorkers=4 --no-watchman"',
      "test:group:admin:ci": 'JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh "yarn test:group:admin --ci --maxWorkers=4 --no-watchman"',
      "test:group:producer:ci": 'JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh "yarn test:group:producer --ci --maxWorkers=4 --no-watchman"',
      "test:group:consumer:ci": 'JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh "yarn test:group:consumer --ci --maxWorkers=4 --no-watchman"',
      "test:group:others:ci": 'JEST_JUNIT_OUTPUT_NAME=test-report.xml ./scripts/testWithKafka.sh "yarn test:group:others --ci --maxWorkers=4 --no-watchman"',
      "test:group:oauthbearer:ci": `JEST_JUNIT_OUTPUT_NAME=test-report.xml COMPOSE_FILE='docker-compose.2_4_oauthbearer.yml' ./scripts/testWithKafka.sh "yarn test:group:oauthbearer --ci --maxWorkers=4 --no-watchman"`,
      "test:types": "tsc -p types/"
    },
    devDependencies: {
      "@types/jest": "^27.4.0",
      "@types/node": "^12.0.8",
      "@typescript-eslint/typescript-estree": "^1.10.2",
      eslint: "^6.8.0",
      "eslint-config-prettier": "^6.0.0",
      "eslint-config-standard": "^13.0.1",
      "eslint-plugin-import": "^2.18.2",
      "eslint-plugin-jest": "^26.1.0",
      "eslint-plugin-node": "^11.0.0",
      "eslint-plugin-prettier": "^3.1.0",
      "eslint-plugin-promise": "^4.2.1",
      "eslint-plugin-standard": "^4.0.0",
      execa: "^2.0.3",
      glob: "^7.1.4",
      husky: "^3.0.1",
      ip: "^1.1.5",
      jest: "^25.1.0",
      "jest-circus": "^25.1.0",
      "jest-extended": "^0.11.2",
      "jest-junit": "^10.0.0",
      jsonwebtoken: "^9.0.0",
      "lint-staged": "^9.2.0",
      mockdate: "^2.0.5",
      prettier: "^1.18.2",
      semver: "^6.2.0",
      typescript: "^3.8.3",
      uuid: "^3.3.2"
    },
    dependencies: {},
    "lint-staged": {
      "*.js": [
        "prettier --write",
        "git add"
      ]
    }
  };
});

// node_modules/kafkajs/src/errors.js
var require_errors = __commonJS((exports, module) => {
  var pkgJson = require_package2();
  var { bugs } = pkgJson;

  class KafkaJSError extends Error {
    constructor(e, { retriable = true, cause } = {}) {
      super(e, { cause });
      Error.captureStackTrace(this, this.constructor);
      this.message = e.message || e;
      this.name = "KafkaJSError";
      this.retriable = retriable;
      this.helpUrl = e.helpUrl;
      this.cause = cause;
    }
  }

  class KafkaJSNonRetriableError extends KafkaJSError {
    constructor(e, { cause } = {}) {
      super(e, { retriable: false, cause });
      this.name = "KafkaJSNonRetriableError";
    }
  }

  class KafkaJSProtocolError extends KafkaJSError {
    constructor(e, { retriable = e.retriable } = {}) {
      super(e, { retriable });
      this.type = e.type;
      this.code = e.code;
      this.name = "KafkaJSProtocolError";
    }
  }

  class KafkaJSOffsetOutOfRange extends KafkaJSProtocolError {
    constructor(e, { topic, partition }) {
      super(e);
      this.topic = topic;
      this.partition = partition;
      this.name = "KafkaJSOffsetOutOfRange";
    }
  }

  class KafkaJSMemberIdRequired extends KafkaJSProtocolError {
    constructor(e, { memberId }) {
      super(e);
      this.memberId = memberId;
      this.name = "KafkaJSMemberIdRequired";
    }
  }

  class KafkaJSNumberOfRetriesExceeded extends KafkaJSNonRetriableError {
    constructor(e, { retryCount, retryTime }) {
      super(e, { cause: e });
      this.stack = `${this.name}
  Caused by: ${e.stack}`;
      this.retryCount = retryCount;
      this.retryTime = retryTime;
      this.name = "KafkaJSNumberOfRetriesExceeded";
    }
  }

  class KafkaJSConnectionError extends KafkaJSError {
    constructor(e, { broker, code } = {}) {
      super(e);
      this.broker = broker;
      this.code = code;
      this.name = "KafkaJSConnectionError";
    }
  }

  class KafkaJSConnectionClosedError extends KafkaJSConnectionError {
    constructor(e, { host, port } = {}) {
      super(e, { broker: `${host}:${port}` });
      this.host = host;
      this.port = port;
      this.name = "KafkaJSConnectionClosedError";
    }
  }

  class KafkaJSRequestTimeoutError extends KafkaJSError {
    constructor(e, { broker, correlationId, createdAt, sentAt, pendingDuration } = {}) {
      super(e);
      this.broker = broker;
      this.correlationId = correlationId;
      this.createdAt = createdAt;
      this.sentAt = sentAt;
      this.pendingDuration = pendingDuration;
      this.name = "KafkaJSRequestTimeoutError";
    }
  }

  class KafkaJSMetadataNotLoaded extends KafkaJSError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSMetadataNotLoaded";
    }
  }

  class KafkaJSTopicMetadataNotLoaded extends KafkaJSMetadataNotLoaded {
    constructor(e, { topic } = {}) {
      super(e);
      this.topic = topic;
      this.name = "KafkaJSTopicMetadataNotLoaded";
    }
  }

  class KafkaJSStaleTopicMetadataAssignment extends KafkaJSError {
    constructor(e, { topic, unknownPartitions } = {}) {
      super(e);
      this.topic = topic;
      this.unknownPartitions = unknownPartitions;
      this.name = "KafkaJSStaleTopicMetadataAssignment";
    }
  }

  class KafkaJSDeleteGroupsError extends KafkaJSError {
    constructor(e, groups = []) {
      super(e);
      this.groups = groups;
      this.name = "KafkaJSDeleteGroupsError";
    }
  }

  class KafkaJSServerDoesNotSupportApiKey extends KafkaJSNonRetriableError {
    constructor(e, { apiKey, apiName } = {}) {
      super(e);
      this.apiKey = apiKey;
      this.apiName = apiName;
      this.name = "KafkaJSServerDoesNotSupportApiKey";
    }
  }

  class KafkaJSBrokerNotFound extends KafkaJSError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSBrokerNotFound";
    }
  }

  class KafkaJSPartialMessageError extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSPartialMessageError";
    }
  }

  class KafkaJSSASLAuthenticationError extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSSASLAuthenticationError";
    }
  }

  class KafkaJSGroupCoordinatorNotFound extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSGroupCoordinatorNotFound";
    }
  }

  class KafkaJSNotImplemented extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSNotImplemented";
    }
  }

  class KafkaJSTimeout extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSTimeout";
    }
  }

  class KafkaJSLockTimeout extends KafkaJSTimeout {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSLockTimeout";
    }
  }

  class KafkaJSUnsupportedMagicByteInMessageSet extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSUnsupportedMagicByteInMessageSet";
    }
  }

  class KafkaJSDeleteTopicRecordsError extends KafkaJSError {
    constructor({ partitions }) {
      const retriable = partitions.filter(({ error: error40 }) => error40 != null).every(({ error: error40 }) => error40.retriable === true);
      super("Error while deleting records", { retriable });
      this.name = "KafkaJSDeleteTopicRecordsError";
      this.partitions = partitions;
    }
  }
  var issueUrl = bugs ? bugs.url : null;

  class KafkaJSInvariantViolation extends KafkaJSNonRetriableError {
    constructor(e) {
      const message = e.message || e;
      super(`Invariant violated: ${message}. This is likely a bug and should be reported.`);
      this.name = "KafkaJSInvariantViolation";
      if (issueUrl !== null) {
        const issueTitle = encodeURIComponent(`Invariant violation: ${message}`);
        this.helpUrl = `${issueUrl}/new?assignees=&labels=bug&template=bug_report.md&title=${issueTitle}`;
      }
    }
  }

  class KafkaJSInvalidVarIntError extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSNonRetriableError";
    }
  }

  class KafkaJSInvalidLongError extends KafkaJSNonRetriableError {
    constructor() {
      super(...arguments);
      this.name = "KafkaJSNonRetriableError";
    }
  }

  class KafkaJSCreateTopicError extends KafkaJSProtocolError {
    constructor(e, topicName) {
      super(e);
      this.topic = topicName;
      this.name = "KafkaJSCreateTopicError";
    }
  }

  class KafkaJSAlterPartitionReassignmentsError extends KafkaJSProtocolError {
    constructor(e, topicName, partition) {
      super(e);
      this.topic = topicName;
      this.partition = partition;
      this.name = "KafkaJSAlterPartitionReassignmentsError";
    }
  }

  class KafkaJSAggregateError extends Error {
    constructor(message, errors3) {
      super(message);
      this.errors = errors3;
      this.name = "KafkaJSAggregateError";
    }
  }

  class KafkaJSFetcherRebalanceError extends Error {
  }

  class KafkaJSNoBrokerAvailableError extends KafkaJSError {
    constructor() {
      super("No broker available");
      this.name = "KafkaJSNoBrokerAvailableError";
    }
  }
  var isRebalancing = (e) => e.type === "REBALANCE_IN_PROGRESS" || e.type === "NOT_COORDINATOR_FOR_GROUP" || e.type === "ILLEGAL_GENERATION";
  var isKafkaJSError = (e) => e instanceof KafkaJSError;
  module.exports = {
    KafkaJSError,
    KafkaJSNonRetriableError,
    KafkaJSPartialMessageError,
    KafkaJSBrokerNotFound,
    KafkaJSProtocolError,
    KafkaJSConnectionError,
    KafkaJSConnectionClosedError,
    KafkaJSRequestTimeoutError,
    KafkaJSSASLAuthenticationError,
    KafkaJSNumberOfRetriesExceeded,
    KafkaJSOffsetOutOfRange,
    KafkaJSMemberIdRequired,
    KafkaJSGroupCoordinatorNotFound,
    KafkaJSNotImplemented,
    KafkaJSMetadataNotLoaded,
    KafkaJSTopicMetadataNotLoaded,
    KafkaJSStaleTopicMetadataAssignment,
    KafkaJSDeleteGroupsError,
    KafkaJSTimeout,
    KafkaJSLockTimeout,
    KafkaJSServerDoesNotSupportApiKey,
    KafkaJSUnsupportedMagicByteInMessageSet,
    KafkaJSDeleteTopicRecordsError,
    KafkaJSInvariantViolation,
    KafkaJSInvalidVarIntError,
    KafkaJSInvalidLongError,
    KafkaJSCreateTopicError,
    KafkaJSAggregateError,
    KafkaJSFetcherRebalanceError,
    KafkaJSNoBrokerAvailableError,
    KafkaJSAlterPartitionReassignmentsError,
    isRebalancing,
    isKafkaJSError
  };
});

// node_modules/kafkajs/src/instrumentation/emitter.js
var require_emitter = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var InstrumentationEvent = require_event();
  var { KafkaJSError } = require_errors();
  module.exports = class InstrumentationEventEmitter {
    constructor() {
      this.emitter = new EventEmitter;
    }
    emit(eventName, payload) {
      if (!eventName) {
        throw new KafkaJSError("Invalid event name", { retriable: false });
      }
      if (this.emitter.listenerCount(eventName) > 0) {
        const event = new InstrumentationEvent(eventName, payload);
        this.emitter.emit(eventName, event);
      }
    }
    addListener(eventName, listener) {
      this.emitter.addListener(eventName, listener);
      return () => this.emitter.removeListener(eventName, listener);
    }
  };
});

// node_modules/kafkajs/src/loggers/console.js
var require_console = __commonJS((exports, module) => {
  var { LEVELS: logLevel } = require_loggers();
  module.exports = () => ({ namespace, level, label, log: log2 }) => {
    const prefix = namespace ? `[${namespace}] ` : "";
    const message = JSON.stringify(Object.assign({ level: label }, log2, {
      message: `${prefix}${log2.message}`
    }));
    switch (level) {
      case logLevel.INFO:
        return console.info(message);
      case logLevel.ERROR:
        return console.error(message);
      case logLevel.WARN:
        return console.warn(message);
      case logLevel.DEBUG:
        return console.log(message);
    }
  };
});

// node_modules/kafkajs/src/utils/lock.js
var require_lock = __commonJS((exports, module) => {
  var { format } = __require("util");
  var { KafkaJSLockTimeout } = require_errors();
  var PRIVATE = {
    LOCKED: Symbol("private:Lock:locked"),
    TIMEOUT: Symbol("private:Lock:timeout"),
    WAITING: Symbol("private:Lock:waiting"),
    TIMEOUT_ERROR_MESSAGE: Symbol("private:Lock:timeoutErrorMessage")
  };
  var TIMEOUT_MESSAGE = "Timeout while acquiring lock (%d waiting locks)";
  module.exports = class Lock {
    constructor({ timeout, description = null } = {}) {
      if (typeof timeout !== "number") {
        throw new TypeError(`'timeout' is not a number, received '${typeof timeout}'`);
      }
      this[PRIVATE.LOCKED] = false;
      this[PRIVATE.TIMEOUT] = timeout;
      this[PRIVATE.WAITING] = new Set;
      this[PRIVATE.TIMEOUT_ERROR_MESSAGE] = () => {
        const timeoutMessage = format(TIMEOUT_MESSAGE, this[PRIVATE.WAITING].size);
        return description ? `${timeoutMessage}: "${description}"` : timeoutMessage;
      };
    }
    async acquire() {
      return new Promise((resolve, reject) => {
        if (!this[PRIVATE.LOCKED]) {
          this[PRIVATE.LOCKED] = true;
          return resolve();
        }
        let timeoutId = null;
        const tryToAcquire = async () => {
          if (!this[PRIVATE.LOCKED]) {
            this[PRIVATE.LOCKED] = true;
            clearTimeout(timeoutId);
            this[PRIVATE.WAITING].delete(tryToAcquire);
            return resolve();
          }
        };
        this[PRIVATE.WAITING].add(tryToAcquire);
        timeoutId = setTimeout(() => {
          const error40 = new KafkaJSLockTimeout(this[PRIVATE.TIMEOUT_ERROR_MESSAGE]());
          this[PRIVATE.WAITING].delete(tryToAcquire);
          reject(error40);
        }, this[PRIVATE.TIMEOUT]);
      });
    }
    async release() {
      this[PRIVATE.LOCKED] = false;
      const waitingLock = this[PRIVATE.WAITING].values().next().value;
      if (waitingLock) {
        return waitingLock();
      }
    }
  };
});

// node_modules/kafkajs/src/protocol/message/compression/gzip.js
var require_gzip = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var zlib = __require("zlib");
  var gzip = promisify(zlib.gzip);
  var unzip = promisify(zlib.unzip);
  module.exports = {
    async compress(encoder) {
      return await gzip(encoder.buffer);
    },
    async decompress(buffer) {
      return await unzip(buffer);
    }
  };
});

// node_modules/kafkajs/src/protocol/message/compression/index.js
var require_compression = __commonJS((exports, module) => {
  var { KafkaJSNotImplemented } = require_errors();
  var COMPRESSION_CODEC_MASK = 7;
  var Types = {
    None: 0,
    GZIP: 1,
    Snappy: 2,
    LZ4: 3,
    ZSTD: 4
  };
  var Codecs = {
    [Types.GZIP]: () => require_gzip(),
    [Types.Snappy]: () => {
      throw new KafkaJSNotImplemented("Snappy compression not implemented");
    },
    [Types.LZ4]: () => {
      throw new KafkaJSNotImplemented("LZ4 compression not implemented");
    },
    [Types.ZSTD]: () => {
      throw new KafkaJSNotImplemented("ZSTD compression not implemented");
    }
  };
  var lookupCodec = (type) => Codecs[type] ? Codecs[type]() : null;
  var lookupCodecByAttributes = (attributes) => {
    const codec = Codecs[attributes & COMPRESSION_CODEC_MASK];
    return codec ? codec() : null;
  };
  module.exports = {
    Types,
    Codecs,
    lookupCodec,
    lookupCodecByAttributes,
    COMPRESSION_CODEC_MASK
  };
});

// node_modules/kafkajs/src/protocol/requests/apiKeys.js
var require_apiKeys = __commonJS((exports, module) => {
  module.exports = {
    Produce: 0,
    Fetch: 1,
    ListOffsets: 2,
    Metadata: 3,
    LeaderAndIsr: 4,
    StopReplica: 5,
    UpdateMetadata: 6,
    ControlledShutdown: 7,
    OffsetCommit: 8,
    OffsetFetch: 9,
    GroupCoordinator: 10,
    JoinGroup: 11,
    Heartbeat: 12,
    LeaveGroup: 13,
    SyncGroup: 14,
    DescribeGroups: 15,
    ListGroups: 16,
    SaslHandshake: 17,
    ApiVersions: 18,
    CreateTopics: 19,
    DeleteTopics: 20,
    DeleteRecords: 21,
    InitProducerId: 22,
    OffsetForLeaderEpoch: 23,
    AddPartitionsToTxn: 24,
    AddOffsetsToTxn: 25,
    EndTxn: 26,
    WriteTxnMarkers: 27,
    TxnOffsetCommit: 28,
    DescribeAcls: 29,
    CreateAcls: 30,
    DeleteAcls: 31,
    DescribeConfigs: 32,
    AlterConfigs: 33,
    AlterReplicaLogDirs: 34,
    DescribeLogDirs: 35,
    SaslAuthenticate: 36,
    CreatePartitions: 37,
    CreateDelegationToken: 38,
    RenewDelegationToken: 39,
    ExpireDelegationToken: 40,
    DescribeDelegationToken: 41,
    DeleteGroups: 42,
    ElectPreferredLeaders: 43,
    IncrementalAlterConfigs: 44,
    AlterPartitionReassignments: 45,
    ListPartitionReassignments: 46
  };
});

// node_modules/kafkajs/src/utils/long.js
var require_long = __commonJS((exports, module) => {
  class Long {
    constructor(value) {
      this.value = value;
    }
    static isLong(obj) {
      return typeof obj.value === "bigint";
    }
    static fromBits(value) {
      return new Long(BigInt(value));
    }
    static fromInt(value) {
      if (isNaN(value))
        return Long.ZERO;
      return new Long(BigInt.asIntN(64, BigInt(value)));
    }
    static fromNumber(value) {
      if (isNaN(value))
        return Long.ZERO;
      return new Long(BigInt(value));
    }
    static fromValue(val) {
      if (typeof val === "number")
        return this.fromNumber(val);
      if (typeof val === "string")
        return this.fromString(val);
      if (typeof val === "bigint")
        return new Long(val);
      if (this.isLong(val))
        return new Long(BigInt(val.value));
      return new Long(BigInt(val));
    }
    static fromString(str) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return Long.ZERO;
      return new Long(BigInt(str));
    }
    isZero() {
      return this.value === BigInt(0);
    }
    isNegative() {
      return this.value < BigInt(0);
    }
    toString() {
      return String(this.value);
    }
    toNumber() {
      return Number(this.value);
    }
    toInt() {
      return Number(BigInt.asIntN(32, this.value));
    }
    toJSON() {
      return this.toString();
    }
    shiftLeft(numBits) {
      return new Long(this.value << BigInt(numBits));
    }
    shiftRight(numBits) {
      return new Long(this.value >> BigInt(numBits));
    }
    or(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return Long.fromBits(this.value | other.value);
    }
    xor(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return new Long(this.value ^ other.value);
    }
    and(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return new Long(this.value & other.value);
    }
    not() {
      return new Long(~this.value);
    }
    shiftRightUnsigned(numBits) {
      return new Long(this.value >> BigInt.asUintN(64, BigInt(numBits)));
    }
    equals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return this.value === other.value;
    }
    greaterThanOrEqual(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return this.value >= other.value;
    }
    gte(other) {
      return this.greaterThanOrEqual(other);
    }
    notEquals(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return !this.equals(other);
    }
    add(addend) {
      if (!Long.isLong(addend))
        addend = Long.fromValue(addend);
      return new Long(this.value + addend.value);
    }
    subtract(subtrahend) {
      if (!Long.isLong(subtrahend))
        subtrahend = Long.fromValue(subtrahend);
      return this.add(subtrahend.negate());
    }
    multiply(multiplier) {
      if (this.isZero())
        return Long.ZERO;
      if (!Long.isLong(multiplier))
        multiplier = Long.fromValue(multiplier);
      return new Long(this.value * multiplier.value);
    }
    divide(divisor) {
      if (!Long.isLong(divisor))
        divisor = Long.fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      return new Long(this.value / divisor.value);
    }
    compare(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      if (this.value === other.value)
        return 0;
      if (this.value > other.value)
        return 1;
      if (other.value > this.value)
        return -1;
    }
    lessThan(other) {
      if (!Long.isLong(other))
        other = Long.fromValue(other);
      return this.value < other.value;
    }
    negate() {
      if (this.equals(Long.MIN_VALUE)) {
        return Long.MIN_VALUE;
      }
      return this.not().add(Long.ONE);
    }
    getHighBits() {
      return Number(BigInt.asIntN(32, this.value >> BigInt(32)));
    }
    getLowBits() {
      return Number(BigInt.asIntN(32, this.value));
    }
  }
  Long.MIN_VALUE = new Long(BigInt("-9223372036854775808"));
  Long.MAX_VALUE = new Long(BigInt("9223372036854775807"));
  Long.ZERO = Long.fromInt(0);
  Long.ONE = Long.fromInt(1);
  module.exports = Long;
});

// node_modules/kafkajs/src/protocol/encoder.js
var require_encoder = __commonJS((exports, module) => {
  var Long = require_long();
  var INT8_SIZE = 1;
  var INT16_SIZE = 2;
  var INT32_SIZE = 4;
  var INT64_SIZE = 8;
  var DOUBLE_SIZE = 8;
  var MOST_SIGNIFICANT_BIT = 128;
  var OTHER_BITS = 127;
  var UNSIGNED_INT32_MAX_NUMBER = 4294967168;
  var UNSIGNED_INT64_MAX_NUMBER = 0xffffffffffffff80n;
  module.exports = class Encoder {
    static encodeZigZag(value) {
      return value << 1 ^ value >> 31;
    }
    static encodeZigZag64(value) {
      const longValue = Long.fromValue(value);
      return longValue.shiftLeft(1).xor(longValue.shiftRight(63));
    }
    static sizeOfVarInt(value) {
      let encodedValue = this.encodeZigZag(value);
      let bytes = 1;
      while ((encodedValue & UNSIGNED_INT32_MAX_NUMBER) !== 0) {
        bytes += 1;
        encodedValue >>>= 7;
      }
      return bytes;
    }
    static sizeOfVarLong(value) {
      let longValue = Encoder.encodeZigZag64(value);
      let bytes = 1;
      while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {
        bytes += 1;
        longValue = longValue.shiftRightUnsigned(7);
      }
      return bytes;
    }
    static sizeOfVarIntBytes(value) {
      const size = value == null ? -1 : Buffer.byteLength(value);
      if (size < 0) {
        return Encoder.sizeOfVarInt(-1);
      }
      return Encoder.sizeOfVarInt(size) + size;
    }
    static nextPowerOfTwo(value) {
      return 1 << 31 - Math.clz32(value) + 1;
    }
    constructor(initialSize = 511) {
      this.buf = Buffer.alloc(Encoder.nextPowerOfTwo(initialSize));
      this.offset = 0;
    }
    writeBufferInternal(buffer) {
      const bufferLength = buffer.length;
      this.ensureAvailable(bufferLength);
      buffer.copy(this.buf, this.offset, 0);
      this.offset += bufferLength;
    }
    ensureAvailable(length) {
      if (this.offset + length > this.buf.length) {
        const newLength = Encoder.nextPowerOfTwo(this.offset + length);
        const newBuffer = Buffer.alloc(newLength);
        this.buf.copy(newBuffer, 0, 0, this.offset);
        this.buf = newBuffer;
      }
    }
    get buffer() {
      return this.buf.slice(0, this.offset);
    }
    writeInt8(value) {
      this.ensureAvailable(INT8_SIZE);
      this.buf.writeInt8(value, this.offset);
      this.offset += INT8_SIZE;
      return this;
    }
    writeInt16(value) {
      this.ensureAvailable(INT16_SIZE);
      this.buf.writeInt16BE(value, this.offset);
      this.offset += INT16_SIZE;
      return this;
    }
    writeInt32(value) {
      this.ensureAvailable(INT32_SIZE);
      this.buf.writeInt32BE(value, this.offset);
      this.offset += INT32_SIZE;
      return this;
    }
    writeUInt32(value) {
      this.ensureAvailable(INT32_SIZE);
      this.buf.writeUInt32BE(value, this.offset);
      this.offset += INT32_SIZE;
      return this;
    }
    writeInt64(value) {
      this.ensureAvailable(INT64_SIZE);
      const longValue = Long.fromValue(value);
      this.buf.writeInt32BE(longValue.getHighBits(), this.offset);
      this.buf.writeInt32BE(longValue.getLowBits(), this.offset + INT32_SIZE);
      this.offset += INT64_SIZE;
      return this;
    }
    writeDouble(value) {
      this.ensureAvailable(DOUBLE_SIZE);
      this.buf.writeDoubleBE(value, this.offset);
      this.offset += DOUBLE_SIZE;
      return this;
    }
    writeBoolean(value) {
      value ? this.writeInt8(1) : this.writeInt8(0);
      return this;
    }
    writeString(value) {
      if (value == null) {
        this.writeInt16(-1);
        return this;
      }
      const byteLength = Buffer.byteLength(value, "utf8");
      this.ensureAvailable(INT16_SIZE + byteLength);
      this.writeInt16(byteLength);
      this.buf.write(value, this.offset, byteLength, "utf8");
      this.offset += byteLength;
      return this;
    }
    writeVarIntString(value) {
      if (value == null) {
        this.writeVarInt(-1);
        return this;
      }
      const byteLength = Buffer.byteLength(value, "utf8");
      this.writeVarInt(byteLength);
      this.ensureAvailable(byteLength);
      this.buf.write(value, this.offset, byteLength, "utf8");
      this.offset += byteLength;
      return this;
    }
    writeUVarIntString(value) {
      if (value == null) {
        this.writeUVarInt(0);
        return this;
      }
      const byteLength = Buffer.byteLength(value, "utf8");
      this.writeUVarInt(byteLength + 1);
      this.ensureAvailable(byteLength);
      this.buf.write(value, this.offset, byteLength, "utf8");
      this.offset += byteLength;
      return this;
    }
    writeBytes(value) {
      if (value == null) {
        this.writeInt32(-1);
        return this;
      }
      if (Buffer.isBuffer(value)) {
        this.ensureAvailable(INT32_SIZE + value.length);
        this.writeInt32(value.length);
        this.writeBufferInternal(value);
      } else {
        const valueToWrite = String(value);
        const byteLength = Buffer.byteLength(valueToWrite, "utf8");
        this.ensureAvailable(INT32_SIZE + byteLength);
        this.writeInt32(byteLength);
        this.buf.write(valueToWrite, this.offset, byteLength, "utf8");
        this.offset += byteLength;
      }
      return this;
    }
    writeVarIntBytes(value) {
      if (value == null) {
        this.writeVarInt(-1);
        return this;
      }
      if (Buffer.isBuffer(value)) {
        this.writeVarInt(value.length);
        this.writeBufferInternal(value);
      } else {
        const valueToWrite = String(value);
        const byteLength = Buffer.byteLength(valueToWrite, "utf8");
        this.writeVarInt(byteLength);
        this.ensureAvailable(byteLength);
        this.buf.write(valueToWrite, this.offset, byteLength, "utf8");
        this.offset += byteLength;
      }
      return this;
    }
    writeUVarIntBytes(value) {
      if (value == null) {
        this.writeVarInt(0);
        return this;
      }
      if (Buffer.isBuffer(value)) {
        this.writeUVarInt(value.length + 1);
        this.writeBufferInternal(value);
      } else {
        const valueToWrite = String(value);
        const byteLength = Buffer.byteLength(valueToWrite, "utf8");
        this.writeUVarInt(byteLength + 1);
        this.ensureAvailable(byteLength);
        this.buf.write(valueToWrite, this.offset, byteLength, "utf8");
        this.offset += byteLength;
      }
      return this;
    }
    writeEncoder(value) {
      if (value == null || !Buffer.isBuffer(value.buf)) {
        throw new Error("value should be an instance of Encoder");
      }
      this.writeBufferInternal(value.buffer);
      return this;
    }
    writeEncoderArray(value) {
      if (!Array.isArray(value) || value.some((v) => v == null || !Buffer.isBuffer(v.buf))) {
        throw new Error("all values should be an instance of Encoder[]");
      }
      value.forEach((v) => {
        this.writeBufferInternal(v.buffer);
      });
      return this;
    }
    writeBuffer(value) {
      if (!Buffer.isBuffer(value)) {
        throw new Error("value should be an instance of Buffer");
      }
      this.writeBufferInternal(value);
      return this;
    }
    writeNullableArray(array2, type) {
      const length = array2.length !== 0 ? array2.length : -1;
      this.writeArray(array2, type, length);
      return this;
    }
    writeArray(array2, type, length) {
      const arrayLength = length == null ? array2.length : length;
      this.writeInt32(arrayLength);
      if (type !== undefined) {
        switch (type) {
          case "int32":
          case "number":
            array2.forEach((value) => this.writeInt32(value));
            break;
          case "string":
            array2.forEach((value) => this.writeString(value));
            break;
          case "object":
            this.writeEncoderArray(array2);
            break;
        }
      } else {
        array2.forEach((value) => {
          switch (typeof value) {
            case "number":
              this.writeInt32(value);
              break;
            case "string":
              this.writeString(value);
              break;
            case "object":
              this.writeEncoder(value);
              break;
          }
        });
      }
      return this;
    }
    writeVarIntArray(array2, type) {
      if (type === "object") {
        this.writeVarInt(array2.length);
        this.writeEncoderArray(array2);
      } else {
        const objectArray = array2.filter((v) => typeof v === "object");
        this.writeVarInt(objectArray.length);
        this.writeEncoderArray(objectArray);
      }
      return this;
    }
    writeUVarIntArray(array2, type) {
      if (type === "object") {
        this.writeUVarInt(array2.length + 1);
        this.writeEncoderArray(array2);
      } else if (array2 === null) {
        this.writeUVarInt(0);
      } else {
        const objectArray = array2.filter((v) => typeof v === "object");
        this.writeUVarInt(objectArray.length + 1);
        this.writeEncoderArray(objectArray);
      }
      return this;
    }
    writeVarInt(value) {
      return this.writeUVarInt(Encoder.encodeZigZag(value));
    }
    writeUVarInt(value) {
      const byteArray = [];
      while ((value & UNSIGNED_INT32_MAX_NUMBER) !== 0) {
        byteArray.push(value & OTHER_BITS | MOST_SIGNIFICANT_BIT);
        value >>>= 7;
      }
      byteArray.push(value & OTHER_BITS);
      this.writeBufferInternal(Buffer.from(byteArray));
      return this;
    }
    writeVarLong(value) {
      const byteArray = [];
      let longValue = Encoder.encodeZigZag64(value);
      while (longValue.and(UNSIGNED_INT64_MAX_NUMBER).notEquals(Long.fromInt(0))) {
        byteArray.push(longValue.and(OTHER_BITS).or(MOST_SIGNIFICANT_BIT).toInt());
        longValue = longValue.shiftRightUnsigned(7);
      }
      byteArray.push(longValue.toInt());
      this.writeBufferInternal(Buffer.from(byteArray));
      return this;
    }
    size() {
      return this.offset;
    }
    toJSON() {
      return this.buffer.toJSON();
    }
  };
});

// node_modules/kafkajs/src/protocol/crc32.js
var require_crc32 = __commonJS((exports, module) => {
  var CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  module.exports = (encoder) => {
    const { buffer } = encoder;
    const l = buffer.length;
    let crc = -1;
    for (let n = 0;n < l; n++) {
      crc = CRC_TABLE[(crc ^ buffer[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// node_modules/kafkajs/src/protocol/message/v0/index.js
var require_v0 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var crc32 = require_crc32();
  var { Types: Compression, COMPRESSION_CODEC_MASK } = require_compression();
  module.exports = ({ compression = Compression.None, key, value }) => {
    const content = new Encoder().writeInt8(0).writeInt8(compression & COMPRESSION_CODEC_MASK).writeBytes(key).writeBytes(value);
    const crc = crc32(content);
    return new Encoder().writeInt32(crc).writeEncoder(content);
  };
});

// node_modules/kafkajs/src/protocol/message/v1/index.js
var require_v1 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var crc32 = require_crc32();
  var { Types: Compression, COMPRESSION_CODEC_MASK } = require_compression();
  module.exports = ({ compression = Compression.None, timestamp = Date.now(), key, value }) => {
    const content = new Encoder().writeInt8(1).writeInt8(compression & COMPRESSION_CODEC_MASK).writeInt64(timestamp).writeBytes(key).writeBytes(value);
    const crc = crc32(content);
    return new Encoder().writeInt32(crc).writeEncoder(content);
  };
});

// node_modules/kafkajs/src/protocol/message/index.js
var require_message = __commonJS((exports, module) => {
  var versions2 = {
    0: require_v0(),
    1: require_v1()
  };
  module.exports = ({ version: version2 = 0 }) => versions2[version2];
});

// node_modules/kafkajs/src/protocol/messageSet/index.js
var require_messageSet = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var MessageProtocol = require_message();
  var { Types } = require_compression();
  module.exports = ({ messageVersion = 0, compression, entries }) => {
    const isCompressed = compression !== Types.None;
    const Message = MessageProtocol({ version: messageVersion });
    const encoder = new Encoder;
    entries.forEach((entry, i) => {
      const message = Message(entry);
      encoder.writeInt64(isCompressed ? i : -1);
      encoder.writeInt32(message.size());
      encoder.writeEncoder(message);
    });
    return encoder;
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v0/request.js
var require_request = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Produce: apiKey } = require_apiKeys();
  var MessageSet = require_messageSet();
  module.exports = ({ acks, timeout, topicData }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "Produce",
    expectResponse: () => acks !== 0,
    encode: async () => {
      return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(topicData.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartitions));
  };
  var encodePartitions = ({ partition, messages }) => {
    const messageSet = MessageSet({ messageVersion: 0, entries: messages });
    return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);
  };
});

// node_modules/kafkajs/src/protocol/decoder.js
var require_decoder = __commonJS((exports, module) => {
  var { KafkaJSInvalidVarIntError, KafkaJSInvalidLongError } = require_errors();
  var Long = require_long();
  var INT8_SIZE = 1;
  var INT16_SIZE = 2;
  var INT32_SIZE = 4;
  var INT64_SIZE = 8;
  var DOUBLE_SIZE = 8;
  var MOST_SIGNIFICANT_BIT = 128;
  var OTHER_BITS = 127;
  module.exports = class Decoder {
    static int32Size() {
      return INT32_SIZE;
    }
    static decodeZigZag(value) {
      return value >>> 1 ^ -(value & 1);
    }
    static decodeZigZag64(longValue) {
      return longValue.shiftRightUnsigned(1).xor(longValue.and(Long.fromInt(1)).negate());
    }
    constructor(buffer) {
      this.buffer = buffer;
      this.offset = 0;
    }
    readInt8() {
      const value = this.buffer.readInt8(this.offset);
      this.offset += INT8_SIZE;
      return value;
    }
    canReadInt16() {
      return this.canReadBytes(INT16_SIZE);
    }
    readInt16() {
      const value = this.buffer.readInt16BE(this.offset);
      this.offset += INT16_SIZE;
      return value;
    }
    canReadInt32() {
      return this.canReadBytes(INT32_SIZE);
    }
    readInt32() {
      const value = this.buffer.readInt32BE(this.offset);
      this.offset += INT32_SIZE;
      return value;
    }
    canReadInt64() {
      return this.canReadBytes(INT64_SIZE);
    }
    readInt64() {
      const first = this.buffer[this.offset];
      const last = this.buffer[this.offset + 7];
      const low = (first << 24) + this.buffer[this.offset + 1] * 2 ** 16 + this.buffer[this.offset + 2] * 2 ** 8 + this.buffer[this.offset + 3];
      const high = this.buffer[this.offset + 4] * 2 ** 24 + this.buffer[this.offset + 5] * 2 ** 16 + this.buffer[this.offset + 6] * 2 ** 8 + last;
      this.offset += INT64_SIZE;
      return (BigInt(low) << 32n) + BigInt(high);
    }
    readDouble() {
      const value = this.buffer.readDoubleBE(this.offset);
      this.offset += DOUBLE_SIZE;
      return value;
    }
    readString() {
      const byteLength = this.readInt16();
      if (byteLength === -1) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
      const value = stringBuffer.toString("utf8");
      this.offset += byteLength;
      return value;
    }
    readVarIntString() {
      const byteLength = this.readVarInt();
      if (byteLength === -1) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
      const value = stringBuffer.toString("utf8");
      this.offset += byteLength;
      return value;
    }
    readUVarIntString() {
      const byteLength = this.readUVarInt();
      if (byteLength === 0) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength - 1);
      const value = stringBuffer.toString("utf8");
      this.offset += byteLength - 1;
      return value;
    }
    canReadBytes(length) {
      return Buffer.byteLength(this.buffer) - this.offset >= length;
    }
    readBytes(byteLength = this.readInt32()) {
      if (byteLength === -1) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
      this.offset += byteLength;
      return stringBuffer;
    }
    readVarIntBytes() {
      const byteLength = this.readVarInt();
      if (byteLength === -1) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
      this.offset += byteLength;
      return stringBuffer;
    }
    readUVarIntBytes() {
      const byteLength = this.readUVarInt();
      if (byteLength === 0) {
        return null;
      }
      const stringBuffer = this.buffer.slice(this.offset, this.offset + byteLength);
      this.offset += byteLength - 1;
      return stringBuffer;
    }
    readBoolean() {
      return this.readInt8() === 1;
    }
    readAll() {
      const result = this.buffer.slice(this.offset);
      this.offset += Buffer.byteLength(this.buffer);
      return result;
    }
    readArray(reader) {
      const length = this.readInt32();
      if (length === -1) {
        return [];
      }
      const array2 = new Array(length);
      for (let i = 0;i < length; i++) {
        array2[i] = reader(this);
      }
      return array2;
    }
    readVarIntArray(reader) {
      const length = this.readVarInt();
      if (length === -1) {
        return [];
      }
      const array2 = new Array(length);
      for (let i = 0;i < length; i++) {
        array2[i] = reader(this);
      }
      return array2;
    }
    readUVarIntArray(reader) {
      const length = this.readUVarInt();
      if (length === 0) {
        return null;
      }
      const array2 = new Array(length - 1);
      for (let i = 0;i < length - 1; i++) {
        array2[i] = reader(this);
      }
      return array2;
    }
    async readArrayAsync(reader) {
      const length = this.readInt32();
      if (length === -1) {
        return [];
      }
      const array2 = new Array(length);
      for (let i = 0;i < length; i++) {
        array2[i] = await reader(this);
      }
      return array2;
    }
    readVarInt() {
      let currentByte;
      let result = 0;
      let i = 0;
      do {
        currentByte = this.buffer[this.offset++];
        result += (currentByte & OTHER_BITS) << i;
        i += 7;
      } while (currentByte >= MOST_SIGNIFICANT_BIT);
      return Decoder.decodeZigZag(result);
    }
    readUVarInt() {
      let currentByte;
      let result = 0;
      let i = 0;
      while (((currentByte = this.buffer[this.offset++]) & MOST_SIGNIFICANT_BIT) !== 0) {
        result |= (currentByte & OTHER_BITS) << i;
        i += 7;
        if (i > 28) {
          throw new KafkaJSInvalidVarIntError("Invalid VarInt, must contain 5 bytes or less");
        }
      }
      result |= currentByte << i;
      return result >>> 0;
    }
    readTaggedFields() {
      const numberOfTaggedFields = this.readUVarInt();
      if (numberOfTaggedFields === 0) {
        return null;
      }
      const taggedFields = {};
      for (let i = 0;i < numberOfTaggedFields; i++) {
        this.readUVarInt();
        this.readUVarIntBytes();
      }
      return taggedFields;
    }
    readVarLong() {
      let currentByte;
      let result = Long.fromInt(0);
      let i = 0;
      do {
        if (i > 63) {
          throw new KafkaJSInvalidLongError("Invalid Long, must contain 9 bytes or less");
        }
        currentByte = this.buffer[this.offset++];
        result = result.add(Long.fromInt(currentByte & OTHER_BITS).shiftLeft(i));
        i += 7;
      } while (currentByte >= MOST_SIGNIFICANT_BIT);
      return Decoder.decodeZigZag64(result);
    }
    slice(size) {
      return new Decoder(this.buffer.slice(this.offset, this.offset + size));
    }
    forward(size) {
      this.offset += size;
    }
  };
});

// node_modules/kafkajs/src/utils/websiteUrl.js
var require_websiteUrl = __commonJS((exports, module) => {
  var BASE_URL = "https://kafka.js.org";
  var stripLeading = (char) => (str) => str.charAt(0) === char ? str.substring(1) : str;
  var stripLeadingSlash = stripLeading("/");
  var stripLeadingHash = stripLeading("#");
  module.exports = (path, hash) => `${BASE_URL}/${stripLeadingSlash(path)}${hash ? "#" + stripLeadingHash(hash) : ""}`;
});

// node_modules/kafkajs/src/protocol/error.js
var require_error = __commonJS((exports, module) => {
  var { KafkaJSProtocolError } = require_errors();
  var websiteUrl = require_websiteUrl();
  var errorCodes = [
    {
      type: "UNKNOWN",
      code: -1,
      retriable: false,
      message: "The server experienced an unexpected error when processing the request"
    },
    {
      type: "OFFSET_OUT_OF_RANGE",
      code: 1,
      retriable: false,
      message: "The requested offset is not within the range of offsets maintained by the server"
    },
    {
      type: "CORRUPT_MESSAGE",
      code: 2,
      retriable: true,
      message: "This message has failed its CRC checksum, exceeds the valid size, or is otherwise corrupt"
    },
    {
      type: "UNKNOWN_TOPIC_OR_PARTITION",
      code: 3,
      retriable: true,
      message: "This server does not host this topic-partition"
    },
    {
      type: "INVALID_FETCH_SIZE",
      code: 4,
      retriable: false,
      message: "The requested fetch size is invalid"
    },
    {
      type: "LEADER_NOT_AVAILABLE",
      code: 5,
      retriable: true,
      message: "There is no leader for this topic-partition as we are in the middle of a leadership election"
    },
    {
      type: "NOT_LEADER_FOR_PARTITION",
      code: 6,
      retriable: true,
      message: "This server is not the leader for that topic-partition"
    },
    {
      type: "REQUEST_TIMED_OUT",
      code: 7,
      retriable: true,
      message: "The request timed out"
    },
    {
      type: "BROKER_NOT_AVAILABLE",
      code: 8,
      retriable: false,
      message: "The broker is not available"
    },
    {
      type: "REPLICA_NOT_AVAILABLE",
      code: 9,
      retriable: true,
      message: "The replica is not available for the requested topic-partition"
    },
    {
      type: "MESSAGE_TOO_LARGE",
      code: 10,
      retriable: false,
      message: "The request included a message larger than the max message size the server will accept"
    },
    {
      type: "STALE_CONTROLLER_EPOCH",
      code: 11,
      retriable: false,
      message: "The controller moved to another broker"
    },
    {
      type: "OFFSET_METADATA_TOO_LARGE",
      code: 12,
      retriable: false,
      message: "The metadata field of the offset request was too large"
    },
    {
      type: "NETWORK_EXCEPTION",
      code: 13,
      retriable: true,
      message: "The server disconnected before a response was received"
    },
    {
      type: "GROUP_LOAD_IN_PROGRESS",
      code: 14,
      retriable: true,
      message: "The coordinator is loading and hence can't process requests for this group"
    },
    {
      type: "GROUP_COORDINATOR_NOT_AVAILABLE",
      code: 15,
      retriable: true,
      message: "The group coordinator is not available"
    },
    {
      type: "NOT_COORDINATOR_FOR_GROUP",
      code: 16,
      retriable: true,
      message: "This is not the correct coordinator for this group"
    },
    {
      type: "INVALID_TOPIC_EXCEPTION",
      code: 17,
      retriable: false,
      message: "The request attempted to perform an operation on an invalid topic"
    },
    {
      type: "RECORD_LIST_TOO_LARGE",
      code: 18,
      retriable: false,
      message: "The request included message batch larger than the configured segment size on the server"
    },
    {
      type: "NOT_ENOUGH_REPLICAS",
      code: 19,
      retriable: true,
      message: "Messages are rejected since there are fewer in-sync replicas than required"
    },
    {
      type: "NOT_ENOUGH_REPLICAS_AFTER_APPEND",
      code: 20,
      retriable: true,
      message: "Messages are written to the log, but to fewer in-sync replicas than required"
    },
    {
      type: "INVALID_REQUIRED_ACKS",
      code: 21,
      retriable: false,
      message: "Produce request specified an invalid value for required acks"
    },
    {
      type: "ILLEGAL_GENERATION",
      code: 22,
      retriable: false,
      message: "Specified group generation id is not valid"
    },
    {
      type: "INCONSISTENT_GROUP_PROTOCOL",
      code: 23,
      retriable: false,
      message: "The group member's supported protocols are incompatible with those of existing members"
    },
    {
      type: "INVALID_GROUP_ID",
      code: 24,
      retriable: false,
      message: "The configured groupId is invalid"
    },
    {
      type: "UNKNOWN_MEMBER_ID",
      code: 25,
      retriable: false,
      message: "The coordinator is not aware of this member"
    },
    {
      type: "INVALID_SESSION_TIMEOUT",
      code: 26,
      retriable: false,
      message: "The session timeout is not within the range allowed by the broker (as configured by group.min.session.timeout.ms and group.max.session.timeout.ms)"
    },
    {
      type: "REBALANCE_IN_PROGRESS",
      code: 27,
      retriable: false,
      message: "The group is rebalancing, so a rejoin is needed",
      helpUrl: websiteUrl("docs/faq", "what-does-it-mean-to-get-rebalance-in-progress-errors")
    },
    {
      type: "INVALID_COMMIT_OFFSET_SIZE",
      code: 28,
      retriable: false,
      message: "The committing offset data size is not valid"
    },
    {
      type: "TOPIC_AUTHORIZATION_FAILED",
      code: 29,
      retriable: false,
      message: "Not authorized to access topics: [Topic authorization failed]"
    },
    {
      type: "GROUP_AUTHORIZATION_FAILED",
      code: 30,
      retriable: false,
      message: "Not authorized to access group: Group authorization failed"
    },
    {
      type: "CLUSTER_AUTHORIZATION_FAILED",
      code: 31,
      retriable: false,
      message: "Cluster authorization failed"
    },
    {
      type: "INVALID_TIMESTAMP",
      code: 32,
      retriable: false,
      message: "The timestamp of the message is out of acceptable range"
    },
    {
      type: "UNSUPPORTED_SASL_MECHANISM",
      code: 33,
      retriable: false,
      message: "The broker does not support the requested SASL mechanism"
    },
    {
      type: "ILLEGAL_SASL_STATE",
      code: 34,
      retriable: false,
      message: "Request is not valid given the current SASL state"
    },
    {
      type: "UNSUPPORTED_VERSION",
      code: 35,
      retriable: false,
      message: "The version of API is not supported"
    },
    {
      type: "TOPIC_ALREADY_EXISTS",
      code: 36,
      retriable: false,
      message: "Topic with this name already exists"
    },
    {
      type: "INVALID_PARTITIONS",
      code: 37,
      retriable: false,
      message: "Number of partitions is invalid"
    },
    {
      type: "INVALID_REPLICATION_FACTOR",
      code: 38,
      retriable: false,
      message: "Replication-factor is invalid"
    },
    {
      type: "INVALID_REPLICA_ASSIGNMENT",
      code: 39,
      retriable: false,
      message: "Replica assignment is invalid"
    },
    {
      type: "INVALID_CONFIG",
      code: 40,
      retriable: false,
      message: "Configuration is invalid"
    },
    {
      type: "NOT_CONTROLLER",
      code: 41,
      retriable: true,
      message: "This is not the correct controller for this cluster"
    },
    {
      type: "INVALID_REQUEST",
      code: 42,
      retriable: false,
      message: "This most likely occurs because of a request being malformed by the client library or the message was sent to an incompatible broker. See the broker logs for more details"
    },
    {
      type: "UNSUPPORTED_FOR_MESSAGE_FORMAT",
      code: 43,
      retriable: false,
      message: "The message format version on the broker does not support the request"
    },
    {
      type: "POLICY_VIOLATION",
      code: 44,
      retriable: false,
      message: "Request parameters do not satisfy the configured policy"
    },
    {
      type: "OUT_OF_ORDER_SEQUENCE_NUMBER",
      code: 45,
      retriable: false,
      message: "The broker received an out of order sequence number"
    },
    {
      type: "DUPLICATE_SEQUENCE_NUMBER",
      code: 46,
      retriable: false,
      message: "The broker received a duplicate sequence number"
    },
    {
      type: "INVALID_PRODUCER_EPOCH",
      code: 47,
      retriable: false,
      message: "Producer attempted an operation with an old epoch. Either there is a newer producer with the same transactionalId, or the producer's transaction has been expired by the broker"
    },
    {
      type: "INVALID_TXN_STATE",
      code: 48,
      retriable: false,
      message: "The producer attempted a transactional operation in an invalid state"
    },
    {
      type: "INVALID_PRODUCER_ID_MAPPING",
      code: 49,
      retriable: false,
      message: "The producer attempted to use a producer id which is not currently assigned to its transactional id"
    },
    {
      type: "INVALID_TRANSACTION_TIMEOUT",
      code: 50,
      retriable: false,
      message: "The transaction timeout is larger than the maximum value allowed by the broker (as configured by max.transaction.timeout.ms)"
    },
    {
      type: "CONCURRENT_TRANSACTIONS",
      code: 51,
      retriable: true,
      message: "The producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing"
    },
    {
      type: "TRANSACTION_COORDINATOR_FENCED",
      code: 52,
      retriable: false,
      message: "Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer"
    },
    {
      type: "TRANSACTIONAL_ID_AUTHORIZATION_FAILED",
      code: 53,
      retriable: false,
      message: "Transactional Id authorization failed"
    },
    {
      type: "SECURITY_DISABLED",
      code: 54,
      retriable: false,
      message: "Security features are disabled"
    },
    {
      type: "OPERATION_NOT_ATTEMPTED",
      code: 55,
      retriable: false,
      message: "The broker did not attempt to execute this operation. This may happen for batched RPCs where some operations in the batch failed, causing the broker to respond without trying the rest"
    },
    {
      type: "KAFKA_STORAGE_ERROR",
      code: 56,
      retriable: true,
      message: "Disk error when trying to access log file on the disk"
    },
    {
      type: "LOG_DIR_NOT_FOUND",
      code: 57,
      retriable: false,
      message: "The user-specified log directory is not found in the broker config"
    },
    {
      type: "SASL_AUTHENTICATION_FAILED",
      code: 58,
      retriable: false,
      message: "SASL Authentication failed",
      helpUrl: websiteUrl("docs/configuration", "sasl")
    },
    {
      type: "UNKNOWN_PRODUCER_ID",
      code: 59,
      retriable: false,
      message: "This exception is raised by the broker if it could not locate the producer metadata associated with the producerId in question. This could happen if, for instance, the producer's records were deleted because their retention time had elapsed. Once the last records of the producerId are removed, the producer's metadata is removed from the broker, and future appends by the producer will return this exception"
    },
    {
      type: "REASSIGNMENT_IN_PROGRESS",
      code: 60,
      retriable: false,
      message: "A partition reassignment is in progress"
    },
    {
      type: "DELEGATION_TOKEN_AUTH_DISABLED",
      code: 61,
      retriable: false,
      message: "Delegation Token feature is not enabled"
    },
    {
      type: "DELEGATION_TOKEN_NOT_FOUND",
      code: 62,
      retriable: false,
      message: "Delegation Token is not found on server"
    },
    {
      type: "DELEGATION_TOKEN_OWNER_MISMATCH",
      code: 63,
      retriable: false,
      message: "Specified Principal is not valid Owner/Renewer"
    },
    {
      type: "DELEGATION_TOKEN_REQUEST_NOT_ALLOWED",
      code: 64,
      retriable: false,
      message: "Delegation Token requests are not allowed on PLAINTEXT/1-way SSL channels and on delegation token authenticated channels"
    },
    {
      type: "DELEGATION_TOKEN_AUTHORIZATION_FAILED",
      code: 65,
      retriable: false,
      message: "Delegation Token authorization failed"
    },
    {
      type: "DELEGATION_TOKEN_EXPIRED",
      code: 66,
      retriable: false,
      message: "Delegation Token is expired"
    },
    {
      type: "INVALID_PRINCIPAL_TYPE",
      code: 67,
      retriable: false,
      message: "Supplied principalType is not supported"
    },
    {
      type: "NON_EMPTY_GROUP",
      code: 68,
      retriable: false,
      message: "The group is not empty"
    },
    {
      type: "GROUP_ID_NOT_FOUND",
      code: 69,
      retriable: false,
      message: "The group id was not found"
    },
    {
      type: "FETCH_SESSION_ID_NOT_FOUND",
      code: 70,
      retriable: true,
      message: "The fetch session ID was not found"
    },
    {
      type: "INVALID_FETCH_SESSION_EPOCH",
      code: 71,
      retriable: true,
      message: "The fetch session epoch is invalid"
    },
    {
      type: "LISTENER_NOT_FOUND",
      code: 72,
      retriable: true,
      message: "There is no listener on the leader broker that matches the listener on which metadata request was processed"
    },
    {
      type: "TOPIC_DELETION_DISABLED",
      code: 73,
      retriable: false,
      message: "Topic deletion is disabled"
    },
    {
      type: "FENCED_LEADER_EPOCH",
      code: 74,
      retriable: true,
      message: "The leader epoch in the request is older than the epoch on the broker"
    },
    {
      type: "UNKNOWN_LEADER_EPOCH",
      code: 75,
      retriable: true,
      message: "The leader epoch in the request is newer than the epoch on the broker"
    },
    {
      type: "UNSUPPORTED_COMPRESSION_TYPE",
      code: 76,
      retriable: false,
      message: "The requesting client does not support the compression type of given partition"
    },
    {
      type: "STALE_BROKER_EPOCH",
      code: 77,
      retriable: false,
      message: "Broker epoch has changed"
    },
    {
      type: "OFFSET_NOT_AVAILABLE",
      code: 78,
      retriable: true,
      message: "The leader high watermark has not caught up from a recent leader election so the offsets cannot be guaranteed to be monotonically increasing"
    },
    {
      type: "MEMBER_ID_REQUIRED",
      code: 79,
      retriable: false,
      message: "The group member needs to have a valid member id before actually entering a consumer group"
    },
    {
      type: "PREFERRED_LEADER_NOT_AVAILABLE",
      code: 80,
      retriable: true,
      message: "The preferred leader was not available"
    },
    {
      type: "GROUP_MAX_SIZE_REACHED",
      code: 81,
      retriable: false,
      message: "The consumer group has reached its max size. It already has the configured maximum number of members"
    },
    {
      type: "FENCED_INSTANCE_ID",
      code: 82,
      retriable: false,
      message: "The broker rejected this static consumer since another consumer with the same group instance id has registered with a different member id"
    },
    {
      type: "ELIGIBLE_LEADERS_NOT_AVAILABLE",
      code: 83,
      retriable: true,
      message: "Eligible topic partition leaders are not available"
    },
    {
      type: "ELECTION_NOT_NEEDED",
      code: 84,
      retriable: true,
      message: "Leader election not needed for topic partition"
    },
    {
      type: "NO_REASSIGNMENT_IN_PROGRESS",
      code: 85,
      retriable: false,
      message: "No partition reassignment is in progress"
    },
    {
      type: "GROUP_SUBSCRIBED_TO_TOPIC",
      code: 86,
      retriable: false,
      message: "Deleting offsets of a topic is forbidden while the consumer group is actively subscribed to it"
    },
    {
      type: "INVALID_RECORD",
      code: 87,
      retriable: false,
      message: "This record has failed the validation on broker and hence be rejected"
    },
    {
      type: "UNSTABLE_OFFSET_COMMIT",
      code: 88,
      retriable: true,
      message: "There are unstable offsets that need to be cleared"
    }
  ];
  var unknownErrorCode = (errorCode) => ({
    type: "KAFKAJS_UNKNOWN_ERROR_CODE",
    code: -99,
    retriable: false,
    message: `Unknown error code ${errorCode}`
  });
  var SUCCESS_CODE = 0;
  var UNSUPPORTED_VERSION_CODE = 35;
  var failure = (code) => code !== SUCCESS_CODE;
  var createErrorFromCode = (code) => {
    return new KafkaJSProtocolError(errorCodes.find((e) => e.code === code) || unknownErrorCode(code));
  };
  var failIfVersionNotSupported = (code) => {
    if (code === UNSUPPORTED_VERSION_CODE) {
      throw createErrorFromCode(UNSUPPORTED_VERSION_CODE);
    }
  };
  var staleMetadata = (e) => ["UNKNOWN_TOPIC_OR_PARTITION", "LEADER_NOT_AVAILABLE", "NOT_LEADER_FOR_PARTITION"].includes(e.type);
  module.exports = {
    failure,
    errorCodes,
    createErrorFromCode,
    failIfVersionNotSupported,
    staleMetadata
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v0/response.js
var require_response = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var partition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    offset: decoder.readInt64().toString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const topics = decoder.readArray((decoder2) => ({
      topicName: decoder2.readString(),
      partitions: decoder2.readArray(partition)
    }));
    return {
      topics
    };
  };
  var parse6 = async (data) => {
    const errors3 = data.topics.flatMap((topic) => {
      return topic.partitions.filter((partition2) => failure(partition2.errorCode));
    });
    if (errors3.length > 0) {
      const { errorCode } = errors3[0];
      throw createErrorFromCode(errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v1/request.js
var require_request2 = __commonJS((exports, module) => {
  var requestV0 = require_request();
  module.exports = ({ acks, timeout, topicData }) => {
    return Object.assign(requestV0({ acks, timeout, topicData }), { apiVersion: 1 });
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v1/response.js
var require_response2 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response();
  var partition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    offset: decoder.readInt64().toString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const topics = decoder.readArray((decoder2) => ({
      topicName: decoder2.readString(),
      partitions: decoder2.readArray(partition)
    }));
    const throttleTime = decoder.readInt32();
    return {
      topics,
      throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v2/request.js
var require_request3 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Produce: apiKey } = require_apiKeys();
  var MessageSet = require_messageSet();
  var { Types, lookupCodec } = require_compression();
  module.exports = ({ acks, timeout, compression = Types.None, topicData }) => ({
    apiKey,
    apiVersion: 2,
    apiName: "Produce",
    expectResponse: () => acks !== 0,
    encode: async () => {
      const encodeTopic = topicEncoder(compression);
      const encodedTopicData = [];
      for (const data of topicData) {
        encodedTopicData.push(await encodeTopic(data));
      }
      return new Encoder().writeInt16(acks).writeInt32(timeout).writeArray(encodedTopicData);
    }
  });
  var topicEncoder = (compression) => {
    const encodePartitions = partitionsEncoder(compression);
    return async ({ topic, partitions }) => {
      const encodedPartitions = [];
      for (const data of partitions) {
        encodedPartitions.push(await encodePartitions(data));
      }
      return new Encoder().writeString(topic).writeArray(encodedPartitions);
    };
  };
  var partitionsEncoder = (compression) => async ({ partition, messages }) => {
    const messageSet = MessageSet({ messageVersion: 1, compression, entries: messages });
    if (compression === Types.None) {
      return new Encoder().writeInt32(partition).writeInt32(messageSet.size()).writeEncoder(messageSet);
    }
    const timestamp = messages[0].timestamp || Date.now();
    const codec = lookupCodec(compression);
    const compressedValue = await codec.compress(messageSet);
    const compressedMessageSet = MessageSet({
      messageVersion: 1,
      entries: [{ compression, timestamp, value: compressedValue }]
    });
    return new Encoder().writeInt32(partition).writeInt32(compressedMessageSet.size()).writeEncoder(compressedMessageSet);
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v2/response.js
var require_response3 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response();
  var partition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    offset: decoder.readInt64().toString(),
    timestamp: decoder.readInt64().toString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const topics = decoder.readArray((decoder2) => ({
      topicName: decoder2.readString(),
      partitions: decoder2.readArray(partition)
    }));
    const throttleTime = decoder.readInt32();
    return {
      topics,
      throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/header/v0/index.js
var require_v02 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  module.exports = ({ key, value }) => {
    return new Encoder().writeVarIntString(key).writeVarIntBytes(value);
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/record/v0/index.js
var require_v03 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var Header = require_v02();
  module.exports = ({ offsetDelta = 0, timestampDelta = 0, key, value, headers = {} }) => {
    const headersArray = Object.keys(headers).flatMap((headerKey) => !Array.isArray(headers[headerKey]) ? [{ key: headerKey, value: headers[headerKey] }] : headers[headerKey].map((headerValue) => ({ key: headerKey, value: headerValue })));
    const sizeOfBody = 1 + Encoder.sizeOfVarLong(timestampDelta) + Encoder.sizeOfVarInt(offsetDelta) + Encoder.sizeOfVarIntBytes(key) + Encoder.sizeOfVarIntBytes(value) + sizeOfHeaders(headersArray);
    return new Encoder().writeVarInt(sizeOfBody).writeInt8(0).writeVarLong(timestampDelta).writeVarInt(offsetDelta).writeVarIntBytes(key).writeVarIntBytes(value).writeVarIntArray(headersArray.map(Header));
  };
  var sizeOfHeaders = (headersArray) => {
    let size = Encoder.sizeOfVarInt(headersArray.length);
    for (const header of headersArray) {
      const keySize = Buffer.byteLength(header.key);
      const valueSize = Buffer.byteLength(header.value);
      size += Encoder.sizeOfVarInt(keySize) + keySize;
      if (header.value === null) {
        size += Encoder.sizeOfVarInt(-1);
      } else {
        size += Encoder.sizeOfVarInt(valueSize) + valueSize;
      }
    }
    return size;
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/crc32C/crc32C.js
var require_crc32C = __commonJS((exports, module) => {
  var crc32C = (buffer) => {
    let crc = 0 ^ -1;
    for (let i = 0;i < buffer.length; i++) {
      crc = T[(crc ^ buffer[i]) & 255] ^ crc >>> 8;
    }
    return (crc ^ -1) >>> 0;
  };
  module.exports = crc32C;
  var T = new Int32Array([
    0,
    4067132163,
    3778769143,
    324072436,
    3348797215,
    904991772,
    648144872,
    3570033899,
    2329499855,
    2024987596,
    1809983544,
    2575936315,
    1296289744,
    3207089363,
    2893594407,
    1578318884,
    274646895,
    3795141740,
    4049975192,
    51262619,
    3619967088,
    632279923,
    922689671,
    3298075524,
    2592579488,
    1760304291,
    2075979607,
    2312596564,
    1562183871,
    2943781820,
    3156637768,
    1313733451,
    549293790,
    3537243613,
    3246849577,
    871202090,
    3878099393,
    357341890,
    102525238,
    4101499445,
    2858735121,
    1477399826,
    1264559846,
    3107202533,
    1845379342,
    2677391885,
    2361733625,
    2125378298,
    820201905,
    3263744690,
    3520608582,
    598981189,
    4151959214,
    85089709,
    373468761,
    3827903834,
    3124367742,
    1213305469,
    1526817161,
    2842354314,
    2107672161,
    2412447074,
    2627466902,
    1861252501,
    1098587580,
    3004210879,
    2688576843,
    1378610760,
    2262928035,
    1955203488,
    1742404180,
    2511436119,
    3416409459,
    969524848,
    714683780,
    3639785095,
    205050476,
    4266873199,
    3976438427,
    526918040,
    1361435347,
    2739821008,
    2954799652,
    1114974503,
    2529119692,
    1691668175,
    2005155131,
    2247081528,
    3690758684,
    697762079,
    986182379,
    3366744552,
    476452099,
    3993867776,
    4250756596,
    255256311,
    1640403810,
    2477592673,
    2164122517,
    1922457750,
    2791048317,
    1412925310,
    1197962378,
    3037525897,
    3944729517,
    427051182,
    170179418,
    4165941337,
    746937522,
    3740196785,
    3451792453,
    1070968646,
    1905808397,
    2213795598,
    2426610938,
    1657317369,
    3053634322,
    1147748369,
    1463399397,
    2773627110,
    4215344322,
    153784257,
    444234805,
    3893493558,
    1021025245,
    3467647198,
    3722505002,
    797665321,
    2197175160,
    1889384571,
    1674398607,
    2443626636,
    1164749927,
    3070701412,
    2757221520,
    1446797203,
    137323447,
    4198817972,
    3910406976,
    461344835,
    3484808360,
    1037989803,
    781091935,
    3705997148,
    2460548119,
    1623424788,
    1939049696,
    2180517859,
    1429367560,
    2807687179,
    3020495871,
    1180866812,
    410100952,
    3927582683,
    4182430767,
    186734380,
    3756733383,
    763408580,
    1053836080,
    3434856499,
    2722870694,
    1344288421,
    1131464017,
    2971354706,
    1708204729,
    2545590714,
    2229949006,
    1988219213,
    680717673,
    3673779818,
    3383336350,
    1002577565,
    4010310262,
    493091189,
    238226049,
    4233660802,
    2987750089,
    1082061258,
    1395524158,
    2705686845,
    1972364758,
    2279892693,
    2494862625,
    1725896226,
    952904198,
    3399985413,
    3656866545,
    731699698,
    4283874585,
    222117402,
    510512622,
    3959836397,
    3280807620,
    837199303,
    582374963,
    3504198960,
    68661723,
    4135334616,
    3844915500,
    390545967,
    1230274059,
    3141532936,
    2825850620,
    1510247935,
    2395924756,
    2091215383,
    1878366691,
    2644384480,
    3553878443,
    565732008,
    854102364,
    3229815391,
    340358836,
    3861050807,
    4117890627,
    119113024,
    1493875044,
    2875275879,
    3090270611,
    1247431312,
    2660249211,
    1828433272,
    2141937292,
    2378227087,
    3811616794,
    291187481,
    34330861,
    4032846830,
    615137029,
    3603020806,
    3314634738,
    939183345,
    1776939221,
    2609017814,
    2295496738,
    2058945313,
    2926798794,
    1545135305,
    1330124605,
    3173225534,
    4084100981,
    17165430,
    307568514,
    3762199681,
    888469610,
    3332340585,
    3587147933,
    665062302,
    2042050490,
    2346497209,
    2559330125,
    1793573966,
    3190661285,
    1279665062,
    1595330642,
    2910671697
  ]);
});

// node_modules/kafkajs/src/protocol/recordBatch/crc32C/index.js
var require_crc32C2 = __commonJS((exports, module) => {
  var crc32C = require_crc32C();
  var unsigned = (value) => Uint32Array.from([value])[0];
  module.exports = (buffer) => unsigned(crc32C(buffer));
});

// node_modules/kafkajs/src/protocol/recordBatch/v0/index.js
var require_v04 = __commonJS((exports, module) => {
  var Long = require_long();
  var Encoder = require_encoder();
  var crc32C = require_crc32C2();
  var {
    Types: Compression,
    lookupCodec,
    COMPRESSION_CODEC_MASK
  } = require_compression();
  var MAGIC_BYTE = 2;
  var TIMESTAMP_MASK = 0;
  var TRANSACTIONAL_MASK = 16;
  var RecordBatch = async ({
    compression = Compression.None,
    firstOffset = Long.fromInt(0),
    firstTimestamp = Date.now(),
    maxTimestamp = Date.now(),
    partitionLeaderEpoch = 0,
    lastOffsetDelta = 0,
    transactional = false,
    producerId = Long.fromValue(-1),
    producerEpoch = 0,
    firstSequence = 0,
    records = []
  }) => {
    const COMPRESSION_CODEC = compression & COMPRESSION_CODEC_MASK;
    const IN_TRANSACTION = transactional ? TRANSACTIONAL_MASK : 0;
    const attributes = COMPRESSION_CODEC | TIMESTAMP_MASK | IN_TRANSACTION;
    const batchBody = new Encoder().writeInt16(attributes).writeInt32(lastOffsetDelta).writeInt64(firstTimestamp).writeInt64(maxTimestamp).writeInt64(producerId).writeInt16(producerEpoch).writeInt32(firstSequence);
    if (compression === Compression.None) {
      if (records.every((v) => typeof v === typeof records[0])) {
        batchBody.writeArray(records, typeof records[0]);
      } else {
        batchBody.writeArray(records);
      }
    } else {
      const compressedRecords = await compressRecords(compression, records);
      batchBody.writeInt32(records.length).writeBuffer(compressedRecords);
    }
    const batch = new Encoder().writeInt32(partitionLeaderEpoch).writeInt8(MAGIC_BYTE).writeUInt32(crc32C(batchBody.buffer)).writeEncoder(batchBody);
    return new Encoder().writeInt64(firstOffset).writeBytes(batch.buffer);
  };
  var compressRecords = async (compression, records) => {
    const codec = lookupCodec(compression);
    const recordsEncoder = new Encoder;
    recordsEncoder.writeEncoderArray(records);
    return codec.compress(recordsEncoder);
  };
  module.exports = {
    RecordBatch,
    MAGIC_BYTE
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v3/request.js
var require_request4 = __commonJS((exports, module) => {
  var Long = require_long();
  var Encoder = require_encoder();
  var { Produce: apiKey } = require_apiKeys();
  var { Types } = require_compression();
  var Record = require_v03();
  var { RecordBatch } = require_v04();
  module.exports = ({
    acks,
    timeout,
    transactionalId = null,
    producerId = Long.fromInt(-1),
    producerEpoch = 0,
    compression = Types.None,
    topicData
  }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "Produce",
    expectResponse: () => acks !== 0,
    encode: async () => {
      const encodeTopic = topicEncoder(compression);
      const encodedTopicData = [];
      for (const data of topicData) {
        encodedTopicData.push(await encodeTopic({ ...data, transactionalId, producerId, producerEpoch }));
      }
      return new Encoder().writeString(transactionalId).writeInt16(acks).writeInt32(timeout).writeArray(encodedTopicData);
    }
  });
  var topicEncoder = (compression) => async ({
    topic,
    partitions,
    transactionalId,
    producerId,
    producerEpoch
  }) => {
    const encodePartitions = partitionsEncoder(compression);
    const encodedPartitions = [];
    for (const data of partitions) {
      encodedPartitions.push(await encodePartitions({ ...data, transactionalId, producerId, producerEpoch }));
    }
    return new Encoder().writeString(topic).writeArray(encodedPartitions);
  };
  var partitionsEncoder = (compression) => async ({
    partition,
    messages,
    transactionalId,
    firstSequence,
    producerId,
    producerEpoch
  }) => {
    const dateNow = Date.now();
    const messageTimestamps = messages.map((m) => m.timestamp).filter((timestamp) => timestamp != null).sort();
    const timestamps = messageTimestamps.length === 0 ? [dateNow] : messageTimestamps;
    const firstTimestamp = timestamps[0];
    const maxTimestamp = timestamps[timestamps.length - 1];
    const records = messages.map((message, i) => Record({
      ...message,
      offsetDelta: i,
      timestampDelta: (message.timestamp || dateNow) - firstTimestamp
    }));
    const recordBatch = await RecordBatch({
      compression,
      records,
      firstTimestamp,
      maxTimestamp,
      producerId,
      producerEpoch,
      firstSequence,
      transactional: !!transactionalId,
      lastOffsetDelta: records.length - 1
    });
    return new Encoder().writeInt32(partition).writeInt32(recordBatch.size()).writeEncoder(recordBatch);
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v3/response.js
var require_response4 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var partition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    baseOffset: decoder.readInt64().toString(),
    logAppendTime: decoder.readInt64().toString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const topics = decoder.readArray((decoder2) => ({
      topicName: decoder2.readString(),
      partitions: decoder2.readArray(partition)
    }));
    const throttleTime = decoder.readInt32();
    return {
      topics,
      throttleTime
    };
  };
  var parse6 = async (data) => {
    const errors3 = data.topics.flatMap((response) => {
      return response.partitions.filter((partition2) => failure(partition2.errorCode));
    });
    if (errors3.length > 0) {
      const { errorCode } = errors3[0];
      throw createErrorFromCode(errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v4/request.js
var require_request5 = __commonJS((exports, module) => {
  var requestV3 = require_request4();
  module.exports = ({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }) => Object.assign(requestV3({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }), { apiVersion: 4 });
});

// node_modules/kafkajs/src/protocol/requests/produce/v4/response.js
var require_response5 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response4();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v5/request.js
var require_request6 = __commonJS((exports, module) => {
  var requestV3 = require_request4();
  module.exports = ({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }) => Object.assign(requestV3({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }), { apiVersion: 5 });
});

// node_modules/kafkajs/src/protocol/requests/produce/v5/response.js
var require_response6 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV3 } = require_response4();
  var partition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    baseOffset: decoder.readInt64().toString(),
    logAppendTime: decoder.readInt64().toString(),
    logStartOffset: decoder.readInt64().toString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const topics = decoder.readArray((decoder2) => ({
      topicName: decoder2.readString(),
      partitions: decoder2.readArray(partition)
    }));
    const throttleTime = decoder.readInt32();
    return {
      topics,
      throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parseV3
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v6/request.js
var require_request7 = __commonJS((exports, module) => {
  var requestV5 = require_request6();
  module.exports = ({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }) => Object.assign(requestV5({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }), { apiVersion: 6 });
});

// node_modules/kafkajs/src/protocol/requests/produce/v6/response.js
var require_response7 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV5 } = require_response6();
  var decode = async (rawData) => {
    const decoded = await decodeV5(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/v7/request.js
var require_request8 = __commonJS((exports, module) => {
  var requestV6 = require_request7();
  module.exports = ({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }) => Object.assign(requestV6({
    acks,
    timeout,
    transactionalId,
    producerId,
    producerEpoch,
    compression,
    topicData
  }), { apiVersion: 7 });
});

// node_modules/kafkajs/src/protocol/requests/produce/v7/response.js
var require_response8 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response7();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/produce/index.js
var require_produce = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ acks, timeout, topicData }) => {
      const request = require_request();
      const response = require_response();
      return { request: request({ acks, timeout, topicData }), response };
    },
    1: ({ acks, timeout, topicData }) => {
      const request = require_request2();
      const response = require_response2();
      return { request: request({ acks, timeout, topicData }), response };
    },
    2: ({ acks, timeout, topicData, compression }) => {
      const request = require_request3();
      const response = require_response3();
      return { request: request({ acks, timeout, compression, topicData }), response };
    },
    3: ({ acks, timeout, compression, topicData, transactionalId, producerId, producerEpoch }) => {
      const request = require_request4();
      const response = require_response4();
      return {
        request: request({
          acks,
          timeout,
          compression,
          topicData,
          transactionalId,
          producerId,
          producerEpoch
        }),
        response
      };
    },
    4: ({ acks, timeout, compression, topicData, transactionalId, producerId, producerEpoch }) => {
      const request = require_request5();
      const response = require_response5();
      return {
        request: request({
          acks,
          timeout,
          compression,
          topicData,
          transactionalId,
          producerId,
          producerEpoch
        }),
        response
      };
    },
    5: ({ acks, timeout, compression, topicData, transactionalId, producerId, producerEpoch }) => {
      const request = require_request6();
      const response = require_response6();
      return {
        request: request({
          acks,
          timeout,
          compression,
          topicData,
          transactionalId,
          producerId,
          producerEpoch
        }),
        response
      };
    },
    6: ({ acks, timeout, compression, topicData, transactionalId, producerId, producerEpoch }) => {
      const request = require_request7();
      const response = require_response7();
      return {
        request: request({
          acks,
          timeout,
          compression,
          topicData,
          transactionalId,
          producerId,
          producerEpoch
        }),
        response
      };
    },
    7: ({ acks, timeout, compression, topicData, transactionalId, producerId, producerEpoch }) => {
      const request = require_request8();
      const response = require_response8();
      return {
        request: request({
          acks,
          timeout,
          compression,
          topicData,
          transactionalId,
          producerId,
          producerEpoch
        }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/isolationLevel.js
var require_isolationLevel = __commonJS((exports, module) => {
  module.exports = {
    READ_UNCOMMITTED: 0,
    READ_COMMITTED: 1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v0/request.js
var require_request9 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  module.exports = ({ replicaId, maxWaitTime, minBytes, topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, fetchOffset, maxBytes }) => {
    return new Encoder().writeInt32(partition).writeInt64(fetchOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/message/v0/decoder.js
var require_decoder2 = __commonJS((exports, module) => {
  module.exports = (decoder) => ({
    attributes: decoder.readInt8(),
    key: decoder.readBytes(),
    value: decoder.readBytes()
  });
});

// node_modules/kafkajs/src/protocol/message/v1/decoder.js
var require_decoder3 = __commonJS((exports, module) => {
  module.exports = (decoder) => ({
    attributes: decoder.readInt8(),
    timestamp: decoder.readInt64().toString(),
    key: decoder.readBytes(),
    value: decoder.readBytes()
  });
});

// node_modules/kafkajs/src/protocol/message/decoder.js
var require_decoder4 = __commonJS((exports, module) => {
  var {
    KafkaJSPartialMessageError,
    KafkaJSUnsupportedMagicByteInMessageSet
  } = require_errors();
  var V0Decoder = require_decoder2();
  var V1Decoder = require_decoder3();
  var decodeMessage = (decoder, magicByte) => {
    switch (magicByte) {
      case 0:
        return V0Decoder(decoder);
      case 1:
        return V1Decoder(decoder);
      default:
        throw new KafkaJSUnsupportedMagicByteInMessageSet(`Unsupported MessageSet message version, magic byte: ${magicByte}`);
    }
  };
  module.exports = (offset, size, decoder) => {
    const remainingBytes = Buffer.byteLength(decoder.slice(size).buffer);
    if (remainingBytes < size) {
      throw new KafkaJSPartialMessageError(`Tried to decode a partial message: remainingBytes(${remainingBytes}) < messageSize(${size})`);
    }
    const crc = decoder.readInt32();
    const magicByte = decoder.readInt8();
    const message = decodeMessage(decoder, magicByte);
    return Object.assign({ offset, size, crc, magicByte }, message);
  };
});

// node_modules/kafkajs/src/protocol/messageSet/decoder.js
var require_decoder5 = __commonJS((exports, module) => {
  var Long = require_long();
  var Decoder = require_decoder();
  var MessageDecoder = require_decoder4();
  var { lookupCodecByAttributes } = require_compression();
  var { KafkaJSPartialMessageError } = require_errors();
  module.exports = async (primaryDecoder, size = null) => {
    const messages = [];
    const messageSetSize = size || primaryDecoder.readInt32();
    const messageSetDecoder = primaryDecoder.slice(messageSetSize);
    while (messageSetDecoder.offset < messageSetSize) {
      try {
        const message = EntryDecoder(messageSetDecoder);
        const codec = lookupCodecByAttributes(message.attributes);
        if (codec) {
          const buffer = await codec.decompress(message.value);
          messages.push(...EntriesDecoder(new Decoder(buffer), message));
        } else {
          messages.push(message);
        }
      } catch (e) {
        if (e.name === "KafkaJSPartialMessageError") {
          break;
        }
        if (e.name === "KafkaJSUnsupportedMagicByteInMessageSet") {
          break;
        }
        throw e;
      }
    }
    primaryDecoder.forward(messageSetSize);
    return messages;
  };
  var EntriesDecoder = (decoder, compressedMessage) => {
    const messages = [];
    while (decoder.offset < decoder.buffer.length) {
      messages.push(EntryDecoder(decoder));
    }
    if (compressedMessage.magicByte > 0 && compressedMessage.offset >= 0) {
      const compressedOffset = Long.fromValue(compressedMessage.offset);
      const lastMessageOffset = Long.fromValue(messages[messages.length - 1].offset);
      const baseOffset = compressedOffset - lastMessageOffset;
      for (const message of messages) {
        message.offset = Long.fromValue(message.offset).add(baseOffset).toString();
      }
    }
    return messages;
  };
  var EntryDecoder = (decoder) => {
    if (!decoder.canReadInt64()) {
      throw new KafkaJSPartialMessageError(`Tried to decode a partial message: There isn't enough bytes to read the offset`);
    }
    const offset = decoder.readInt64().toString();
    if (!decoder.canReadInt32()) {
      throw new KafkaJSPartialMessageError(`Tried to decode a partial message: There isn't enough bytes to read the message size`);
    }
    const size = decoder.readInt32();
    return MessageDecoder(offset, size, decoder);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v0/response.js
var require_response9 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { KafkaJSOffsetOutOfRange } = require_errors();
  var { failure, createErrorFromCode, errorCodes } = require_error();
  var MessageSetDecoder = require_decoder5();
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    messages: await MessageSetDecoder(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      responses
    };
  };
  var { code: OFFSET_OUT_OF_RANGE_ERROR_CODE } = errorCodes.find((e) => e.type === "OFFSET_OUT_OF_RANGE");
  var parse6 = async (data) => {
    const errors3 = data.responses.flatMap(({ topicName, partitions }) => {
      return partitions.filter((partition) => failure(partition.errorCode)).map((partition) => Object.assign({}, partition, { topic: topicName }));
    });
    if (errors3.length > 0) {
      const { errorCode, topic, partition } = errors3[0];
      if (errorCode === OFFSET_OUT_OF_RANGE_ERROR_CODE) {
        throw new KafkaJSOffsetOutOfRange(createErrorFromCode(errorCode), { topic, partition });
      }
      throw createErrorFromCode(errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v1/request.js
var require_request10 = __commonJS((exports, module) => {
  var requestV0 = require_request9();
  module.exports = ({ replicaId, maxWaitTime, minBytes, topics }) => {
    return Object.assign(requestV0({ replicaId, maxWaitTime, minBytes, topics }), { apiVersion: 1 });
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v1/response.js
var require_response10 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response9();
  var MessageSetDecoder = require_decoder5();
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    messages: await MessageSetDecoder(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v2/request.js
var require_request11 = __commonJS((exports, module) => {
  var requestV0 = require_request9();
  module.exports = ({ replicaId, maxWaitTime, minBytes, topics }) => {
    return Object.assign(requestV0({ replicaId, maxWaitTime, minBytes, topics }), { apiVersion: 2 });
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v2/response.js
var require_response11 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response10();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v3/request.js
var require_request12 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  module.exports = ({ replicaId, maxWaitTime, minBytes, maxBytes, topics }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, fetchOffset, maxBytes }) => {
    return new Encoder().writeInt32(partition).writeInt64(fetchOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v3/response.js
var require_response12 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response10();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v4/request.js
var require_request13 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  var ISOLATION_LEVEL = require_isolationLevel();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED
  }) => ({
    apiKey,
    apiVersion: 4,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, fetchOffset, maxBytes }) => {
    return new Encoder().writeInt32(partition).writeInt64(fetchOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/header/v0/decoder.js
var require_decoder6 = __commonJS((exports, module) => {
  module.exports = (decoder) => ({
    key: decoder.readVarIntString(),
    value: decoder.readVarIntBytes()
  });
});

// node_modules/kafkajs/src/protocol/timestampTypes.js
var require_timestampTypes = __commonJS((exports, module) => {
  module.exports = {
    NO_TIMESTAMP: -1,
    CREATE_TIME: 0,
    LOG_APPEND_TIME: 1
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/record/v0/decoder.js
var require_decoder7 = __commonJS((exports, module) => {
  var Long = require_long();
  var HeaderDecoder = require_decoder6();
  var TimestampTypes = require_timestampTypes();
  module.exports = (decoder, batchContext = {}) => {
    const {
      firstOffset,
      firstTimestamp,
      magicByte,
      isControlBatch = false,
      timestampType,
      maxTimestamp
    } = batchContext;
    const attributes = decoder.readInt8();
    const timestampDelta = decoder.readVarLong();
    const timestamp = timestampType === TimestampTypes.LOG_APPEND_TIME && maxTimestamp ? maxTimestamp : Long.fromValue(firstTimestamp).add(timestampDelta).toString();
    const offsetDelta = decoder.readVarInt();
    const offset = Long.fromValue(firstOffset).add(offsetDelta).toString();
    const key = decoder.readVarIntBytes();
    const value = decoder.readVarIntBytes();
    const headers = decoder.readVarIntArray(HeaderDecoder).reduce((obj, { key: key2, value: value2 }) => ({
      ...obj,
      [key2]: obj[key2] === undefined ? value2 : Array.isArray(obj[key2]) ? obj[key2].concat([value2]) : [obj[key2], value2]
    }), {});
    return {
      magicByte,
      attributes,
      timestamp,
      offset,
      key,
      value,
      headers,
      isControlRecord: isControlBatch,
      batchContext
    };
  };
});

// node_modules/kafkajs/src/protocol/recordBatch/v0/decoder.js
var require_decoder8 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { KafkaJSPartialMessageError } = require_errors();
  var { lookupCodecByAttributes } = require_compression();
  var RecordDecoder = require_decoder7();
  var TimestampTypes = require_timestampTypes();
  var TIMESTAMP_TYPE_FLAG_MASK = 8;
  var TRANSACTIONAL_FLAG_MASK = 16;
  var CONTROL_FLAG_MASK = 32;
  module.exports = async (fetchDecoder) => {
    const firstOffset = fetchDecoder.readInt64().toString();
    const length = fetchDecoder.readInt32();
    const decoder = fetchDecoder.slice(length);
    fetchDecoder.forward(length);
    const remainingBytes = Buffer.byteLength(decoder.buffer);
    if (remainingBytes < length) {
      throw new KafkaJSPartialMessageError(`Tried to decode a partial record batch: remainingBytes(${remainingBytes}) < recordBatchLength(${length})`);
    }
    const partitionLeaderEpoch = decoder.readInt32();
    const magicByte = decoder.readInt8();
    const crc = decoder.readInt32();
    const attributes = decoder.readInt16();
    const lastOffsetDelta = decoder.readInt32();
    const firstTimestamp = decoder.readInt64().toString();
    const maxTimestamp = decoder.readInt64().toString();
    const producerId = decoder.readInt64().toString();
    const producerEpoch = decoder.readInt16();
    const firstSequence = decoder.readInt32();
    const inTransaction = (attributes & TRANSACTIONAL_FLAG_MASK) > 0;
    const isControlBatch = (attributes & CONTROL_FLAG_MASK) > 0;
    const timestampType = (attributes & TIMESTAMP_TYPE_FLAG_MASK) > 0 ? TimestampTypes.LOG_APPEND_TIME : TimestampTypes.CREATE_TIME;
    const codec = lookupCodecByAttributes(attributes);
    const recordContext = {
      firstOffset,
      firstTimestamp,
      partitionLeaderEpoch,
      inTransaction,
      isControlBatch,
      lastOffsetDelta,
      producerId,
      producerEpoch,
      firstSequence,
      maxTimestamp,
      timestampType
    };
    const records = await decodeRecords(codec, decoder, { ...recordContext, magicByte });
    return {
      ...recordContext,
      records
    };
  };
  var decodeRecords = async (codec, recordsDecoder, recordContext) => {
    if (!codec) {
      return recordsDecoder.readArray((decoder) => decodeRecord(decoder, recordContext));
    }
    const length = recordsDecoder.readInt32();
    if (length <= 0) {
      return [];
    }
    const compressedRecordsBuffer = recordsDecoder.readAll();
    const decompressedRecordBuffer = await codec.decompress(compressedRecordsBuffer);
    const decompressedRecordDecoder = new Decoder(decompressedRecordBuffer);
    const records = new Array(length);
    for (let i = 0;i < length; i++) {
      records[i] = decodeRecord(decompressedRecordDecoder, recordContext);
    }
    return records;
  };
  var decodeRecord = (decoder, recordContext) => {
    const recordBuffer = decoder.readVarIntBytes();
    return RecordDecoder(new Decoder(recordBuffer), recordContext);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v4/decodeMessages.js
var require_decodeMessages = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var MessageSetDecoder = require_decoder5();
  var RecordBatchDecoder = require_decoder8();
  var { MAGIC_BYTE } = require_v04();
  var MAGIC_OFFSET = 16;
  var RECORD_BATCH_OVERHEAD = 49;
  var decodeMessages = async (decoder) => {
    const messagesSize = decoder.readInt32();
    if (messagesSize <= 0 || !decoder.canReadBytes(messagesSize)) {
      return [];
    }
    const messagesBuffer = decoder.readBytes(messagesSize);
    const messagesDecoder = new Decoder(messagesBuffer);
    const magicByte = messagesBuffer.slice(MAGIC_OFFSET).readInt8(0);
    if (magicByte === MAGIC_BYTE) {
      const records = [];
      while (messagesDecoder.canReadBytes(RECORD_BATCH_OVERHEAD)) {
        try {
          const recordBatch = await RecordBatchDecoder(messagesDecoder);
          records.push(...recordBatch.records);
        } catch (e) {
          if (e.name === "KafkaJSPartialMessageError") {
            break;
          }
          throw e;
        }
      }
      return records;
    }
    return MessageSetDecoder(messagesDecoder, messagesSize);
  };
  module.exports = decodeMessages;
});

// node_modules/kafkajs/src/protocol/requests/fetch/v4/response.js
var require_response13 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response10();
  var decodeMessages = require_decodeMessages();
  var decodeAbortedTransactions = (decoder) => ({
    producerId: decoder.readInt64().toString(),
    firstOffset: decoder.readInt64().toString()
  });
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    lastStableOffset: decoder.readInt64().toString(),
    abortedTransactions: decoder.readArray(decodeAbortedTransactions),
    messages: await decodeMessages(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v5/request.js
var require_request14 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  var ISOLATION_LEVEL = require_isolationLevel();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED
  }) => ({
    apiKey,
    apiVersion: 5,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, fetchOffset, logStartOffset = -1, maxBytes }) => {
    return new Encoder().writeInt32(partition).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v5/response.js
var require_response14 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response10();
  var decodeMessages = require_decodeMessages();
  var decodeAbortedTransactions = (decoder) => ({
    producerId: decoder.readInt64().toString(),
    firstOffset: decoder.readInt64().toString()
  });
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    lastStableOffset: decoder.readInt64().toString(),
    lastStartOffset: decoder.readInt64().toString(),
    abortedTransactions: decoder.readArray(decodeAbortedTransactions),
    messages: await decodeMessages(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v6/request.js
var require_request15 = __commonJS((exports, module) => {
  var ISOLATION_LEVEL = require_isolationLevel();
  var requestV5 = require_request14();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED
  }) => Object.assign(requestV5({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel
  }), { apiVersion: 6 });
});

// node_modules/kafkajs/src/protocol/requests/fetch/v6/response.js
var require_response15 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response14();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v7/request.js
var require_request16 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  var ISOLATION_LEVEL = require_isolationLevel();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
  }) => ({
    apiKey,
    apiVersion: 7,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic)).writeArray(forgottenTopics.map(encodeForgottenTopics));
    }
  });
  var encodeForgottenTopics = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions);
  };
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, fetchOffset, logStartOffset = -1, maxBytes }) => {
    return new Encoder().writeInt32(partition).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v7/response.js
var require_response16 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response10();
  var decodeMessages = require_decodeMessages();
  var decodeAbortedTransactions = (decoder) => ({
    producerId: decoder.readInt64().toString(),
    firstOffset: decoder.readInt64().toString()
  });
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    lastStableOffset: decoder.readInt64().toString(),
    lastStartOffset: decoder.readInt64().toString(),
    abortedTransactions: decoder.readArray(decodeAbortedTransactions),
    messages: await decodeMessages(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime,
      errorCode,
      sessionId,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v8/request.js
var require_request17 = __commonJS((exports, module) => {
  var ISOLATION_LEVEL = require_isolationLevel();
  var requestV7 = require_request16();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
  }) => Object.assign(requestV7({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel,
    sessionId,
    sessionEpoch,
    forgottenTopics
  }), { apiVersion: 8 });
});

// node_modules/kafkajs/src/protocol/requests/fetch/v8/response.js
var require_response17 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response10();
  var decodeMessages = require_decodeMessages();
  var decodeAbortedTransactions = (decoder) => ({
    producerId: decoder.readInt64().toString(),
    firstOffset: decoder.readInt64().toString()
  });
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    lastStableOffset: decoder.readInt64().toString(),
    lastStartOffset: decoder.readInt64().toString(),
    abortedTransactions: decoder.readArray(decodeAbortedTransactions),
    messages: await decodeMessages(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const clientSideThrottleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime: 0,
      clientSideThrottleTime,
      errorCode,
      sessionId,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v9/request.js
var require_request18 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  var ISOLATION_LEVEL = require_isolationLevel();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
  }) => ({
    apiKey,
    apiVersion: 9,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic)).writeArray(forgottenTopics.map(encodeForgottenTopics));
    }
  });
  var encodeForgottenTopics = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions);
  };
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({
    partition,
    currentLeaderEpoch = -1,
    fetchOffset,
    logStartOffset = -1,
    maxBytes
  }) => {
    return new Encoder().writeInt32(partition).writeInt32(currentLeaderEpoch).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v9/response.js
var require_response18 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response17();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v10/request.js
var require_request19 = __commonJS((exports, module) => {
  var ISOLATION_LEVEL = require_isolationLevel();
  var requestV9 = require_request18();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
  }) => Object.assign(requestV9({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    isolationLevel,
    sessionId,
    sessionEpoch,
    forgottenTopics
  }), { apiVersion: 10 });
});

// node_modules/kafkajs/src/protocol/requests/fetch/v10/response.js
var require_response19 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response18();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v11/request.js
var require_request20 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Fetch: apiKey } = require_apiKeys();
  var ISOLATION_LEVEL = require_isolationLevel();
  module.exports = ({
    replicaId,
    maxWaitTime,
    minBytes,
    maxBytes,
    topics,
    rackId = "",
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    sessionId = 0,
    sessionEpoch = -1,
    forgottenTopics = []
  }) => ({
    apiKey,
    apiVersion: 11,
    apiName: "Fetch",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt32(maxWaitTime).writeInt32(minBytes).writeInt32(maxBytes).writeInt8(isolationLevel).writeInt32(sessionId).writeInt32(sessionEpoch).writeArray(topics.map(encodeTopic)).writeArray(forgottenTopics.map(encodeForgottenTopics)).writeString(rackId);
    }
  });
  var encodeForgottenTopics = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions);
  };
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({
    partition,
    currentLeaderEpoch = -1,
    fetchOffset,
    logStartOffset = -1,
    maxBytes
  }) => {
    return new Encoder().writeInt32(partition).writeInt32(currentLeaderEpoch).writeInt64(fetchOffset).writeInt64(logStartOffset).writeInt32(maxBytes);
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/v11/response.js
var require_response20 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response10();
  var decodeMessages = require_decodeMessages();
  var decodeAbortedTransactions = (decoder) => ({
    producerId: decoder.readInt64().toString(),
    firstOffset: decoder.readInt64().toString()
  });
  var decodePartition = async (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    highWatermark: decoder.readInt64().toString(),
    lastStableOffset: decoder.readInt64().toString(),
    lastStartOffset: decoder.readInt64().toString(),
    abortedTransactions: decoder.readArray(decodeAbortedTransactions),
    preferredReadReplica: decoder.readInt32(),
    messages: await decodeMessages(decoder)
  });
  var decodeResponse = async (decoder) => ({
    topicName: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const clientSideThrottleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const sessionId = decoder.readInt32();
    const responses = await decoder.readArrayAsync(decodeResponse);
    return {
      throttleTime: 0,
      clientSideThrottleTime,
      errorCode,
      sessionId,
      responses
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var ISOLATION_LEVEL = require_isolationLevel();
  var REPLICA_ID = -1;
  var NETWORK_DELAY = 100;
  var requestTimeout = (timeout) => Number.isSafeInteger(timeout + NETWORK_DELAY) ? timeout + NETWORK_DELAY : timeout;
  var versions2 = {
    0: ({ replicaId = REPLICA_ID, maxWaitTime, minBytes, topics }) => {
      const request = require_request9();
      const response = require_response9();
      return {
        request: request({ replicaId, maxWaitTime, minBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    1: ({ replicaId = REPLICA_ID, maxWaitTime, minBytes, topics }) => {
      const request = require_request10();
      const response = require_response10();
      return {
        request: request({ replicaId, maxWaitTime, minBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    2: ({ replicaId = REPLICA_ID, maxWaitTime, minBytes, topics }) => {
      const request = require_request11();
      const response = require_response11();
      return {
        request: request({ replicaId, maxWaitTime, minBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    3: ({ replicaId = REPLICA_ID, maxWaitTime, minBytes, maxBytes, topics }) => {
      const request = require_request12();
      const response = require_response12();
      return {
        request: request({ replicaId, maxWaitTime, minBytes, maxBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    4: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request13();
      const response = require_response13();
      return {
        request: request({ replicaId, isolationLevel, maxWaitTime, minBytes, maxBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    5: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request14();
      const response = require_response14();
      return {
        request: request({ replicaId, isolationLevel, maxWaitTime, minBytes, maxBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    6: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request15();
      const response = require_response15();
      return {
        request: request({ replicaId, isolationLevel, maxWaitTime, minBytes, maxBytes, topics }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    7: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      sessionId = 0,
      sessionEpoch = -1,
      forgottenTopics = [],
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request16();
      const response = require_response16();
      return {
        request: request({
          replicaId,
          isolationLevel,
          sessionId,
          sessionEpoch,
          forgottenTopics,
          maxWaitTime,
          minBytes,
          maxBytes,
          topics
        }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    8: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      sessionId = 0,
      sessionEpoch = -1,
      forgottenTopics = [],
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request17();
      const response = require_response17();
      return {
        request: request({
          replicaId,
          isolationLevel,
          sessionId,
          sessionEpoch,
          forgottenTopics,
          maxWaitTime,
          minBytes,
          maxBytes,
          topics
        }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    9: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      sessionId = 0,
      sessionEpoch = -1,
      forgottenTopics = [],
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request18();
      const response = require_response18();
      return {
        request: request({
          replicaId,
          isolationLevel,
          sessionId,
          sessionEpoch,
          forgottenTopics,
          maxWaitTime,
          minBytes,
          maxBytes,
          topics
        }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    10: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      sessionId = 0,
      sessionEpoch = -1,
      forgottenTopics = [],
      maxWaitTime,
      minBytes,
      maxBytes,
      topics
    }) => {
      const request = require_request19();
      const response = require_response19();
      return {
        request: request({
          replicaId,
          isolationLevel,
          sessionId,
          sessionEpoch,
          forgottenTopics,
          maxWaitTime,
          minBytes,
          maxBytes,
          topics
        }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    },
    11: ({
      replicaId = REPLICA_ID,
      isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
      sessionId = 0,
      sessionEpoch = -1,
      forgottenTopics = [],
      maxWaitTime,
      minBytes,
      maxBytes,
      topics,
      rackId
    }) => {
      const request = require_request20();
      const response = require_response20();
      return {
        request: request({
          replicaId,
          isolationLevel,
          sessionId,
          sessionEpoch,
          forgottenTopics,
          maxWaitTime,
          minBytes,
          maxBytes,
          topics,
          rackId
        }),
        response,
        requestTimeout: requestTimeout(maxWaitTime)
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v0/request.js
var require_request21 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ListOffsets: apiKey } = require_apiKeys();
  module.exports = ({ replicaId, topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "ListOffsets",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, timestamp = -1, maxNumOffsets = 1 }) => {
    return new Encoder().writeInt32(partition).writeInt64(timestamp).writeInt32(maxNumOffsets);
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v0/response.js
var require_response21 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    offsets: decoder.readArray(decodeOffsets)
  });
  var decodeOffsets = (decoder) => decoder.readInt64().toString();
  var parse6 = async (data) => {
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v1/request.js
var require_request22 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ListOffsets: apiKey } = require_apiKeys();
  module.exports = ({ replicaId, topics }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "ListOffsets",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, timestamp = -1 }) => {
    return new Encoder().writeInt32(partition).writeInt64(timestamp);
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v1/response.js
var require_response22 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    timestamp: decoder.readInt64().toString(),
    offset: decoder.readInt64().toString()
  });
  var parse6 = async (data) => {
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v2/request.js
var require_request23 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ListOffsets: apiKey } = require_apiKeys();
  module.exports = ({ replicaId, isolationLevel, topics }) => ({
    apiKey,
    apiVersion: 2,
    apiName: "ListOffsets",
    encode: async () => {
      return new Encoder().writeInt32(replicaId).writeInt8(isolationLevel).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, timestamp = -1 }) => {
    return new Encoder().writeInt32(partition).writeInt64(timestamp);
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v2/response.js
var require_response23 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16(),
    timestamp: decoder.readInt64().toString(),
    offset: decoder.readInt64().toString()
  });
  var parse6 = async (data) => {
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v3/request.js
var require_request24 = __commonJS((exports, module) => {
  var requestV2 = require_request23();
  module.exports = ({ replicaId, isolationLevel, topics }) => Object.assign(requestV2({ replicaId, isolationLevel, topics }), { apiVersion: 3 });
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/v3/response.js
var require_response24 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV2 } = require_response23();
  var decode = async (rawData) => {
    const decoded = await decodeV2(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listOffsets/index.js
var require_listOffsets = __commonJS((exports, module) => {
  var ISOLATION_LEVEL = require_isolationLevel();
  var REPLICA_ID = -1;
  var versions2 = {
    0: ({ replicaId = REPLICA_ID, topics }) => {
      const request = require_request21();
      const response = require_response21();
      return { request: request({ replicaId, topics }), response };
    },
    1: ({ replicaId = REPLICA_ID, topics }) => {
      const request = require_request22();
      const response = require_response22();
      return { request: request({ replicaId, topics }), response };
    },
    2: ({ replicaId = REPLICA_ID, isolationLevel = ISOLATION_LEVEL.READ_COMMITTED, topics }) => {
      const request = require_request23();
      const response = require_response23();
      return { request: request({ replicaId, isolationLevel, topics }), response };
    },
    3: ({ replicaId = REPLICA_ID, isolationLevel = ISOLATION_LEVEL.READ_COMMITTED, topics }) => {
      const request = require_request24();
      const response = require_response24();
      return { request: request({ replicaId, isolationLevel, topics }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v0/request.js
var require_request25 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Metadata: apiKey } = require_apiKeys();
  module.exports = ({ topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "Metadata",
    encode: async () => {
      return new Encoder().writeArray(topics);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v0/response.js
var require_response25 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var broker = (decoder) => ({
    nodeId: decoder.readInt32(),
    host: decoder.readString(),
    port: decoder.readInt32()
  });
  var topicMetadata = (decoder) => ({
    topicErrorCode: decoder.readInt16(),
    topic: decoder.readString(),
    partitionMetadata: decoder.readArray(partitionMetadata)
  });
  var partitionMetadata = (decoder) => ({
    partitionErrorCode: decoder.readInt16(),
    partitionId: decoder.readInt32(),
    leader: decoder.readInt32(),
    replicas: decoder.readArray((d) => d.readInt32()),
    isr: decoder.readArray((d) => d.readInt32())
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      brokers: decoder.readArray(broker),
      topicMetadata: decoder.readArray(topicMetadata)
    };
  };
  var parse6 = async (data) => {
    const topicsWithErrors = data.topicMetadata.filter((topic) => failure(topic.topicErrorCode));
    if (topicsWithErrors.length > 0) {
      const { topicErrorCode } = topicsWithErrors[0];
      throw createErrorFromCode(topicErrorCode);
    }
    const errors3 = data.topicMetadata.flatMap((topic) => {
      return topic.partitionMetadata.filter((partition) => failure(partition.partitionErrorCode));
    });
    if (errors3.length > 0) {
      const { partitionErrorCode } = errors3[0];
      throw createErrorFromCode(partitionErrorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v1/request.js
var require_request26 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Metadata: apiKey } = require_apiKeys();
  module.exports = ({ topics }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "Metadata",
    encode: async () => {
      return new Encoder().writeNullableArray(topics);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v1/response.js
var require_response26 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response25();
  var broker = (decoder) => ({
    nodeId: decoder.readInt32(),
    host: decoder.readString(),
    port: decoder.readInt32(),
    rack: decoder.readString()
  });
  var topicMetadata = (decoder) => ({
    topicErrorCode: decoder.readInt16(),
    topic: decoder.readString(),
    isInternal: decoder.readBoolean(),
    partitionMetadata: decoder.readArray(partitionMetadata)
  });
  var partitionMetadata = (decoder) => ({
    partitionErrorCode: decoder.readInt16(),
    partitionId: decoder.readInt32(),
    leader: decoder.readInt32(),
    replicas: decoder.readArray((d) => d.readInt32()),
    isr: decoder.readArray((d) => d.readInt32())
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      brokers: decoder.readArray(broker),
      controllerId: decoder.readInt32(),
      topicMetadata: decoder.readArray(topicMetadata)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v2/request.js
var require_request27 = __commonJS((exports, module) => {
  var requestV1 = require_request26();
  module.exports = ({ topics }) => Object.assign(requestV1({ topics }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v2/response.js
var require_response27 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response25();
  var broker = (decoder) => ({
    nodeId: decoder.readInt32(),
    host: decoder.readString(),
    port: decoder.readInt32(),
    rack: decoder.readString()
  });
  var topicMetadata = (decoder) => ({
    topicErrorCode: decoder.readInt16(),
    topic: decoder.readString(),
    isInternal: decoder.readBoolean(),
    partitionMetadata: decoder.readArray(partitionMetadata)
  });
  var partitionMetadata = (decoder) => ({
    partitionErrorCode: decoder.readInt16(),
    partitionId: decoder.readInt32(),
    leader: decoder.readInt32(),
    replicas: decoder.readArray((d) => d.readInt32()),
    isr: decoder.readArray((d) => d.readInt32())
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      brokers: decoder.readArray(broker),
      clusterId: decoder.readString(),
      controllerId: decoder.readInt32(),
      topicMetadata: decoder.readArray(topicMetadata)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v3/request.js
var require_request28 = __commonJS((exports, module) => {
  var requestV1 = require_request26();
  module.exports = ({ topics }) => Object.assign(requestV1({ topics }), { apiVersion: 3 });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v3/response.js
var require_response28 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response25();
  var broker = (decoder) => ({
    nodeId: decoder.readInt32(),
    host: decoder.readString(),
    port: decoder.readInt32(),
    rack: decoder.readString()
  });
  var topicMetadata = (decoder) => ({
    topicErrorCode: decoder.readInt16(),
    topic: decoder.readString(),
    isInternal: decoder.readBoolean(),
    partitionMetadata: decoder.readArray(partitionMetadata)
  });
  var partitionMetadata = (decoder) => ({
    partitionErrorCode: decoder.readInt16(),
    partitionId: decoder.readInt32(),
    leader: decoder.readInt32(),
    replicas: decoder.readArray((d) => d.readInt32()),
    isr: decoder.readArray((d) => d.readInt32())
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      brokers: decoder.readArray(broker),
      clusterId: decoder.readString(),
      controllerId: decoder.readInt32(),
      topicMetadata: decoder.readArray(topicMetadata)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v4/request.js
var require_request29 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Metadata: apiKey } = require_apiKeys();
  module.exports = ({ topics, allowAutoTopicCreation = true }) => ({
    apiKey,
    apiVersion: 4,
    apiName: "Metadata",
    encode: async () => {
      return new Encoder().writeNullableArray(topics).writeBoolean(allowAutoTopicCreation);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v4/response.js
var require_response29 = __commonJS((exports, module) => {
  var { parse: parseV3, decode: decodeV3 } = require_response28();
  module.exports = {
    parse: parseV3,
    decode: decodeV3
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v5/request.js
var require_request30 = __commonJS((exports, module) => {
  var requestV4 = require_request29();
  module.exports = ({ topics, allowAutoTopicCreation = true }) => Object.assign(requestV4({ topics, allowAutoTopicCreation }), { apiVersion: 5 });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v5/response.js
var require_response30 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response25();
  var broker = (decoder) => ({
    nodeId: decoder.readInt32(),
    host: decoder.readString(),
    port: decoder.readInt32(),
    rack: decoder.readString()
  });
  var topicMetadata = (decoder) => ({
    topicErrorCode: decoder.readInt16(),
    topic: decoder.readString(),
    isInternal: decoder.readBoolean(),
    partitionMetadata: decoder.readArray(partitionMetadata)
  });
  var partitionMetadata = (decoder) => ({
    partitionErrorCode: decoder.readInt16(),
    partitionId: decoder.readInt32(),
    leader: decoder.readInt32(),
    replicas: decoder.readArray((d) => d.readInt32()),
    isr: decoder.readArray((d) => d.readInt32()),
    offlineReplicas: decoder.readArray((d) => d.readInt32())
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      brokers: decoder.readArray(broker),
      clusterId: decoder.readString(),
      controllerId: decoder.readInt32(),
      topicMetadata: decoder.readArray(topicMetadata)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/v6/request.js
var require_request31 = __commonJS((exports, module) => {
  var requestV5 = require_request30();
  module.exports = ({ topics, allowAutoTopicCreation = true }) => Object.assign(requestV5({ topics, allowAutoTopicCreation }), { apiVersion: 6 });
});

// node_modules/kafkajs/src/protocol/requests/metadata/v6/response.js
var require_response31 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response30();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/metadata/index.js
var require_metadata = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics }) => {
      const request = require_request25();
      const response = require_response25();
      return { request: request({ topics }), response };
    },
    1: ({ topics }) => {
      const request = require_request26();
      const response = require_response26();
      return { request: request({ topics }), response };
    },
    2: ({ topics }) => {
      const request = require_request27();
      const response = require_response27();
      return { request: request({ topics }), response };
    },
    3: ({ topics }) => {
      const request = require_request28();
      const response = require_response28();
      return { request: request({ topics }), response };
    },
    4: ({ topics, allowAutoTopicCreation }) => {
      const request = require_request29();
      const response = require_response29();
      return { request: request({ topics, allowAutoTopicCreation }), response };
    },
    5: ({ topics, allowAutoTopicCreation }) => {
      const request = require_request30();
      const response = require_response30();
      return { request: request({ topics, allowAutoTopicCreation }), response };
    },
    6: ({ topics, allowAutoTopicCreation }) => {
      const request = require_request31();
      const response = require_response31();
      return { request: request({ topics, allowAutoTopicCreation }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v0/request.js
var require_request32 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetCommit: apiKey } = require_apiKeys();
  module.exports = ({ groupId, topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "OffsetCommit",
    encode: async () => {
      return new Encoder().writeString(groupId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, offset, metadata = null }) => {
    return new Encoder().writeInt32(partition).writeInt64(offset).writeString(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v0/response.js
var require_response32 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v1/request.js
var require_request33 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetCommit: apiKey } = require_apiKeys();
  module.exports = ({ groupId, groupGenerationId, memberId, topics }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "OffsetCommit",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, offset, timestamp = Date.now(), metadata = null }) => {
    return new Encoder().writeInt32(partition).writeInt64(offset).writeInt64(timestamp).writeString(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v1/response.js
var require_response33 = __commonJS((exports, module) => {
  var { parse: parse6, decode } = require_response32();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v2/request.js
var require_request34 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetCommit: apiKey } = require_apiKeys();
  module.exports = ({ groupId, groupGenerationId, memberId, retentionTime, topics }) => ({
    apiKey,
    apiVersion: 2,
    apiName: "OffsetCommit",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId).writeInt64(retentionTime).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, offset, metadata = null }) => {
    return new Encoder().writeInt32(partition).writeInt64(offset).writeString(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v2/response.js
var require_response34 = __commonJS((exports, module) => {
  var { parse: parse6, decode } = require_response32();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v3/request.js
var require_request35 = __commonJS((exports, module) => {
  var requestV2 = require_request34();
  module.exports = ({ groupId, groupGenerationId, memberId, retentionTime, topics }) => Object.assign(requestV2({ groupId, groupGenerationId, memberId, retentionTime, topics }), {
    apiVersion: 3
  });
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v3/response.js
var require_response35 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response32();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16()
  });
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v4/request.js
var require_request36 = __commonJS((exports, module) => {
  var requestV3 = require_request35();
  module.exports = ({ groupId, groupGenerationId, memberId, retentionTime, topics }) => Object.assign(requestV3({ groupId, groupGenerationId, memberId, retentionTime, topics }), {
    apiVersion: 4
  });
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v4/response.js
var require_response36 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV3 } = require_response35();
  var decode = async (rawData) => {
    const decoded = await decodeV3(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v5/request.js
var require_request37 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetCommit: apiKey } = require_apiKeys();
  module.exports = ({ groupId, groupGenerationId, memberId, topics }) => ({
    apiKey,
    apiVersion: 5,
    apiName: "OffsetCommit",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, offset, metadata = null }) => {
    return new Encoder().writeInt32(partition).writeInt64(offset).writeString(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/v5/response.js
var require_response37 = __commonJS((exports, module) => {
  var { parse: parse6, decode } = require_response36();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetCommit/index.js
var require_offsetCommit = __commonJS((exports, module) => {
  var RETENTION_TIME = -1;
  var versions2 = {
    0: ({ groupId, topics }) => {
      const request = require_request32();
      const response = require_response32();
      return { request: request({ groupId, topics }), response };
    },
    1: ({ groupId, groupGenerationId, memberId, topics }) => {
      const request = require_request33();
      const response = require_response33();
      return { request: request({ groupId, groupGenerationId, memberId, topics }), response };
    },
    2: ({ groupId, groupGenerationId, memberId, retentionTime = RETENTION_TIME, topics }) => {
      const request = require_request34();
      const response = require_response34();
      return {
        request: request({
          groupId,
          groupGenerationId,
          memberId,
          retentionTime,
          topics
        }),
        response
      };
    },
    3: ({ groupId, groupGenerationId, memberId, retentionTime = RETENTION_TIME, topics }) => {
      const request = require_request35();
      const response = require_response35();
      return {
        request: request({
          groupId,
          groupGenerationId,
          memberId,
          retentionTime,
          topics
        }),
        response
      };
    },
    4: ({ groupId, groupGenerationId, memberId, retentionTime = RETENTION_TIME, topics }) => {
      const request = require_request36();
      const response = require_response36();
      return {
        request: request({
          groupId,
          groupGenerationId,
          memberId,
          retentionTime,
          topics
        }),
        response
      };
    },
    5: ({ groupId, groupGenerationId, memberId, topics }) => {
      const request = require_request37();
      const response = require_response37();
      return {
        request: request({
          groupId,
          groupGenerationId,
          memberId,
          topics
        }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v1/request.js
var require_request38 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetFetch: apiKey } = require_apiKeys();
  module.exports = ({ groupId, topics }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "OffsetFetch",
    encode: async () => {
      return new Encoder().writeString(groupId).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition }) => {
    return new Encoder().writeInt32(partition);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v1/response.js
var require_response38 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      responses: decoder.readArray(decodeResponses)
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    offset: decoder.readInt64().toString(),
    metadata: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v2/request.js
var require_request39 = __commonJS((exports, module) => {
  var requestV1 = require_request38();
  module.exports = ({ groupId, topics }) => Object.assign(requestV1({ groupId, topics }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v2/response.js
var require_response39 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      responses: decoder.readArray(decodeResponses),
      errorCode: decoder.readInt16()
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    offset: decoder.readInt64().toString(),
    metadata: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    const partitionsWithError = data.responses.flatMap((response) => response.partitions.filter((partition) => failure(partition.errorCode)));
    const partitionWithError = partitionsWithError[0];
    if (partitionWithError) {
      throw createErrorFromCode(partitionWithError.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v3/request.js
var require_request40 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { OffsetFetch: apiKey } = require_apiKeys();
  module.exports = ({ groupId, topics }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "OffsetFetch",
    encode: async () => {
      return new Encoder().writeString(groupId).writeNullableArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition }) => {
    return new Encoder().writeInt32(partition);
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v3/response.js
var require_response40 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV2 } = require_response39();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      responses: decoder.readArray(decodeResponses),
      errorCode: decoder.readInt16()
    };
  };
  var decodeResponses = (decoder) => ({
    topic: decoder.readString(),
    partitions: decoder.readArray(decodePartitions)
  });
  var decodePartitions = (decoder) => ({
    partition: decoder.readInt32(),
    offset: decoder.readInt64().toString(),
    metadata: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  module.exports = {
    decode,
    parse: parseV2
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v4/request.js
var require_request41 = __commonJS((exports, module) => {
  var requestV3 = require_request40();
  module.exports = ({ groupId, topics }) => Object.assign(requestV3({ groupId, topics }), { apiVersion: 4 });
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/v4/response.js
var require_response41 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV3 } = require_response40();
  var decode = async (rawData) => {
    const decoded = await decodeV3(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/offsetFetch/index.js
var require_offsetFetch = __commonJS((exports, module) => {
  var versions2 = {
    1: ({ groupId, topics }) => {
      const request = require_request38();
      const response = require_response38();
      return { request: request({ groupId, topics }), response };
    },
    2: ({ groupId, topics }) => {
      const request = require_request39();
      const response = require_response39();
      return { request: request({ groupId, topics }), response };
    },
    3: ({ groupId, topics }) => {
      const request = require_request40();
      const response = require_response40();
      return { request: request({ groupId, topics }), response };
    },
    4: ({ groupId, topics }) => {
      const request = require_request41();
      const response = require_response41();
      return { request: request({ groupId, topics }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/coordinatorTypes.js
var require_coordinatorTypes = __commonJS((exports, module) => {
  module.exports = {
    GROUP: 0,
    TRANSACTION: 1
  };
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v0/request.js
var require_request42 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { GroupCoordinator: apiKey } = require_apiKeys();
  module.exports = ({ groupId }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "GroupCoordinator",
    encode: async () => {
      return new Encoder().writeString(groupId);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v0/response.js
var require_response42 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    const coordinator = {
      nodeId: decoder.readInt32(),
      host: decoder.readString(),
      port: decoder.readInt32()
    };
    return {
      errorCode,
      coordinator
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v1/request.js
var require_request43 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { GroupCoordinator: apiKey } = require_apiKeys();
  module.exports = ({ coordinatorKey, coordinatorType }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "GroupCoordinator",
    encode: async () => {
      return new Encoder().writeString(coordinatorKey).writeInt8(coordinatorType);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v1/response.js
var require_response43 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    const errorMessage = decoder.readString();
    const coordinator = {
      nodeId: decoder.readInt32(),
      host: decoder.readString(),
      port: decoder.readInt32()
    };
    return {
      throttleTime,
      errorCode,
      errorMessage,
      coordinator
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v2/request.js
var require_request44 = __commonJS((exports, module) => {
  var requestV1 = require_request43();
  module.exports = ({ coordinatorKey, coordinatorType }) => Object.assign(requestV1({ coordinatorKey, coordinatorType }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/v2/response.js
var require_response44 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response43();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/findCoordinator/index.js
var require_findCoordinator = __commonJS((exports, module) => {
  var COORDINATOR_TYPES = require_coordinatorTypes();
  var versions2 = {
    0: ({ groupId }) => {
      const request = require_request42();
      const response = require_response42();
      return { request: request({ groupId }), response };
    },
    1: ({ groupId, coordinatorType = COORDINATOR_TYPES.GROUP }) => {
      const request = require_request43();
      const response = require_response43();
      return { request: request({ coordinatorKey: groupId, coordinatorType }), response };
    },
    2: ({ groupId, coordinatorType = COORDINATOR_TYPES.GROUP }) => {
      const request = require_request44();
      const response = require_response44();
      return { request: request({ coordinatorKey: groupId, coordinatorType }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v0/request.js
var require_request45 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { JoinGroup: apiKey } = require_apiKeys();
  module.exports = ({ groupId, sessionTimeout, memberId, protocolType, groupProtocols }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "JoinGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(sessionTimeout).writeString(memberId).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols));
    }
  });
  var encodeGroupProtocols = ({ name, metadata = Buffer.alloc(0) }) => {
    return new Encoder().writeString(name).writeBytes(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v0/response.js
var require_response45 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      errorCode,
      generationId: decoder.readInt32(),
      groupProtocol: decoder.readString(),
      leaderId: decoder.readString(),
      memberId: decoder.readString(),
      members: decoder.readArray((decoder2) => ({
        memberId: decoder2.readString(),
        memberMetadata: decoder2.readBytes()
      }))
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v1/request.js
var require_request46 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { JoinGroup: apiKey } = require_apiKeys();
  module.exports = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "JoinGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(sessionTimeout).writeInt32(rebalanceTimeout).writeString(memberId).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols));
    }
  });
  var encodeGroupProtocols = ({ name, metadata = Buffer.alloc(0) }) => {
    return new Encoder().writeString(name).writeBytes(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v1/response.js
var require_response46 = __commonJS((exports, module) => {
  var { parse: parse6, decode } = require_response45();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v2/request.js
var require_request47 = __commonJS((exports, module) => {
  var requestV1 = require_request46();
  module.exports = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }) => Object.assign(requestV1({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v2/response.js
var require_response47 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported } = require_error();
  var { parse: parseV0 } = require_response45();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime,
      errorCode,
      generationId: decoder.readInt32(),
      groupProtocol: decoder.readString(),
      leaderId: decoder.readString(),
      memberId: decoder.readString(),
      members: decoder.readArray((decoder2) => ({
        memberId: decoder2.readString(),
        memberMetadata: decoder2.readBytes()
      }))
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v3/request.js
var require_request48 = __commonJS((exports, module) => {
  var requestV2 = require_request47();
  module.exports = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }) => Object.assign(requestV2({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }), { apiVersion: 3 });
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v3/response.js
var require_response48 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV2 } = require_response47();
  var decode = async (rawData) => {
    const decoded = await decodeV2(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v4/request.js
var require_request49 = __commonJS((exports, module) => {
  var requestV3 = require_request48();
  module.exports = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }) => Object.assign(requestV3({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    protocolType,
    groupProtocols
  }), { apiVersion: 4 });
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v4/response.js
var require_response49 = __commonJS((exports, module) => {
  var { decode } = require_response48();
  var { KafkaJSMemberIdRequired } = require_errors();
  var { failure, createErrorFromCode, errorCodes } = require_error();
  var { code: MEMBER_ID_REQUIRED_ERROR_CODE } = errorCodes.find((e) => e.type === "MEMBER_ID_REQUIRED");
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      if (data.errorCode === MEMBER_ID_REQUIRED_ERROR_CODE) {
        throw new KafkaJSMemberIdRequired(createErrorFromCode(data.errorCode), {
          memberId: data.memberId
        });
      }
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v5/request.js
var require_request50 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { JoinGroup: apiKey } = require_apiKeys();
  module.exports = ({
    groupId,
    sessionTimeout,
    rebalanceTimeout,
    memberId,
    groupInstanceId = null,
    protocolType,
    groupProtocols
  }) => ({
    apiKey,
    apiVersion: 5,
    apiName: "JoinGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(sessionTimeout).writeInt32(rebalanceTimeout).writeString(memberId).writeString(groupInstanceId).writeString(protocolType).writeArray(groupProtocols.map(encodeGroupProtocols));
    }
  });
  var encodeGroupProtocols = ({ name, metadata = Buffer.alloc(0) }) => {
    return new Encoder().writeString(name).writeBytes(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/v5/response.js
var require_response50 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { KafkaJSMemberIdRequired } = require_errors();
  var {
    failure,
    createErrorFromCode,
    errorCodes,
    failIfVersionNotSupported
  } = require_error();
  var { code: MEMBER_ID_REQUIRED_ERROR_CODE } = errorCodes.find((e) => e.type === "MEMBER_ID_REQUIRED");
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      if (data.errorCode === MEMBER_ID_REQUIRED_ERROR_CODE) {
        throw new KafkaJSMemberIdRequired(createErrorFromCode(data.errorCode), {
          memberId: data.memberId
        });
      }
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime: 0,
      clientSideThrottleTime: throttleTime,
      errorCode,
      generationId: decoder.readInt32(),
      groupProtocol: decoder.readString(),
      leaderId: decoder.readString(),
      memberId: decoder.readString(),
      members: decoder.readArray((decoder2) => ({
        memberId: decoder2.readString(),
        groupInstanceId: decoder2.readString(),
        memberMetadata: decoder2.readBytes()
      }))
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/joinGroup/index.js
var require_joinGroup = __commonJS((exports, module) => {
  var NETWORK_DELAY = 5000;
  var requestTimeout = ({ rebalanceTimeout, sessionTimeout }) => {
    const timeout = rebalanceTimeout || sessionTimeout;
    return Number.isSafeInteger(timeout + NETWORK_DELAY) ? timeout + NETWORK_DELAY : timeout;
  };
  var logResponseError = (memberId) => memberId != null && memberId !== "";
  var versions2 = {
    0: ({ groupId, sessionTimeout, memberId, protocolType, groupProtocols }) => {
      const request = require_request45();
      const response = require_response45();
      return {
        request: request({
          groupId,
          sessionTimeout,
          memberId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout: null, sessionTimeout })
      };
    },
    1: ({ groupId, sessionTimeout, rebalanceTimeout, memberId, protocolType, groupProtocols }) => {
      const request = require_request46();
      const response = require_response46();
      return {
        request: request({
          groupId,
          sessionTimeout,
          rebalanceTimeout,
          memberId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout, sessionTimeout })
      };
    },
    2: ({ groupId, sessionTimeout, rebalanceTimeout, memberId, protocolType, groupProtocols }) => {
      const request = require_request47();
      const response = require_response47();
      return {
        request: request({
          groupId,
          sessionTimeout,
          rebalanceTimeout,
          memberId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout, sessionTimeout })
      };
    },
    3: ({ groupId, sessionTimeout, rebalanceTimeout, memberId, protocolType, groupProtocols }) => {
      const request = require_request48();
      const response = require_response48();
      return {
        request: request({
          groupId,
          sessionTimeout,
          rebalanceTimeout,
          memberId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout, sessionTimeout })
      };
    },
    4: ({ groupId, sessionTimeout, rebalanceTimeout, memberId, protocolType, groupProtocols }) => {
      const request = require_request49();
      const response = require_response49();
      return {
        request: request({
          groupId,
          sessionTimeout,
          rebalanceTimeout,
          memberId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout, sessionTimeout }),
        logResponseError: logResponseError(memberId)
      };
    },
    5: ({
      groupId,
      sessionTimeout,
      rebalanceTimeout,
      memberId,
      groupInstanceId,
      protocolType,
      groupProtocols
    }) => {
      const request = require_request50();
      const response = require_response50();
      return {
        request: request({
          groupId,
          sessionTimeout,
          rebalanceTimeout,
          memberId,
          groupInstanceId,
          protocolType,
          groupProtocols
        }),
        response,
        requestTimeout: requestTimeout({ rebalanceTimeout, sessionTimeout }),
        logResponseError: logResponseError(memberId)
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v0/request.js
var require_request51 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Heartbeat: apiKey } = require_apiKeys();
  module.exports = ({ groupId, groupGenerationId, memberId }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "Heartbeat",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v0/response.js
var require_response51 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return { errorCode };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v1/request.js
var require_request52 = __commonJS((exports, module) => {
  var requestV0 = require_request51();
  module.exports = ({ groupId, groupGenerationId, memberId }) => Object.assign(requestV0({ groupId, groupGenerationId, memberId }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v1/response.js
var require_response52 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported } = require_error();
  var { parse: parseV0 } = require_response51();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return { throttleTime, errorCode };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v2/request.js
var require_request53 = __commonJS((exports, module) => {
  var requestV1 = require_request52();
  module.exports = ({ groupId, groupGenerationId, memberId }) => Object.assign(requestV1({ groupId, groupGenerationId, memberId }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v2/response.js
var require_response53 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response52();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v3/request.js
var require_request54 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { Heartbeat: apiKey } = require_apiKeys();
  module.exports = ({ groupId, groupGenerationId, memberId, groupInstanceId }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "Heartbeat",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(groupGenerationId).writeString(memberId).writeString(groupInstanceId);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/v3/response.js
var require_response54 = __commonJS((exports, module) => {
  var { parse: parse6, decode } = require_response53();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/heartbeat/index.js
var require_heartbeat = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ groupId, groupGenerationId, memberId }) => {
      const request = require_request51();
      const response = require_response51();
      return {
        request: request({ groupId, groupGenerationId, memberId }),
        response
      };
    },
    1: ({ groupId, groupGenerationId, memberId }) => {
      const request = require_request52();
      const response = require_response52();
      return {
        request: request({ groupId, groupGenerationId, memberId }),
        response
      };
    },
    2: ({ groupId, groupGenerationId, memberId }) => {
      const request = require_request53();
      const response = require_response53();
      return {
        request: request({ groupId, groupGenerationId, memberId }),
        response
      };
    },
    3: ({ groupId, groupGenerationId, memberId, groupInstanceId }) => {
      const request = require_request54();
      const response = require_response54();
      return {
        request: request({ groupId, groupGenerationId, memberId, groupInstanceId }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v0/request.js
var require_request55 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { LeaveGroup: apiKey } = require_apiKeys();
  module.exports = ({ groupId, memberId }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "LeaveGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeString(memberId);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v0/response.js
var require_response55 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return { errorCode };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v1/request.js
var require_request56 = __commonJS((exports, module) => {
  var requestV0 = require_request55();
  module.exports = ({ groupId, memberId }) => Object.assign(requestV0({ groupId, memberId }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v1/response.js
var require_response56 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported } = require_error();
  var { parse: parseV0 } = require_response55();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return { throttleTime, errorCode };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v2/request.js
var require_request57 = __commonJS((exports, module) => {
  var requestV1 = require_request56();
  module.exports = ({ groupId, memberId }) => Object.assign(requestV1({ groupId, memberId }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v2/response.js
var require_response57 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response56();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v3/request.js
var require_request58 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { LeaveGroup: apiKey } = require_apiKeys();
  module.exports = ({ groupId, members }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "LeaveGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeArray(members.map((member) => encodeMember(member)));
    }
  });
  var encodeMember = ({ memberId, groupInstanceId = null }) => {
    return new Encoder().writeString(memberId).writeString(groupInstanceId);
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/v3/response.js
var require_response58 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported, failure, createErrorFromCode } = require_error();
  var { parse: parseV2 } = require_response57();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const members = decoder.readArray(decodeMembers);
    failIfVersionNotSupported(errorCode);
    return { throttleTime: 0, clientSideThrottleTime: throttleTime, errorCode, members };
  };
  var decodeMembers = (decoder) => ({
    memberId: decoder.readString(),
    groupInstanceId: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    const parsed = parseV2(data);
    const memberWithError = data.members.find((member) => failure(member.errorCode));
    if (memberWithError) {
      throw createErrorFromCode(memberWithError.errorCode);
    }
    return parsed;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/leaveGroup/index.js
var require_leaveGroup = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ groupId, memberId }) => {
      const request = require_request55();
      const response = require_response55();
      return {
        request: request({ groupId, memberId }),
        response
      };
    },
    1: ({ groupId, memberId }) => {
      const request = require_request56();
      const response = require_response56();
      return {
        request: request({ groupId, memberId }),
        response
      };
    },
    2: ({ groupId, memberId }) => {
      const request = require_request57();
      const response = require_response57();
      return {
        request: request({ groupId, memberId }),
        response
      };
    },
    3: ({ groupId, memberId, groupInstanceId }) => {
      const request = require_request58();
      const response = require_response58();
      return {
        request: request({ groupId, members: [{ memberId, groupInstanceId }] }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v0/request.js
var require_request59 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { SyncGroup: apiKey } = require_apiKeys();
  module.exports = ({ groupId, generationId, memberId, groupAssignment }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "SyncGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(generationId).writeString(memberId).writeArray(groupAssignment.map(encodeGroupAssignment));
    }
  });
  var encodeGroupAssignment = ({ memberId, memberAssignment }) => {
    return new Encoder().writeString(memberId).writeBytes(memberAssignment);
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v0/response.js
var require_response59 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      errorCode,
      memberAssignment: decoder.readBytes()
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v1/request.js
var require_request60 = __commonJS((exports, module) => {
  var requestV0 = require_request59();
  module.exports = ({ groupId, generationId, memberId, groupAssignment }) => Object.assign(requestV0({ groupId, generationId, memberId, groupAssignment }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v1/response.js
var require_response60 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported } = require_error();
  var { parse: parseV0 } = require_response59();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime,
      errorCode,
      memberAssignment: decoder.readBytes()
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v2/request.js
var require_request61 = __commonJS((exports, module) => {
  var requestV1 = require_request60();
  module.exports = ({ groupId, generationId, memberId, groupAssignment }) => Object.assign(requestV1({ groupId, generationId, memberId, groupAssignment }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v2/response.js
var require_response61 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response60();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v3/request.js
var require_request62 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { SyncGroup: apiKey } = require_apiKeys();
  module.exports = ({
    groupId,
    generationId,
    memberId,
    groupInstanceId = null,
    groupAssignment
  }) => ({
    apiKey,
    apiVersion: 3,
    apiName: "SyncGroup",
    encode: async () => {
      return new Encoder().writeString(groupId).writeInt32(generationId).writeString(memberId).writeString(groupInstanceId).writeArray(groupAssignment.map(encodeGroupAssignment));
    }
  });
  var encodeGroupAssignment = ({ memberId, memberAssignment }) => {
    return new Encoder().writeString(memberId).writeBytes(memberAssignment);
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/v3/response.js
var require_response62 = __commonJS((exports, module) => {
  var { decode, parse: parse6 } = require_response61();
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/syncGroup/index.js
var require_syncGroup = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ groupId, generationId, memberId, groupAssignment }) => {
      const request = require_request59();
      const response = require_response59();
      return {
        request: request({ groupId, generationId, memberId, groupAssignment }),
        response
      };
    },
    1: ({ groupId, generationId, memberId, groupAssignment }) => {
      const request = require_request60();
      const response = require_response60();
      return {
        request: request({ groupId, generationId, memberId, groupAssignment }),
        response
      };
    },
    2: ({ groupId, generationId, memberId, groupAssignment }) => {
      const request = require_request61();
      const response = require_response61();
      return {
        request: request({ groupId, generationId, memberId, groupAssignment }),
        response
      };
    },
    3: ({ groupId, generationId, memberId, groupInstanceId, groupAssignment }) => {
      const request = require_request62();
      const response = require_response62();
      return {
        request: request({ groupId, generationId, memberId, groupInstanceId, groupAssignment }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v0/request.js
var require_request63 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DescribeGroups: apiKey } = require_apiKeys();
  module.exports = ({ groupIds }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DescribeGroups",
    encode: async () => {
      return new Encoder().writeArray(groupIds);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v0/response.js
var require_response63 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decoderMember = (decoder) => ({
    memberId: decoder.readString(),
    clientId: decoder.readString(),
    clientHost: decoder.readString(),
    memberMetadata: decoder.readBytes(),
    memberAssignment: decoder.readBytes()
  });
  var decodeGroup = (decoder) => ({
    errorCode: decoder.readInt16(),
    groupId: decoder.readString(),
    state: decoder.readString(),
    protocolType: decoder.readString(),
    protocol: decoder.readString(),
    members: decoder.readArray(decoderMember)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const groups = decoder.readArray(decodeGroup);
    return {
      groups
    };
  };
  var parse6 = async (data) => {
    const groupsWithError = data.groups.filter(({ errorCode }) => failure(errorCode));
    if (groupsWithError.length > 0) {
      throw createErrorFromCode(groupsWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v1/request.js
var require_request64 = __commonJS((exports, module) => {
  var requestV0 = require_request63();
  module.exports = ({ groupIds }) => Object.assign(requestV0({ groupIds }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v1/response.js
var require_response64 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response63();
  var decoderMember = (decoder) => ({
    memberId: decoder.readString(),
    clientId: decoder.readString(),
    clientHost: decoder.readString(),
    memberMetadata: decoder.readBytes(),
    memberAssignment: decoder.readBytes()
  });
  var decodeGroup = (decoder) => ({
    errorCode: decoder.readInt16(),
    groupId: decoder.readString(),
    state: decoder.readString(),
    protocolType: decoder.readString(),
    protocol: decoder.readString(),
    members: decoder.readArray(decoderMember)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const groups = decoder.readArray(decodeGroup);
    return {
      throttleTime,
      groups
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v2/request.js
var require_request65 = __commonJS((exports, module) => {
  var requestV1 = require_request64();
  module.exports = ({ groupIds }) => Object.assign(requestV1({ groupIds }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/v2/response.js
var require_response65 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response64();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeGroups/index.js
var require_describeGroups = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ groupIds }) => {
      const request = require_request63();
      const response = require_response63();
      return { request: request({ groupIds }), response };
    },
    1: ({ groupIds }) => {
      const request = require_request64();
      const response = require_response64();
      return { request: request({ groupIds }), response };
    },
    2: ({ groupIds }) => {
      const request = require_request65();
      const response = require_response65();
      return { request: request({ groupIds }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v0/request.js
var require_request66 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ListGroups: apiKey } = require_apiKeys();
  module.exports = () => ({
    apiKey,
    apiVersion: 0,
    apiName: "ListGroups",
    encode: async () => {
      return new Encoder;
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v0/response.js
var require_response66 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeGroup = (decoder) => ({
    groupId: decoder.readString(),
    protocolType: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    const groups = decoder.readArray(decodeGroup);
    return {
      errorCode,
      groups
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decodeGroup,
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v1/request.js
var require_request67 = __commonJS((exports, module) => {
  var requestV0 = require_request66();
  module.exports = () => Object.assign(requestV0(), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v1/response.js
var require_response67 = __commonJS((exports, module) => {
  var responseV0 = require_response66();
  var Decoder = require_decoder();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const groups = decoder.readArray(responseV0.decodeGroup);
    return {
      throttleTime,
      errorCode,
      groups
    };
  };
  module.exports = {
    decode,
    parse: responseV0.parse
  };
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v2/request.js
var require_request68 = __commonJS((exports, module) => {
  var requestV1 = require_request67();
  module.exports = () => Object.assign(requestV1(), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/listGroups/v2/response.js
var require_response68 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response67();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listGroups/index.js
var require_listGroups = __commonJS((exports, module) => {
  var versions2 = {
    0: () => {
      const request = require_request66();
      const response = require_response66();
      return { request: request(), response };
    },
    1: () => {
      const request = require_request67();
      const response = require_response67();
      return { request: request(), response };
    },
    2: () => {
      const request = require_request68();
      const response = require_response68();
      return { request: request(), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/saslHandshake/v0/request.js
var require_request69 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { SaslHandshake: apiKey } = require_apiKeys();
  module.exports = ({ mechanism }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "SaslHandshake",
    encode: async () => new Encoder().writeString(mechanism)
  });
});

// node_modules/kafkajs/src/protocol/requests/saslHandshake/v0/response.js
var require_response69 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      errorCode,
      enabledMechanisms: decoder.readArray((decoder2) => decoder2.readString())
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/saslHandshake/v1/request.js
var require_request70 = __commonJS((exports, module) => {
  var requestV0 = require_request69();
  module.exports = ({ mechanism }) => ({ ...requestV0({ mechanism }), apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/saslHandshake/v1/response.js
var require_response70 = __commonJS((exports, module) => {
  var { decode: decodeV0, parse: parseV0 } = require_response69();
  module.exports = {
    decode: decodeV0,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/saslHandshake/index.js
var require_saslHandshake = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ mechanism }) => {
      const request = require_request69();
      const response = require_response69();
      return { request: request({ mechanism }), response };
    },
    1: ({ mechanism }) => {
      const request = require_request70();
      const response = require_response70();
      return { request: request({ mechanism }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v0/request.js
var require_request71 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ApiVersions: apiKey } = require_apiKeys();
  module.exports = () => ({
    apiKey,
    apiVersion: 0,
    apiName: "ApiVersions",
    encode: async () => new Encoder
  });
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v0/response.js
var require_response71 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var apiVersion = (decoder) => ({
    apiKey: decoder.readInt16(),
    minVersion: decoder.readInt16(),
    maxVersion: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      errorCode,
      apiVersions: decoder.readArray(apiVersion)
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v1/request.js
var require_request72 = __commonJS((exports, module) => {
  var requestV0 = require_request71();
  module.exports = () => ({ ...requestV0(), apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v1/response.js
var require_response72 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failIfVersionNotSupported } = require_error();
  var { parse: parseV0 } = require_response71();
  var apiVersion = (decoder) => ({
    apiKey: decoder.readInt16(),
    minVersion: decoder.readInt16(),
    maxVersion: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    const apiVersions = decoder.readArray(apiVersion);
    const throttleTime = decoder.canReadInt32() ? decoder.readInt32() : 0;
    return {
      errorCode,
      apiVersions,
      throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v2/request.js
var require_request73 = __commonJS((exports, module) => {
  var requestV0 = require_request71();
  module.exports = () => ({ ...requestV0(), apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/v2/response.js
var require_response73 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response72();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/apiVersions/index.js
var require_apiVersions = __commonJS((exports, module) => {
  var logResponseError = false;
  var versions2 = {
    0: () => {
      const request = require_request71();
      const response = require_response71();
      return { request: request(), response, logResponseError: true };
    },
    1: () => {
      const request = require_request72();
      const response = require_response72();
      return { request: request(), response, logResponseError };
    },
    2: () => {
      const request = require_request73();
      const response = require_response73();
      return { request: request(), response, logResponseError };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v0/request.js
var require_request74 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { CreateTopics: apiKey } = require_apiKeys();
  module.exports = ({ topics, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "CreateTopics",
    encode: async () => {
      return new Encoder().writeArray(topics.map(encodeTopics)).writeInt32(timeout);
    }
  });
  var encodeTopics = ({
    topic,
    numPartitions = -1,
    replicationFactor = -1,
    replicaAssignment = [],
    configEntries = []
  }) => {
    return new Encoder().writeString(topic).writeInt32(numPartitions).writeInt16(replicationFactor).writeArray(replicaAssignment.map(encodeReplicaAssignment)).writeArray(configEntries.map(encodeConfigEntries));
  };
  var encodeReplicaAssignment = ({ partition, replicas }) => {
    return new Encoder().writeInt32(partition).writeArray(replicas);
  };
  var encodeConfigEntries = ({ name, value }) => {
    return new Encoder().writeString(name).writeString(value);
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v0/response.js
var require_response74 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var { KafkaJSAggregateError, KafkaJSCreateTopicError } = require_errors();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  var parse6 = async (data) => {
    const topicsWithError = data.topicErrors.filter(({ errorCode }) => failure(errorCode));
    if (topicsWithError.length > 0) {
      throw new KafkaJSAggregateError("Topic creation errors", topicsWithError.map((error40) => new KafkaJSCreateTopicError(createErrorFromCode(error40.errorCode), error40.topic)));
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v1/request.js
var require_request75 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { CreateTopics: apiKey } = require_apiKeys();
  module.exports = ({ topics, validateOnly = false, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "CreateTopics",
    encode: async () => {
      return new Encoder().writeArray(topics.map(encodeTopics)).writeInt32(timeout).writeBoolean(validateOnly);
    }
  });
  var encodeTopics = ({
    topic,
    numPartitions = -1,
    replicationFactor = -1,
    replicaAssignment = [],
    configEntries = []
  }) => {
    return new Encoder().writeString(topic).writeInt32(numPartitions).writeInt16(replicationFactor).writeArray(replicaAssignment.map(encodeReplicaAssignment)).writeArray(configEntries.map(encodeConfigEntries));
  };
  var encodeReplicaAssignment = ({ partition, replicas }) => {
    return new Encoder().writeInt32(partition).writeArray(replicas);
  };
  var encodeConfigEntries = ({ name, value }) => {
    return new Encoder().writeString(name).writeString(value);
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v1/response.js
var require_response75 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response74();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v2/request.js
var require_request76 = __commonJS((exports, module) => {
  var requestV1 = require_request75();
  module.exports = ({ topics, validateOnly, timeout }) => Object.assign(requestV1({ topics, validateOnly, timeout }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v2/response.js
var require_response76 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV1 } = require_response75();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  module.exports = {
    decode,
    parse: parseV1
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v3/request.js
var require_request77 = __commonJS((exports, module) => {
  var requestV2 = require_request76();
  module.exports = ({ topics, validateOnly, timeout }) => Object.assign(requestV2({ topics, validateOnly, timeout }), { apiVersion: 3 });
});

// node_modules/kafkajs/src/protocol/requests/createTopics/v3/response.js
var require_response77 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV2 } = require_response76();
  var decode = async (rawData) => {
    const decoded = await decodeV2(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createTopics/index.js
var require_createTopics = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics, timeout }) => {
      const request = require_request74();
      const response = require_response74();
      return { request: request({ topics, timeout }), response };
    },
    1: ({ topics, validateOnly, timeout }) => {
      const request = require_request75();
      const response = require_response75();
      return { request: request({ topics, validateOnly, timeout }), response };
    },
    2: ({ topics, validateOnly, timeout }) => {
      const request = require_request76();
      const response = require_response76();
      return { request: request({ topics, validateOnly, timeout }), response };
    },
    3: ({ topics, validateOnly, timeout }) => {
      const request = require_request77();
      const response = require_response77();
      return { request: request({ topics, validateOnly, timeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteTopics/v0/request.js
var require_request78 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DeleteTopics: apiKey } = require_apiKeys();
  module.exports = ({ topics, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DeleteTopics",
    encode: async () => {
      return new Encoder().writeArray(topics).writeInt32(timeout);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/deleteTopics/v0/response.js
var require_response78 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  var parse6 = async (data) => {
    const topicsWithError = data.topicErrors.filter(({ errorCode }) => failure(errorCode));
    if (topicsWithError.length > 0) {
      throw createErrorFromCode(topicsWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteTopics/v1/request.js
var require_request79 = __commonJS((exports, module) => {
  var requestV0 = require_request78();
  module.exports = ({ topics, timeout }) => Object.assign(requestV0({ topics, timeout }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/deleteTopics/v1/response.js
var require_response79 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response78();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    return {
      throttleTime: 0,
      clientSideThrottleTime: throttleTime,
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteTopics/index.js
var require_deleteTopics = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics, timeout }) => {
      const request = require_request78();
      const response = require_response78();
      return { request: request({ topics, timeout }), response };
    },
    1: ({ topics, timeout }) => {
      const request = require_request79();
      const response = require_response79();
      return { request: request({ topics, timeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteRecords/v0/request.js
var require_request80 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DeleteRecords: apiKey } = require_apiKeys();
  module.exports = ({ topics, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DeleteRecords",
    encode: async () => {
      return new Encoder().writeArray(topics.map(({ topic, partitions }) => {
        return new Encoder().writeString(topic).writeArray(partitions.map(({ partition, offset }) => {
          return new Encoder().writeInt32(partition).writeInt64(offset);
        }));
      })).writeInt32(timeout);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/deleteRecords/v0/response.js
var require_response80 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { KafkaJSDeleteTopicRecordsError } = require_errors();
  var { failure, createErrorFromCode } = require_error();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    return {
      throttleTime: decoder.readInt32(),
      topics: decoder.readArray((decoder2) => ({
        topic: decoder2.readString(),
        partitions: decoder2.readArray((decoder3) => ({
          partition: decoder3.readInt32(),
          lowWatermark: decoder3.readInt64(),
          errorCode: decoder3.readInt16()
        }))
      })).sort(topicNameComparator)
    };
  };
  var parse6 = (requestTopics) => async (data) => {
    const topicsWithErrors = data.topics.map(({ partitions }) => ({
      partitionsWithErrors: partitions.filter(({ errorCode }) => failure(errorCode))
    })).filter(({ partitionsWithErrors }) => partitionsWithErrors.length);
    if (topicsWithErrors.length > 0) {
      const [{ topic }] = data.topics;
      const [{ partitions: requestPartitions }] = requestTopics;
      const [{ partitionsWithErrors }] = topicsWithErrors;
      throw new KafkaJSDeleteTopicRecordsError({
        topic,
        partitions: partitionsWithErrors.map(({ partition, errorCode }) => ({
          partition,
          error: createErrorFromCode(errorCode),
          offset: requestPartitions.find((p) => p.partition === partition).offset
        }))
      });
    }
    return data;
  };
  module.exports = ({ topics }) => ({
    decode,
    parse: parse6(topics)
  });
});

// node_modules/kafkajs/src/protocol/requests/deleteRecords/v1/request.js
var require_request81 = __commonJS((exports, module) => {
  var requestV0 = require_request80();
  module.exports = ({ topics, timeout }) => Object.assign(requestV0({ topics, timeout }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/deleteRecords/v1/response.js
var require_response81 = __commonJS((exports, module) => {
  var responseV0 = require_response80();
  module.exports = ({ topics }) => {
    const { parse: parse6, decode: decodeV0 } = responseV0({ topics });
    const decode = async (rawData) => {
      const decoded = await decodeV0(rawData);
      return {
        ...decoded,
        throttleTime: 0,
        clientSideThrottleTime: decoded.throttleTime
      };
    };
    return {
      decode,
      parse: parse6
    };
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteRecords/index.js
var require_deleteRecords = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics, timeout }) => {
      const request = require_request80();
      const response = require_response80();
      return { request: request({ topics, timeout }), response: response({ topics }) };
    },
    1: ({ topics, timeout }) => {
      const request = require_request81();
      const response = require_response81();
      return { request: request({ topics, timeout }), response: response({ topics }) };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/initProducerId/v0/request.js
var require_request82 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { InitProducerId: apiKey } = require_apiKeys();
  module.exports = ({ transactionalId, transactionTimeout }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "InitProducerId",
    encode: async () => {
      return new Encoder().writeString(transactionalId).writeInt32(transactionTimeout);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/initProducerId/v0/response.js
var require_response82 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime,
      errorCode,
      producerId: decoder.readInt64().toString(),
      producerEpoch: decoder.readInt16()
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/initProducerId/v1/request.js
var require_request83 = __commonJS((exports, module) => {
  var requestV0 = require_request82();
  module.exports = ({ transactionalId, transactionTimeout }) => Object.assign(requestV0({ transactionalId, transactionTimeout }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/initProducerId/v1/response.js
var require_response83 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response82();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/initProducerId/index.js
var require_initProducerId = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ transactionalId, transactionTimeout = 5000 }) => {
      const request = require_request82();
      const response = require_response82();
      return { request: request({ transactionalId, transactionTimeout }), response };
    },
    1: ({ transactionalId, transactionTimeout = 5000 }) => {
      const request = require_request83();
      const response = require_response83();
      return { request: request({ transactionalId, transactionTimeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/addPartitionsToTxn/v0/request.js
var require_request84 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { AddPartitionsToTxn: apiKey } = require_apiKeys();
  module.exports = ({ transactionalId, producerId, producerEpoch, topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "AddPartitionsToTxn",
    encode: async () => {
      return new Encoder().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = (partition) => {
    return new Encoder().writeInt32(partition);
  };
});

// node_modules/kafkajs/src/protocol/requests/addPartitionsToTxn/v0/response.js
var require_response84 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errors3 = await decoder.readArrayAsync(decodeError);
    return {
      throttleTime,
      errors: errors3
    };
  };
  var decodeError = async (decoder) => ({
    topic: decoder.readString(),
    partitionErrors: await decoder.readArrayAsync(decodePartitionError)
  });
  var decodePartitionError = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    const topicsWithErrors = data.errors.map(({ partitionErrors }) => ({
      partitionsWithErrors: partitionErrors.filter(({ errorCode }) => failure(errorCode))
    })).filter(({ partitionsWithErrors }) => partitionsWithErrors.length);
    if (topicsWithErrors.length > 0) {
      throw createErrorFromCode(topicsWithErrors[0].partitionsWithErrors[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/addPartitionsToTxn/v1/request.js
var require_request85 = __commonJS((exports, module) => {
  var requestV0 = require_request84();
  module.exports = ({ transactionalId, producerId, producerEpoch, topics }) => Object.assign(requestV0({
    transactionalId,
    producerId,
    producerEpoch,
    topics
  }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/addPartitionsToTxn/v1/response.js
var require_response85 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response84();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/addPartitionsToTxn/index.js
var require_addPartitionsToTxn = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ transactionalId, producerId, producerEpoch, topics }) => {
      const request = require_request84();
      const response = require_response84();
      return { request: request({ transactionalId, producerId, producerEpoch, topics }), response };
    },
    1: ({ transactionalId, producerId, producerEpoch, topics }) => {
      const request = require_request85();
      const response = require_response85();
      return { request: request({ transactionalId, producerId, producerEpoch, topics }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/addOffsetsToTxn/v0/request.js
var require_request86 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { AddOffsetsToTxn: apiKey } = require_apiKeys();
  module.exports = ({ transactionalId, producerId, producerEpoch, groupId }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "AddOffsetsToTxn",
    encode: async () => {
      return new Encoder().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeString(groupId);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/addOffsetsToTxn/v0/response.js
var require_response86 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime,
      errorCode
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/addOffsetsToTxn/v1/request.js
var require_request87 = __commonJS((exports, module) => {
  var requestV0 = require_request86();
  module.exports = ({ transactionalId, producerId, producerEpoch, groupId }) => Object.assign(requestV0({
    transactionalId,
    producerId,
    producerEpoch,
    groupId
  }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/addOffsetsToTxn/v1/response.js
var require_response87 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response86();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/addOffsetsToTxn/index.js
var require_addOffsetsToTxn = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ transactionalId, producerId, producerEpoch, groupId }) => {
      const request = require_request86();
      const response = require_response86();
      return { request: request({ transactionalId, producerId, producerEpoch, groupId }), response };
    },
    1: ({ transactionalId, producerId, producerEpoch, groupId }) => {
      const request = require_request87();
      const response = require_response87();
      return { request: request({ transactionalId, producerId, producerEpoch, groupId }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/endTxn/v0/request.js
var require_request88 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { EndTxn: apiKey } = require_apiKeys();
  module.exports = ({ transactionalId, producerId, producerEpoch, transactionResult }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "EndTxn",
    encode: async () => {
      return new Encoder().writeString(transactionalId).writeInt64(producerId).writeInt16(producerEpoch).writeBoolean(transactionResult);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/endTxn/v0/response.js
var require_response88 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode, failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    return {
      throttleTime,
      errorCode
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/endTxn/v1/request.js
var require_request89 = __commonJS((exports, module) => {
  var requestV0 = require_request88();
  module.exports = ({ transactionalId, producerId, producerEpoch, transactionResult }) => Object.assign(requestV0({ transactionalId, producerId, producerEpoch, transactionResult }), {
    apiVersion: 1
  });
});

// node_modules/kafkajs/src/protocol/requests/endTxn/v1/response.js
var require_response89 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response88();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/endTxn/index.js
var require_endTxn = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ transactionalId, producerId, producerEpoch, transactionResult }) => {
      const request = require_request88();
      const response = require_response88();
      return {
        request: request({ transactionalId, producerId, producerEpoch, transactionResult }),
        response
      };
    },
    1: ({ transactionalId, producerId, producerEpoch, transactionResult }) => {
      const request = require_request89();
      const response = require_response89();
      return {
        request: request({ transactionalId, producerId, producerEpoch, transactionResult }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/txnOffsetCommit/v0/request.js
var require_request90 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { TxnOffsetCommit: apiKey } = require_apiKeys();
  module.exports = ({ transactionalId, groupId, producerId, producerEpoch, topics }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "TxnOffsetCommit",
    encode: async () => {
      return new Encoder().writeString(transactionalId).writeString(groupId).writeInt64(producerId).writeInt16(producerEpoch).writeArray(topics.map(encodeTopic));
    }
  });
  var encodeTopic = ({ topic, partitions }) => {
    return new Encoder().writeString(topic).writeArray(partitions.map(encodePartition));
  };
  var encodePartition = ({ partition, offset, metadata }) => {
    return new Encoder().writeInt32(partition).writeInt64(offset).writeString(metadata);
  };
});

// node_modules/kafkajs/src/protocol/requests/txnOffsetCommit/v0/response.js
var require_response90 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const topics = await decoder.readArrayAsync(decodeTopic);
    return {
      throttleTime,
      topics
    };
  };
  var decodeTopic = async (decoder) => ({
    topic: decoder.readString(),
    partitions: await decoder.readArrayAsync(decodePartition)
  });
  var decodePartition = (decoder) => ({
    partition: decoder.readInt32(),
    errorCode: decoder.readInt16()
  });
  var parse6 = async (data) => {
    const topicsWithErrors = data.topics.map(({ partitions }) => ({
      partitionsWithErrors: partitions.filter(({ errorCode }) => failure(errorCode))
    })).filter(({ partitionsWithErrors }) => partitionsWithErrors.length);
    if (topicsWithErrors.length > 0) {
      throw createErrorFromCode(topicsWithErrors[0].partitionsWithErrors[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/txnOffsetCommit/v1/request.js
var require_request91 = __commonJS((exports, module) => {
  var requestV0 = require_request90();
  module.exports = ({ transactionalId, groupId, producerId, producerEpoch, topics }) => Object.assign(requestV0({ transactionalId, groupId, producerId, producerEpoch, topics }), {
    apiVersion: 1
  });
});

// node_modules/kafkajs/src/protocol/requests/txnOffsetCommit/v1/response.js
var require_response91 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response90();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/txnOffsetCommit/index.js
var require_txnOffsetCommit = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ transactionalId, groupId, producerId, producerEpoch, topics }) => {
      const request = require_request90();
      const response = require_response90();
      return {
        request: request({ transactionalId, groupId, producerId, producerEpoch, topics }),
        response
      };
    },
    1: ({ transactionalId, groupId, producerId, producerEpoch, topics }) => {
      const request = require_request91();
      const response = require_response91();
      return {
        request: request({ transactionalId, groupId, producerId, producerEpoch, topics }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/describeAcls/v0/request.js
var require_request92 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DescribeAcls: apiKey } = require_apiKeys();
  module.exports = ({ resourceType, resourceName, principal, host, operation, permissionType }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DescribeAcls",
    encode: async () => {
      return new Encoder().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/describeAcls/v0/response.js
var require_response92 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeAcls = (decoder) => ({
    principal: decoder.readString(),
    host: decoder.readString(),
    operation: decoder.readInt8(),
    permissionType: decoder.readInt8()
  });
  var decodeResources = (decoder) => ({
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString(),
    acls: decoder.readArray(decodeAcls)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const errorMessage = decoder.readString();
    const resources = decoder.readArray(decodeResources);
    return {
      throttleTime,
      errorCode,
      errorMessage,
      resources
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeAcls/v1/request.js
var require_request93 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DescribeAcls: apiKey } = require_apiKeys();
  module.exports = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host,
    operation,
    permissionType
  }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "DescribeAcls",
    encode: async () => {
      return new Encoder().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/describeAcls/v1/response.js
var require_response93 = __commonJS((exports, module) => {
  var { parse: parse6 } = require_response92();
  var Decoder = require_decoder();
  var decodeAcls = (decoder) => ({
    principal: decoder.readString(),
    host: decoder.readString(),
    operation: decoder.readInt8(),
    permissionType: decoder.readInt8()
  });
  var decodeResources = (decoder) => ({
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString(),
    resourcePatternType: decoder.readInt8(),
    acls: decoder.readArray(decodeAcls)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    const errorMessage = decoder.readString();
    const resources = decoder.readArray(decodeResources);
    return {
      throttleTime: 0,
      clientSideThrottleTime: throttleTime,
      errorCode,
      errorMessage,
      resources
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeAcls/index.js
var require_describeAcls = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ resourceType, resourceName, principal, host, operation, permissionType }) => {
      const request = require_request92();
      const response = require_response92();
      return {
        request: request({ resourceType, resourceName, principal, host, operation, permissionType }),
        response
      };
    },
    1: ({
      resourceType,
      resourceName,
      resourcePatternType,
      principal,
      host,
      operation,
      permissionType
    }) => {
      const request = require_request93();
      const response = require_response93();
      return {
        request: request({
          resourceType,
          resourceName,
          resourcePatternType,
          principal,
          host,
          operation,
          permissionType
        }),
        response
      };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/createAcls/v0/request.js
var require_request94 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { CreateAcls: apiKey } = require_apiKeys();
  var encodeCreations = ({
    resourceType,
    resourceName,
    principal,
    host,
    operation,
    permissionType
  }) => {
    return new Encoder().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
  };
  module.exports = ({ creations }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "CreateAcls",
    encode: async () => {
      return new Encoder().writeArray(creations.map(encodeCreations));
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/createAcls/v0/response.js
var require_response94 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeCreationResponse = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const creationResponses = decoder.readArray(decodeCreationResponse);
    return {
      throttleTime,
      creationResponses
    };
  };
  var parse6 = async (data) => {
    const creationResponsesWithError = data.creationResponses.filter(({ errorCode }) => failure(errorCode));
    if (creationResponsesWithError.length > 0) {
      throw createErrorFromCode(creationResponsesWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createAcls/v1/request.js
var require_request95 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { CreateAcls: apiKey } = require_apiKeys();
  var encodeCreations = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host,
    operation,
    permissionType
  }) => {
    return new Encoder().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
  };
  module.exports = ({ creations }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "CreateAcls",
    encode: async () => {
      return new Encoder().writeArray(creations.map(encodeCreations));
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/createAcls/v1/response.js
var require_response95 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response94();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createAcls/index.js
var require_createAcls = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ creations }) => {
      const request = require_request94();
      const response = require_response94();
      return { request: request({ creations }), response };
    },
    1: ({ creations }) => {
      const request = require_request95();
      const response = require_response95();
      return { request: request({ creations }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteAcls/v0/request.js
var require_request96 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DeleteAcls: apiKey } = require_apiKeys();
  var encodeFilters = ({
    resourceType,
    resourceName,
    principal,
    host,
    operation,
    permissionType
  }) => {
    return new Encoder().writeInt8(resourceType).writeString(resourceName).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
  };
  module.exports = ({ filters }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DeleteAcls",
    encode: async () => {
      return new Encoder().writeArray(filters.map(encodeFilters));
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/deleteAcls/v0/response.js
var require_response96 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeMatchingAcls = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString(),
    principal: decoder.readString(),
    host: decoder.readString(),
    operation: decoder.readInt8(),
    permissionType: decoder.readInt8()
  });
  var decodeFilterResponse = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    matchingAcls: decoder.readArray(decodeMatchingAcls)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const filterResponses = decoder.readArray(decodeFilterResponse);
    return {
      throttleTime,
      filterResponses
    };
  };
  var parse6 = async (data) => {
    const filterResponsesWithError = data.filterResponses.filter(({ errorCode }) => failure(errorCode));
    if (filterResponsesWithError.length > 0) {
      throw createErrorFromCode(filterResponsesWithError[0].errorCode);
    }
    for (const filterResponse of data.filterResponses) {
      const matchingAcls = filterResponse.matchingAcls;
      const matchingAclsWithError = matchingAcls.filter(({ errorCode }) => failure(errorCode));
      if (matchingAclsWithError.length > 0) {
        throw createErrorFromCode(matchingAclsWithError[0].errorCode);
      }
    }
    return data;
  };
  module.exports = {
    decodeMatchingAcls,
    decodeFilterResponse,
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteAcls/v1/request.js
var require_request97 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DeleteAcls: apiKey } = require_apiKeys();
  var encodeFilters = ({
    resourceType,
    resourceName,
    resourcePatternType,
    principal,
    host,
    operation,
    permissionType
  }) => {
    return new Encoder().writeInt8(resourceType).writeString(resourceName).writeInt8(resourcePatternType).writeString(principal).writeString(host).writeInt8(operation).writeInt8(permissionType);
  };
  module.exports = ({ filters }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "DeleteAcls",
    encode: async () => {
      return new Encoder().writeArray(filters.map(encodeFilters));
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/deleteAcls/v1/response.js
var require_response97 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response96();
  var decodeMatchingAcls = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString(),
    resourcePatternType: decoder.readInt8(),
    principal: decoder.readString(),
    host: decoder.readString(),
    operation: decoder.readInt8(),
    permissionType: decoder.readInt8()
  });
  var decodeFilterResponse = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    matchingAcls: decoder.readArray(decodeMatchingAcls)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const filterResponses = decoder.readArray(decodeFilterResponse);
    return {
      throttleTime: 0,
      clientSideThrottleTime: throttleTime,
      filterResponses
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteAcls/index.js
var require_deleteAcls = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ filters }) => {
      const request = require_request96();
      const response = require_response96();
      return { request: request({ filters }), response };
    },
    1: ({ filters }) => {
      const request = require_request97();
      const response = require_response97();
      return { request: request({ filters }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v0/request.js
var require_request98 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DescribeConfigs: apiKey } = require_apiKeys();
  module.exports = ({ resources }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DescribeConfigs",
    encode: async () => {
      return new Encoder().writeArray(resources.map(encodeResource));
    }
  });
  var encodeResource = ({ type, name, configNames = [] }) => {
    return new Encoder().writeInt8(type).writeString(name).writeNullableArray(configNames);
  };
});

// node_modules/kafkajs/src/protocol/configSource.js
var require_configSource = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    TOPIC_CONFIG: 1,
    DYNAMIC_BROKER_CONFIG: 2,
    DYNAMIC_DEFAULT_BROKER_CONFIG: 3,
    STATIC_BROKER_CONFIG: 4,
    DEFAULT_CONFIG: 5,
    DYNAMIC_BROKER_LOGGER_CONFIG: 6
  };
});

// node_modules/kafkajs/src/protocol/configResourceTypes.js
var require_configResourceTypes = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    TOPIC: 2,
    BROKER: 4,
    BROKER_LOGGER: 8
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v0/response.js
var require_response98 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var ConfigSource = require_configSource();
  var ConfigResourceTypes = require_configResourceTypes();
  var decodeConfigEntries = (decoder, resourceType) => {
    const configName = decoder.readString();
    const configValue = decoder.readString();
    const readOnly = decoder.readBoolean();
    const isDefault = decoder.readBoolean();
    const isSensitive = decoder.readBoolean();
    let configSource;
    if (isDefault) {
      configSource = ConfigSource.DEFAULT_CONFIG;
    } else {
      switch (resourceType) {
        case ConfigResourceTypes.BROKER:
          configSource = ConfigSource.STATIC_BROKER_CONFIG;
          break;
        case ConfigResourceTypes.TOPIC:
          configSource = ConfigSource.TOPIC_CONFIG;
          break;
        default:
          configSource = ConfigSource.UNKNOWN;
      }
    }
    return {
      configName,
      configValue,
      readOnly,
      isDefault,
      configSource,
      isSensitive
    };
  };
  var decodeResources = (decoder) => {
    const errorCode = decoder.readInt16();
    const errorMessage = decoder.readString();
    const resourceType = decoder.readInt8();
    const resourceName = decoder.readString();
    const configEntries = decoder.readArray((decoder2) => decodeConfigEntries(decoder2, resourceType));
    return {
      errorCode,
      errorMessage,
      resourceType,
      resourceName,
      configEntries
    };
  };
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources);
    return {
      throttleTime,
      resources
    };
  };
  var parse6 = async (data) => {
    const resourcesWithError = data.resources.filter(({ errorCode }) => failure(errorCode));
    if (resourcesWithError.length > 0) {
      throw createErrorFromCode(resourcesWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v1/request.js
var require_request99 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DescribeConfigs: apiKey } = require_apiKeys();
  module.exports = ({ resources, includeSynonyms = false }) => ({
    apiKey,
    apiVersion: 1,
    apiName: "DescribeConfigs",
    encode: async () => {
      return new Encoder().writeArray(resources.map(encodeResource)).writeBoolean(includeSynonyms);
    }
  });
  var encodeResource = ({ type, name, configNames = [] }) => {
    return new Encoder().writeInt8(type).writeString(name).writeNullableArray(configNames);
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v1/response.js
var require_response99 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { parse: parseV0 } = require_response98();
  var { DEFAULT_CONFIG } = require_configSource();
  var decodeSynonyms = (decoder) => ({
    configName: decoder.readString(),
    configValue: decoder.readString(),
    configSource: decoder.readInt8()
  });
  var decodeConfigEntries = (decoder) => {
    const configName = decoder.readString();
    const configValue = decoder.readString();
    const readOnly = decoder.readBoolean();
    const configSource = decoder.readInt8();
    const isSensitive = decoder.readBoolean();
    const configSynonyms = decoder.readArray(decodeSynonyms);
    return {
      configName,
      configValue,
      readOnly,
      isDefault: configSource === DEFAULT_CONFIG,
      configSource,
      isSensitive,
      configSynonyms
    };
  };
  var decodeResources = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString(),
    configEntries: decoder.readArray(decodeConfigEntries)
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources);
    return {
      throttleTime,
      resources
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v2/request.js
var require_request100 = __commonJS((exports, module) => {
  var requestV1 = require_request99();
  module.exports = ({ resources, includeSynonyms }) => Object.assign(requestV1({ resources, includeSynonyms }), { apiVersion: 2 });
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/v2/response.js
var require_response100 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV1 } = require_response99();
  var decode = async (rawData) => {
    const decoded = await decodeV1(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/describeConfigs/index.js
var require_describeConfigs = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ resources }) => {
      const request = require_request98();
      const response = require_response98();
      return { request: request({ resources }), response };
    },
    1: ({ resources, includeSynonyms }) => {
      const request = require_request99();
      const response = require_response99();
      return { request: request({ resources, includeSynonyms }), response };
    },
    2: ({ resources, includeSynonyms }) => {
      const request = require_request100();
      const response = require_response100();
      return { request: request({ resources, includeSynonyms }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/alterConfigs/v0/request.js
var require_request101 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { AlterConfigs: apiKey } = require_apiKeys();
  module.exports = ({ resources, validateOnly = false }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "AlterConfigs",
    encode: async () => {
      return new Encoder().writeArray(resources.map(encodeResource)).writeBoolean(validateOnly);
    }
  });
  var encodeResource = ({ type, name, configEntries }) => {
    return new Encoder().writeInt8(type).writeString(name).writeArray(configEntries.map(encodeConfigEntries));
  };
  var encodeConfigEntries = ({ name, value }) => {
    return new Encoder().writeString(name).writeString(value);
  };
});

// node_modules/kafkajs/src/protocol/requests/alterConfigs/v0/response.js
var require_response101 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeResources = (decoder) => ({
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString(),
    resourceType: decoder.readInt8(),
    resourceName: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    const resources = decoder.readArray(decodeResources);
    return {
      throttleTime,
      resources
    };
  };
  var parse6 = async (data) => {
    const resourcesWithError = data.resources.filter(({ errorCode }) => failure(errorCode));
    if (resourcesWithError.length > 0) {
      throw createErrorFromCode(resourcesWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/alterConfigs/v1/request.js
var require_request102 = __commonJS((exports, module) => {
  var requestV0 = require_request101();
  module.exports = ({ resources, validateOnly }) => Object.assign(requestV0({
    resources,
    validateOnly
  }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/alterConfigs/v1/response.js
var require_response102 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response101();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/alterConfigs/index.js
var require_alterConfigs = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ resources, validateOnly }) => {
      const request = require_request101();
      const response = require_response101();
      return { request: request({ resources, validateOnly }), response };
    },
    1: ({ resources, validateOnly }) => {
      const request = require_request102();
      const response = require_response102();
      return { request: request({ resources, validateOnly }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/saslAuthenticate/v0/request.js
var require_request103 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { SaslAuthenticate: apiKey } = require_apiKeys();
  module.exports = ({ authBytes }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "SaslAuthenticate",
    encode: async () => {
      return new Encoder().writeBuffer(authBytes);
    }
  });
});

// node_modules/kafkajs/src/protocol/requests/saslAuthenticate/v0/response.js
var require_response103 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var Encoder = require_encoder();
  var {
    failure,
    createErrorFromCode,
    failIfVersionNotSupported,
    errorCodes
  } = require_error();
  var { KafkaJSProtocolError } = require_errors();
  var SASL_AUTHENTICATION_FAILED = 58;
  var protocolAuthError = errorCodes.find((e) => e.code === SASL_AUTHENTICATION_FAILED);
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    const errorMessage = decoder.readString();
    const authBytesEncoder = new Encoder().writeBytes(decoder.readBytes());
    const authBytes = authBytesEncoder.buffer;
    return {
      errorCode,
      errorMessage,
      authBytes
    };
  };
  var parse6 = async (data) => {
    if (data.errorCode === SASL_AUTHENTICATION_FAILED && data.errorMessage) {
      throw new KafkaJSProtocolError({
        ...protocolAuthError,
        message: data.errorMessage
      });
    }
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/saslAuthenticate/v1/request.js
var require_request104 = __commonJS((exports, module) => {
  var requestV0 = require_request103();
  module.exports = ({ authBytes }) => Object.assign(requestV0({ authBytes }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/saslAuthenticate/v1/response.js
var require_response104 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var Encoder = require_encoder();
  var { parse: parseV0 } = require_response103();
  var { failIfVersionNotSupported } = require_error();
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const errorCode = decoder.readInt16();
    failIfVersionNotSupported(errorCode);
    const errorMessage = decoder.readString();
    const authBytesEncoder = new Encoder().writeBytes(decoder.readBytes());
    const authBytes = authBytesEncoder.buffer;
    const sessionLifetimeMs = decoder.readInt64().toString();
    return {
      errorCode,
      errorMessage,
      authBytes,
      sessionLifetimeMs
    };
  };
  module.exports = {
    decode,
    parse: parseV0
  };
});

// node_modules/kafkajs/src/protocol/requests/saslAuthenticate/index.js
var require_saslAuthenticate = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ authBytes }) => {
      const request = require_request103();
      const response = require_response103();
      return { request: request({ authBytes }), response };
    },
    1: ({ authBytes }) => {
      const request = require_request104();
      const response = require_response104();
      return { request: request({ authBytes }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/createPartitions/v0/request.js
var require_request105 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { CreatePartitions: apiKey } = require_apiKeys();
  module.exports = ({ topicPartitions, validateOnly = false, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "CreatePartitions",
    encode: async () => {
      return new Encoder().writeArray(topicPartitions.map(encodeTopicPartitions)).writeInt32(timeout).writeBoolean(validateOnly);
    }
  });
  var encodeTopicPartitions = ({ topic, count, assignments = [] }) => {
    return new Encoder().writeString(topic).writeInt32(count).writeNullableArray(assignments.map(encodeAssignments));
  };
  var encodeAssignments = (brokerIds) => {
    return new Encoder().writeNullableArray(brokerIds);
  };
});

// node_modules/kafkajs/src/protocol/requests/createPartitions/v0/response.js
var require_response105 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var topicNameComparator = (a, b) => a.topic.localeCompare(b.topic);
  var topicErrors = (decoder) => ({
    topic: decoder.readString(),
    errorCode: decoder.readInt16(),
    errorMessage: decoder.readString()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTime = decoder.readInt32();
    return {
      throttleTime,
      topicErrors: decoder.readArray(topicErrors).sort(topicNameComparator)
    };
  };
  var parse6 = async (data) => {
    const topicsWithError = data.topicErrors.filter(({ errorCode }) => failure(errorCode));
    if (topicsWithError.length > 0) {
      throw createErrorFromCode(topicsWithError[0].errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createPartitions/v1/request.js
var require_request106 = __commonJS((exports, module) => {
  var requestV0 = require_request105();
  module.exports = ({ topicPartitions, validateOnly, timeout }) => Object.assign(requestV0({ topicPartitions, validateOnly, timeout }), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/createPartitions/v1/response.js
var require_response106 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response105();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/createPartitions/index.js
var require_createPartitions = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topicPartitions, timeout, validateOnly }) => {
      const request = require_request105();
      const response = require_response105();
      return { request: request({ topicPartitions, timeout, validateOnly }), response };
    },
    1: ({ topicPartitions, validateOnly, timeout }) => {
      const request = require_request106();
      const response = require_response106();
      return { request: request({ topicPartitions, validateOnly, timeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteGroups/v0/request.js
var require_request107 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { DeleteGroups: apiKey } = require_apiKeys();
  module.exports = (groupIds) => ({
    apiKey,
    apiVersion: 0,
    apiName: "DeleteGroups",
    encode: async () => {
      return new Encoder().writeArray(groupIds.map(encodeGroups));
    }
  });
  var encodeGroups = (group) => {
    return new Encoder().writeString(group);
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteGroups/v0/response.js
var require_response107 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeGroup = (decoder) => ({
    groupId: decoder.readString(),
    errorCode: decoder.readInt16()
  });
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    const throttleTimeMs = decoder.readInt32();
    const results = decoder.readArray(decodeGroup);
    for (const result of results) {
      if (failure(result.errorCode)) {
        result.error = createErrorFromCode(result.errorCode);
      }
    }
    return {
      throttleTimeMs,
      results
    };
  };
  var parse6 = async (data) => {
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteGroups/v1/request.js
var require_request108 = __commonJS((exports, module) => {
  var requestV0 = require_request107();
  module.exports = (groupIds) => Object.assign(requestV0(groupIds), { apiVersion: 1 });
});

// node_modules/kafkajs/src/protocol/requests/deleteGroups/v1/response.js
var require_response108 = __commonJS((exports, module) => {
  var { parse: parse6, decode: decodeV0 } = require_response107();
  var decode = async (rawData) => {
    const decoded = await decodeV0(rawData);
    return {
      ...decoded,
      throttleTime: 0,
      clientSideThrottleTime: decoded.throttleTime
    };
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/deleteGroups/index.js
var require_deleteGroups = __commonJS((exports, module) => {
  var versions2 = {
    0: (groupIds) => {
      const request = require_request107();
      const response = require_response107();
      return { request: request(groupIds), response };
    },
    1: (groupIds) => {
      const request = require_request108();
      const response = require_response108();
      return { request: request(groupIds), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/alterPartitionReassignments/v0/request.js
var require_request109 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { AlterPartitionReassignments: apiKey } = require_apiKeys();
  module.exports = ({ topics, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "AlterPartitionReassignments",
    encode: async () => {
      return new Encoder().writeUVarIntBytes().writeInt32(timeout).writeUVarIntArray(topics.map(encodeTopics)).writeUVarIntBytes();
    }
  });
  var encodeTopics = ({ topic, partitionAssignment }) => {
    return new Encoder().writeUVarIntString(topic).writeUVarIntArray(partitionAssignment.map(encodePartitionAssignment)).writeUVarIntBytes();
  };
  var encodePartitionAssignment = ({ partition, replicas }) => {
    return new Encoder().writeInt32(partition).writeUVarIntArray(replicas.map(encodeReplicas)).writeUVarIntBytes();
  };
  var encodeReplicas = (replica) => {
    return new Encoder().writeInt32(replica);
  };
});

// node_modules/kafkajs/src/protocol/requests/alterPartitionReassignments/v0/response.js
var require_response109 = __commonJS((exports, module) => {
  var {
    KafkaJSAggregateError,
    KafkaJSAlterPartitionReassignmentsError
  } = require_errors();
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeResponses = (decoder) => {
    const response = {
      topic: decoder.readUVarIntString(),
      partitions: decoder.readUVarIntArray(decodePartitions)
    };
    decoder.readTaggedFields();
    return response;
  };
  var decodePartitions = (decoder) => {
    const partition = {
      partition: decoder.readInt32(),
      errorCode: decoder.readInt16()
    };
    decoder.readUVarIntString();
    decoder.readTaggedFields();
    return partition;
  };
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    decoder.readTaggedFields();
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    decoder.readUVarIntString();
    return {
      throttleTime,
      errorCode,
      responses: decoder.readUVarIntArray(decodeResponses)
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw new KafkaJSAlterPartitionReassignmentsError(createErrorFromCode(data.errorCode));
    }
    const topicPartitionsWithError = data.responses.flatMap(({ partitions, topic }) => partitions.filter((partition) => failure(partition.errorCode)).map((partition) => ({
      ...partition,
      topic
    })));
    if (topicPartitionsWithError.length > 0) {
      throw new KafkaJSAggregateError("Errors altering partition reassignments", topicPartitionsWithError.map(({ topic, partition, errorCode }) => new KafkaJSAlterPartitionReassignmentsError(createErrorFromCode(errorCode), topic, partition)));
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/alterPartitionReassignments/index.js
var require_alterPartitionReassignments = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics, timeout }) => {
      const request = require_request109();
      const response = require_response109();
      return { request: request({ topics, timeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/listPartitionReassignments/v0/request.js
var require_request110 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var { ListPartitionReassignments: apiKey } = require_apiKeys();
  module.exports = ({ topics = null, timeout = 5000 }) => ({
    apiKey,
    apiVersion: 0,
    apiName: "ListPartitionReassignments",
    encode: async () => {
      return new Encoder().writeUVarIntBytes().writeInt32(timeout).writeUVarIntArray(topics === null ? topics : topics.map(encodeTopics)).writeUVarIntBytes();
    }
  });
  var encodeTopics = ({ topic, partitions }) => {
    return new Encoder().writeUVarIntString(topic).writeUVarIntArray(partitions.map(encodePartitions)).writeUVarIntBytes();
  };
  var encodePartitions = (partition) => {
    return new Encoder().writeInt32(partition);
  };
});

// node_modules/kafkajs/src/protocol/requests/listPartitionReassignments/v0/response.js
var require_response110 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var { failure, createErrorFromCode } = require_error();
  var decodeReplicas = (decoder) => {
    return decoder.readInt32();
  };
  var decodePartitions = (decoder) => {
    const partition = {
      partition: decoder.readInt32(),
      replicas: decoder.readUVarIntArray(decodeReplicas),
      addingReplicas: decoder.readUVarIntArray(decodeReplicas),
      removingReplicas: decoder.readUVarIntArray(decodeReplicas)
    };
    decoder.readTaggedFields();
    return partition;
  };
  var decodeTopics = (decoder) => {
    const topic = {
      name: decoder.readUVarIntString(),
      partitions: decoder.readUVarIntArray(decodePartitions)
    };
    decoder.readTaggedFields();
    return topic;
  };
  var decode = async (rawData) => {
    const decoder = new Decoder(rawData);
    decoder.readTaggedFields();
    const throttleTime = decoder.readInt32();
    const errorCode = decoder.readInt16();
    decoder.readUVarIntString();
    return {
      throttleTime,
      errorCode,
      topics: decoder.readUVarIntArray(decodeTopics)
    };
  };
  var parse6 = async (data) => {
    if (failure(data.errorCode)) {
      throw createErrorFromCode(data.errorCode);
    }
    return data;
  };
  module.exports = {
    decode,
    parse: parse6
  };
});

// node_modules/kafkajs/src/protocol/requests/listPartitionReassignments/index.js
var require_listPartitionReassignments = __commonJS((exports, module) => {
  var versions2 = {
    0: ({ topics, timeout }) => {
      const request = require_request110();
      const response = require_response110();
      return { request: request({ topics, timeout }), response };
    }
  };
  module.exports = {
    versions: Object.keys(versions2),
    protocol: ({ version: version2 }) => versions2[version2]
  };
});

// node_modules/kafkajs/src/protocol/requests/index.js
var require_requests = __commonJS((exports, module) => {
  var apiKeys = require_apiKeys();
  var { KafkaJSServerDoesNotSupportApiKey, KafkaJSNotImplemented } = require_errors();
  var noImplementedRequestDefinitions = {
    versions: [],
    protocol: () => {
      throw new KafkaJSNotImplemented;
    }
  };
  var requests = {
    Produce: require_produce(),
    Fetch: require_fetch(),
    ListOffsets: require_listOffsets(),
    Metadata: require_metadata(),
    LeaderAndIsr: noImplementedRequestDefinitions,
    StopReplica: noImplementedRequestDefinitions,
    UpdateMetadata: noImplementedRequestDefinitions,
    ControlledShutdown: noImplementedRequestDefinitions,
    OffsetCommit: require_offsetCommit(),
    OffsetFetch: require_offsetFetch(),
    GroupCoordinator: require_findCoordinator(),
    JoinGroup: require_joinGroup(),
    Heartbeat: require_heartbeat(),
    LeaveGroup: require_leaveGroup(),
    SyncGroup: require_syncGroup(),
    DescribeGroups: require_describeGroups(),
    ListGroups: require_listGroups(),
    SaslHandshake: require_saslHandshake(),
    ApiVersions: require_apiVersions(),
    CreateTopics: require_createTopics(),
    DeleteTopics: require_deleteTopics(),
    DeleteRecords: require_deleteRecords(),
    InitProducerId: require_initProducerId(),
    OffsetForLeaderEpoch: noImplementedRequestDefinitions,
    AddPartitionsToTxn: require_addPartitionsToTxn(),
    AddOffsetsToTxn: require_addOffsetsToTxn(),
    EndTxn: require_endTxn(),
    WriteTxnMarkers: noImplementedRequestDefinitions,
    TxnOffsetCommit: require_txnOffsetCommit(),
    DescribeAcls: require_describeAcls(),
    CreateAcls: require_createAcls(),
    DeleteAcls: require_deleteAcls(),
    DescribeConfigs: require_describeConfigs(),
    AlterConfigs: require_alterConfigs(),
    AlterReplicaLogDirs: noImplementedRequestDefinitions,
    DescribeLogDirs: noImplementedRequestDefinitions,
    SaslAuthenticate: require_saslAuthenticate(),
    CreatePartitions: require_createPartitions(),
    CreateDelegationToken: noImplementedRequestDefinitions,
    RenewDelegationToken: noImplementedRequestDefinitions,
    ExpireDelegationToken: noImplementedRequestDefinitions,
    DescribeDelegationToken: noImplementedRequestDefinitions,
    DeleteGroups: require_deleteGroups(),
    ElectLeaders: noImplementedRequestDefinitions,
    IncrementalAlterConfigs: noImplementedRequestDefinitions,
    AlterPartitionReassignments: require_alterPartitionReassignments(),
    ListPartitionReassignments: require_listPartitionReassignments()
  };
  var names = Object.keys(apiKeys);
  var keys = Object.values(apiKeys);
  var findApiName = (apiKey) => names[keys.indexOf(apiKey)];
  var lookup = (versions2) => (apiKey, definition) => {
    const version2 = versions2[apiKey];
    const availableVersions = definition.versions.map(Number);
    const bestImplementedVersion = Math.max(...availableVersions);
    if (!version2 || version2.maxVersion == null) {
      throw new KafkaJSServerDoesNotSupportApiKey(`The Kafka server does not support the requested API version`, { apiKey, apiName: findApiName(apiKey) });
    }
    const bestSupportedVersion = Math.min(bestImplementedVersion, version2.maxVersion);
    return definition.protocol({ version: bestSupportedVersion });
  };
  module.exports = {
    requests,
    lookup
  };
});

// node_modules/kafkajs/src/utils/shuffle.js
var require_shuffle = __commonJS((exports, module) => {
  module.exports = (array2) => {
    if (!Array.isArray(array2)) {
      throw new TypeError("'array' is not an array");
    }
    if (array2.length < 2) {
      return array2;
    }
    const copy = array2.slice();
    for (let i = copy.length - 1;i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      const temp = copy[i];
      copy[i] = copy[j];
      copy[j] = temp;
    }
    return copy;
  };
});

// node_modules/kafkajs/src/broker/index.js
var require_broker = __commonJS((exports, module) => {
  var Lock = require_lock();
  var { Types: Compression } = require_compression();
  var { requests, lookup } = require_requests();
  var { KafkaJSNonRetriableError } = require_errors();
  var apiKeys = require_apiKeys();
  var shuffle = require_shuffle();
  var PRIVATE = {
    SEND_REQUEST: Symbol("private:Broker:sendRequest")
  };
  var notInitializedLookup = () => {
    throw new Error("Broker not connected");
  };
  module.exports = class Broker {
    constructor({
      connectionPool,
      logger: logger2,
      nodeId = null,
      versions: versions2 = null,
      authenticationTimeout = 1e4,
      allowAutoTopicCreation = true
    }) {
      this.connectionPool = connectionPool;
      this.nodeId = nodeId;
      this.rootLogger = logger2;
      this.logger = logger2.namespace("Broker");
      this.versions = versions2;
      this.authenticationTimeout = authenticationTimeout;
      this.allowAutoTopicCreation = allowAutoTopicCreation;
      const lockTimeout = 2 * this.connectionPool.connectionTimeout + this.authenticationTimeout;
      this.brokerAddress = `${this.connectionPool.host}:${this.connectionPool.port}`;
      this.lock = new Lock({
        timeout: lockTimeout,
        description: `connect to broker ${this.brokerAddress}`
      });
      this.lookupRequest = notInitializedLookup;
    }
    isConnected() {
      return this.connectionPool.sasl ? this.connectionPool.isConnected() && this.connectionPool.isAuthenticated() : this.connectionPool.isConnected();
    }
    async connect() {
      await this.lock.acquire();
      try {
        if (this.isConnected()) {
          return;
        }
        const connection = await this.connectionPool.getConnection();
        if (!this.versions) {
          this.versions = await this.apiVersions();
        }
        this.connectionPool.setVersions(this.versions);
        this.lookupRequest = lookup(this.versions);
        if (connection.getSupportAuthenticationProtocol() === null) {
          let supportAuthenticationProtocol = false;
          try {
            this.lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate);
            supportAuthenticationProtocol = true;
          } catch (_) {
            supportAuthenticationProtocol = false;
          }
          this.connectionPool.setSupportAuthenticationProtocol(supportAuthenticationProtocol);
          this.logger.debug(`Verified support for SaslAuthenticate`, {
            broker: this.brokerAddress,
            supportAuthenticationProtocol
          });
        }
        await connection.authenticate();
      } finally {
        await this.lock.release();
      }
    }
    async disconnect() {
      await this.connectionPool.destroy();
    }
    async apiVersions() {
      let response;
      const availableVersions = requests.ApiVersions.versions.map(Number).sort().reverse();
      for (const candidateVersion of availableVersions) {
        try {
          const apiVersions = requests.ApiVersions.protocol({ version: candidateVersion });
          response = await this[PRIVATE.SEND_REQUEST]({
            ...apiVersions(),
            requestTimeout: this.connectionPool.connectionTimeout
          });
          break;
        } catch (e) {
          if (e.type !== "UNSUPPORTED_VERSION") {
            throw e;
          }
        }
      }
      if (!response) {
        throw new KafkaJSNonRetriableError("API Versions not supported");
      }
      return response.apiVersions.reduce((obj, version2) => Object.assign(obj, {
        [version2.apiKey]: {
          minVersion: version2.minVersion,
          maxVersion: version2.maxVersion
        }
      }), {});
    }
    async metadata(topics = []) {
      const metadata = this.lookupRequest(apiKeys.Metadata, requests.Metadata);
      const shuffledTopics = shuffle(topics);
      return await this[PRIVATE.SEND_REQUEST](metadata({ topics: shuffledTopics, allowAutoTopicCreation: this.allowAutoTopicCreation }));
    }
    async produce({
      topicData,
      transactionalId,
      producerId,
      producerEpoch,
      acks = -1,
      timeout = 30000,
      compression = Compression.None
    }) {
      const produce = this.lookupRequest(apiKeys.Produce, requests.Produce);
      return await this[PRIVATE.SEND_REQUEST](produce({
        acks,
        timeout,
        compression,
        topicData,
        transactionalId,
        producerId,
        producerEpoch
      }));
    }
    async fetch({
      replicaId,
      isolationLevel,
      maxWaitTime = 5000,
      minBytes = 1,
      maxBytes = 10485760,
      topics,
      rackId = ""
    }) {
      const fetch = this.lookupRequest(apiKeys.Fetch, requests.Fetch);
      const flattenedTopicPartitions = topics.reduce((topicPartitions, { topic, partitions }) => {
        partitions.forEach((partition) => {
          topicPartitions.push({ topic, partition });
        });
        return topicPartitions;
      }, []);
      const shuffledTopicPartitions = shuffle(flattenedTopicPartitions);
      const consolidatedTopicPartitions = shuffledTopicPartitions.reduce((topicPartitions, { topic, partition }) => {
        const last = topicPartitions[topicPartitions.length - 1];
        if (last != null && last.topic === topic) {
          topicPartitions[topicPartitions.length - 1].partitions.push(partition);
        } else {
          topicPartitions.push({ topic, partitions: [partition] });
        }
        return topicPartitions;
      }, []);
      return await this[PRIVATE.SEND_REQUEST](fetch({
        replicaId,
        isolationLevel,
        maxWaitTime,
        minBytes,
        maxBytes,
        topics: consolidatedTopicPartitions,
        rackId
      }));
    }
    async heartbeat({ groupId, groupGenerationId, memberId }) {
      const heartbeat = this.lookupRequest(apiKeys.Heartbeat, requests.Heartbeat);
      return await this[PRIVATE.SEND_REQUEST](heartbeat({ groupId, groupGenerationId, memberId }));
    }
    async findGroupCoordinator({ groupId, coordinatorType }) {
      const findCoordinator = this.lookupRequest(apiKeys.GroupCoordinator, requests.GroupCoordinator);
      return await this[PRIVATE.SEND_REQUEST](findCoordinator({ groupId, coordinatorType }));
    }
    async joinGroup({
      groupId,
      sessionTimeout,
      rebalanceTimeout,
      memberId = "",
      protocolType = "consumer",
      groupProtocols
    }) {
      const joinGroup = this.lookupRequest(apiKeys.JoinGroup, requests.JoinGroup);
      const makeRequest = (assignedMemberId = memberId) => this[PRIVATE.SEND_REQUEST](joinGroup({
        groupId,
        sessionTimeout,
        rebalanceTimeout,
        memberId: assignedMemberId,
        protocolType,
        groupProtocols
      }));
      try {
        return await makeRequest();
      } catch (error40) {
        if (error40.name === "KafkaJSMemberIdRequired") {
          return makeRequest(error40.memberId);
        }
        throw error40;
      }
    }
    async leaveGroup({ groupId, memberId }) {
      const leaveGroup = this.lookupRequest(apiKeys.LeaveGroup, requests.LeaveGroup);
      return await this[PRIVATE.SEND_REQUEST](leaveGroup({ groupId, memberId }));
    }
    async syncGroup({ groupId, generationId, memberId, groupAssignment }) {
      const syncGroup = this.lookupRequest(apiKeys.SyncGroup, requests.SyncGroup);
      return await this[PRIVATE.SEND_REQUEST](syncGroup({
        groupId,
        generationId,
        memberId,
        groupAssignment
      }));
    }
    async listOffsets({ replicaId, isolationLevel, topics }) {
      const listOffsets = this.lookupRequest(apiKeys.ListOffsets, requests.ListOffsets);
      const result = await this[PRIVATE.SEND_REQUEST](listOffsets({ replicaId, isolationLevel, topics }));
      for (const response of result.responses) {
        response.partitions = response.partitions.map(({ offsets, ...partitionData }) => {
          return offsets ? { ...partitionData, offset: offsets.pop() } : partitionData;
        });
      }
      return result;
    }
    async offsetCommit({ groupId, groupGenerationId, memberId, retentionTime, topics }) {
      const offsetCommit = this.lookupRequest(apiKeys.OffsetCommit, requests.OffsetCommit);
      return await this[PRIVATE.SEND_REQUEST](offsetCommit({
        groupId,
        groupGenerationId,
        memberId,
        retentionTime,
        topics
      }));
    }
    async offsetFetch({ groupId, topics }) {
      const offsetFetch = this.lookupRequest(apiKeys.OffsetFetch, requests.OffsetFetch);
      return await this[PRIVATE.SEND_REQUEST](offsetFetch({ groupId, topics }));
    }
    async describeGroups({ groupIds }) {
      const describeGroups = this.lookupRequest(apiKeys.DescribeGroups, requests.DescribeGroups);
      return await this[PRIVATE.SEND_REQUEST](describeGroups({ groupIds }));
    }
    async createTopics({ topics, validateOnly = false, timeout = 5000 }) {
      const createTopics = this.lookupRequest(apiKeys.CreateTopics, requests.CreateTopics);
      return await this[PRIVATE.SEND_REQUEST](createTopics({ topics, validateOnly, timeout }));
    }
    async createPartitions({ topicPartitions, validateOnly = false, timeout = 5000 }) {
      const createPartitions = this.lookupRequest(apiKeys.CreatePartitions, requests.CreatePartitions);
      return await this[PRIVATE.SEND_REQUEST](createPartitions({ topicPartitions, validateOnly, timeout }));
    }
    async deleteTopics({ topics, timeout = 5000 }) {
      const deleteTopics = this.lookupRequest(apiKeys.DeleteTopics, requests.DeleteTopics);
      return await this[PRIVATE.SEND_REQUEST](deleteTopics({ topics, timeout }));
    }
    async describeConfigs({ resources, includeSynonyms = false }) {
      const describeConfigs = this.lookupRequest(apiKeys.DescribeConfigs, requests.DescribeConfigs);
      return await this[PRIVATE.SEND_REQUEST](describeConfigs({ resources, includeSynonyms }));
    }
    async alterConfigs({ resources, validateOnly = false }) {
      const alterConfigs = this.lookupRequest(apiKeys.AlterConfigs, requests.AlterConfigs);
      return await this[PRIVATE.SEND_REQUEST](alterConfigs({ resources, validateOnly }));
    }
    async initProducerId({ transactionalId, transactionTimeout }) {
      const initProducerId = this.lookupRequest(apiKeys.InitProducerId, requests.InitProducerId);
      return await this[PRIVATE.SEND_REQUEST](initProducerId({ transactionalId, transactionTimeout }));
    }
    async addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics }) {
      const addPartitionsToTxn = this.lookupRequest(apiKeys.AddPartitionsToTxn, requests.AddPartitionsToTxn);
      return await this[PRIVATE.SEND_REQUEST](addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics }));
    }
    async addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId }) {
      const addOffsetsToTxn = this.lookupRequest(apiKeys.AddOffsetsToTxn, requests.AddOffsetsToTxn);
      return await this[PRIVATE.SEND_REQUEST](addOffsetsToTxn({ transactionalId, producerId, producerEpoch, groupId }));
    }
    async txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics }) {
      const txnOffsetCommit = this.lookupRequest(apiKeys.TxnOffsetCommit, requests.TxnOffsetCommit);
      return await this[PRIVATE.SEND_REQUEST](txnOffsetCommit({ transactionalId, groupId, producerId, producerEpoch, topics }));
    }
    async endTxn({ transactionalId, producerId, producerEpoch, transactionResult }) {
      const endTxn = this.lookupRequest(apiKeys.EndTxn, requests.EndTxn);
      return await this[PRIVATE.SEND_REQUEST](endTxn({ transactionalId, producerId, producerEpoch, transactionResult }));
    }
    async listGroups() {
      const listGroups = this.lookupRequest(apiKeys.ListGroups, requests.ListGroups);
      return await this[PRIVATE.SEND_REQUEST](listGroups());
    }
    async deleteGroups(groupIds) {
      const deleteGroups = this.lookupRequest(apiKeys.DeleteGroups, requests.DeleteGroups);
      return await this[PRIVATE.SEND_REQUEST](deleteGroups(groupIds));
    }
    async deleteRecords({ topics }) {
      const deleteRecords = this.lookupRequest(apiKeys.DeleteRecords, requests.DeleteRecords);
      return await this[PRIVATE.SEND_REQUEST](deleteRecords({ topics }));
    }
    async createAcls({ acl }) {
      const createAcls = this.lookupRequest(apiKeys.CreateAcls, requests.CreateAcls);
      return await this[PRIVATE.SEND_REQUEST](createAcls({ creations: acl }));
    }
    async describeAcls({
      resourceType,
      resourceName,
      resourcePatternType,
      principal,
      host,
      operation,
      permissionType
    }) {
      const describeAcls = this.lookupRequest(apiKeys.DescribeAcls, requests.DescribeAcls);
      return await this[PRIVATE.SEND_REQUEST](describeAcls({
        resourceType,
        resourceName,
        resourcePatternType,
        principal,
        host,
        operation,
        permissionType
      }));
    }
    async deleteAcls({ filters }) {
      const deleteAcls = this.lookupRequest(apiKeys.DeleteAcls, requests.DeleteAcls);
      return await this[PRIVATE.SEND_REQUEST](deleteAcls({ filters }));
    }
    async alterPartitionReassignments({ topics, timeout }) {
      const alterPartitionReassignments = this.lookupRequest(apiKeys.AlterPartitionReassignments, requests.AlterPartitionReassignments);
      return await this[PRIVATE.SEND_REQUEST](alterPartitionReassignments({ topics, timeout }));
    }
    async listPartitionReassignments({ topics = null, timeout }) {
      const listPartitionReassignments = this.lookupRequest(apiKeys.ListPartitionReassignments, requests.ListPartitionReassignments);
      return await this[PRIVATE.SEND_REQUEST](listPartitionReassignments({ topics, timeout }));
    }
    async[PRIVATE.SEND_REQUEST](protocolRequest) {
      try {
        return await this.connectionPool.send(protocolRequest);
      } catch (e) {
        if (e.name === "KafkaJSConnectionClosedError") {
          await this.disconnect();
        }
        throw e;
      }
    }
  };
});

// node_modules/kafkajs/src/retry/defaults.test.js
var require_defaults_test = __commonJS((exports, module) => {
  module.exports = {
    maxRetryTime: 1000,
    initialRetryTime: 50,
    factor: 0.02,
    multiplier: 1.5,
    retries: 15
  };
});

// node_modules/kafkajs/src/retry/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    maxRetryTime: 30 * 1000,
    initialRetryTime: 300,
    factor: 0.2,
    multiplier: 2,
    retries: 5
  };
});

// node_modules/kafkajs/src/retry/index.js
var require_retry = __commonJS((exports, module) => {
  var { KafkaJSNumberOfRetriesExceeded, KafkaJSNonRetriableError } = require_errors();
  var isTestMode = false;
  var RETRY_DEFAULT = isTestMode ? require_defaults_test() : require_defaults();
  var random = (min, max) => {
    return Math.random() * (max - min) + min;
  };
  var randomFromRetryTime = (factor, retryTime) => {
    const delta = factor * retryTime;
    return Math.ceil(random(retryTime - delta, retryTime + delta));
  };
  var UNRECOVERABLE_ERRORS = ["RangeError", "ReferenceError", "SyntaxError", "TypeError"];
  var isErrorUnrecoverable = (e) => UNRECOVERABLE_ERRORS.includes(e.name);
  var isErrorRetriable = (error40) => (error40.retriable || error40.retriable !== false) && !isErrorUnrecoverable(error40);
  var createRetriable = (configs, resolve, reject, fn) => {
    let aborted2 = false;
    const { factor, multiplier, maxRetryTime, retries } = configs;
    const bail = (error40) => {
      aborted2 = true;
      reject(error40 || new Error("Aborted"));
    };
    const calculateExponentialRetryTime = (retryTime) => {
      return Math.min(randomFromRetryTime(factor, retryTime) * multiplier, maxRetryTime);
    };
    const retry = (retryTime, retryCount = 0) => {
      if (aborted2)
        return;
      const nextRetryTime = calculateExponentialRetryTime(retryTime);
      const shouldRetry = retryCount < retries;
      const scheduleRetry = () => {
        setTimeout(() => retry(nextRetryTime, retryCount + 1), retryTime);
      };
      fn(bail, retryCount, retryTime).then(resolve).catch((e) => {
        if (isErrorRetriable(e)) {
          if (shouldRetry) {
            scheduleRetry();
          } else {
            reject(new KafkaJSNumberOfRetriesExceeded(e, { retryCount, retryTime, cause: e.cause || e }));
          }
        } else {
          reject(new KafkaJSNonRetriableError(e, { cause: e.cause || e }));
        }
      });
    };
    return retry;
  };
  module.exports = (opts = {}) => (fn) => {
    return new Promise((resolve, reject) => {
      const configs = Object.assign({}, RETRY_DEFAULT, opts);
      const start = createRetriable(configs, resolve, reject, fn);
      start(randomFromRetryTime(configs.factor, configs.initialRetryTime));
    });
  };
});

// node_modules/kafkajs/src/utils/arrayDiff.js
var require_arrayDiff = __commonJS((exports, module) => {
  module.exports = (a, b) => {
    const result = [];
    const length = a.length;
    let i = 0;
    while (i < length) {
      if (b.indexOf(a[i]) === -1) {
        result.push(a[i]);
      }
      i += 1;
    }
    return result;
  };
});

// node_modules/kafkajs/src/cluster/brokerPool.js
var require_brokerPool = __commonJS((exports, module) => {
  var Broker = require_broker();
  var createRetry = require_retry();
  var shuffle = require_shuffle();
  var arrayDiff = require_arrayDiff();
  var { KafkaJSBrokerNotFound, KafkaJSProtocolError } = require_errors();
  var { keys, assign, values } = Object;
  var hasBrokerBeenReplaced = (broker, { host, port, rack }) => broker.connectionPool.host !== host || broker.connectionPool.port !== port || broker.connectionPool.rack !== rack;
  module.exports = class BrokerPool {
    constructor({
      connectionPoolBuilder,
      logger: logger2,
      retry,
      allowAutoTopicCreation,
      authenticationTimeout,
      metadataMaxAge
    }) {
      this.rootLogger = logger2;
      this.connectionPoolBuilder = connectionPoolBuilder;
      this.metadataMaxAge = metadataMaxAge || 0;
      this.logger = logger2.namespace("BrokerPool");
      this.retrier = createRetry(assign({}, retry));
      this.createBroker = (options) => new Broker({
        allowAutoTopicCreation,
        authenticationTimeout,
        ...options
      });
      this.brokers = {};
      this.seedBroker = undefined;
      this.metadata = null;
      this.metadataExpireAt = null;
      this.versions = null;
    }
    hasConnectedBrokers() {
      const brokers = values(this.brokers);
      return !!brokers.find((broker) => broker.isConnected()) || (this.seedBroker ? this.seedBroker.isConnected() : false);
    }
    async createSeedBroker() {
      if (this.seedBroker) {
        await this.seedBroker.disconnect();
      }
      const connectionPool = await this.connectionPoolBuilder.build();
      this.seedBroker = this.createBroker({
        connectionPool,
        logger: this.rootLogger
      });
    }
    async connect() {
      if (this.hasConnectedBrokers()) {
        return;
      }
      if (!this.seedBroker) {
        await this.createSeedBroker();
      }
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          await this.seedBroker.connect();
          this.versions = this.seedBroker.versions;
        } catch (e) {
          if (e.name === "KafkaJSConnectionError" || e.type === "ILLEGAL_SASL_STATE") {
            await this.createSeedBroker();
            this.logger.error(`Failed to connect to seed broker, trying another broker from the list: ${e.message}`, { retryCount, retryTime });
          } else {
            this.logger.error(e.message, { retryCount, retryTime });
          }
          if (e.retriable)
            throw e;
          bail(e);
        }
      });
    }
    async disconnect() {
      this.seedBroker && await this.seedBroker.disconnect();
      await Promise.all(values(this.brokers).map((broker) => broker.disconnect()));
      this.brokers = {};
      this.metadata = null;
      this.versions = null;
    }
    removeBroker({ host, port }) {
      const removedBroker = values(this.brokers).find((broker) => broker.connectionPool.host === host && broker.connectionPool.port === port);
      if (removedBroker) {
        delete this.brokers[removedBroker.nodeId];
        this.metadataExpireAt = null;
        if (this.seedBroker.nodeId === removedBroker.nodeId) {
          this.seedBroker = shuffle(values(this.brokers))[0];
        }
      }
    }
    async refreshMetadata(topics) {
      const broker = await this.findConnectedBroker();
      const { host: seedHost, port: seedPort } = this.seedBroker.connectionPool;
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          this.metadata = await broker.metadata(topics);
          this.metadataExpireAt = Date.now() + this.metadataMaxAge;
          const replacedBrokers = [];
          this.brokers = await this.metadata.brokers.reduce(async (resultPromise, { nodeId, host, port, rack }) => {
            const result = await resultPromise;
            if (result[nodeId]) {
              if (!hasBrokerBeenReplaced(result[nodeId], { host, port, rack })) {
                return result;
              }
              replacedBrokers.push(result[nodeId]);
            }
            if (host === seedHost && port === seedPort) {
              this.seedBroker.nodeId = nodeId;
              this.seedBroker.connectionPool.rack = rack;
              return assign(result, {
                [nodeId]: this.seedBroker
              });
            }
            return assign(result, {
              [nodeId]: this.createBroker({
                logger: this.rootLogger,
                versions: this.versions,
                connectionPool: await this.connectionPoolBuilder.build({ host, port, rack }),
                nodeId
              })
            });
          }, this.brokers);
          const freshBrokerIds = this.metadata.brokers.map(({ nodeId }) => `${nodeId}`).sort();
          const currentBrokerIds = keys(this.brokers).sort();
          const unusedBrokerIds = arrayDiff(currentBrokerIds, freshBrokerIds);
          const brokerDisconnects = unusedBrokerIds.map((nodeId) => {
            const broker2 = this.brokers[nodeId];
            return broker2.disconnect().then(() => {
              delete this.brokers[nodeId];
            });
          });
          const replacedBrokersDisconnects = replacedBrokers.map((broker2) => broker2.disconnect());
          await Promise.all([...brokerDisconnects, ...replacedBrokersDisconnects]);
        } catch (e) {
          if (e.type === "LEADER_NOT_AVAILABLE") {
            throw e;
          }
          bail(e);
        }
      });
    }
    async refreshMetadataIfNecessary(topics) {
      const shouldRefresh = this.metadata == null || this.metadataExpireAt == null || Date.now() > this.metadataExpireAt || !topics.every((topic) => this.metadata.topicMetadata.some((topicMetadata) => topicMetadata.topic === topic));
      if (shouldRefresh) {
        return this.refreshMetadata(topics);
      }
    }
    getNodeIds() {
      return keys(this.brokers);
    }
    async findBroker({ nodeId }) {
      const broker = this.brokers[nodeId];
      if (!broker) {
        throw new KafkaJSBrokerNotFound(`Broker ${nodeId} not found in the cached metadata`);
      }
      await this.connectBroker(broker);
      return broker;
    }
    async withBroker(callback) {
      const brokers = shuffle(keys(this.brokers));
      if (brokers.length === 0) {
        throw new KafkaJSBrokerNotFound("No brokers in the broker pool");
      }
      for (const nodeId of brokers) {
        const broker = await this.findBroker({ nodeId });
        try {
          return await callback({ nodeId, broker });
        } catch (e) {}
      }
      return null;
    }
    async findConnectedBroker() {
      const nodeIds = shuffle(keys(this.brokers));
      const connectedBrokerId = nodeIds.find((nodeId) => this.brokers[nodeId].isConnected());
      if (connectedBrokerId) {
        return await this.findBroker({ nodeId: connectedBrokerId });
      }
      for (const nodeId of nodeIds) {
        try {
          return await this.findBroker({ nodeId });
        } catch (e) {}
      }
      await this.connect();
      return this.seedBroker;
    }
    async connectBroker(broker) {
      if (broker.isConnected()) {
        return;
      }
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          await broker.connect();
        } catch (e) {
          if (e.name === "KafkaJSConnectionError" || e.type === "ILLEGAL_SASL_STATE") {
            await broker.disconnect();
          }
          if (e.name === "KafkaJSConnectionError") {
            return bail(e);
          }
          if (e.type === "ILLEGAL_SASL_STATE") {
            broker.connectionPool = await this.connectionPoolBuilder.build({
              host: broker.connectionPool.host,
              port: broker.connectionPool.port,
              rack: broker.connectionPool.rack
            });
            this.logger.error(`Failed to connect to broker, reconnecting`, { retryCount, retryTime });
            throw new KafkaJSProtocolError(e, { retriable: true });
          }
          if (e.retriable)
            throw e;
          this.logger.error(e, { retryCount, retryTime, stack: e.stack });
          bail(e);
        }
      });
    }
  };
});

// node_modules/kafkajs/src/utils/sharedPromiseTo.js
var require_sharedPromiseTo = __commonJS((exports, module) => {
  module.exports = (asyncFunction) => {
    let promise2 = null;
    return (...args) => {
      if (promise2 == null) {
        promise2 = asyncFunction(...args).finally(() => promise2 = null);
      }
      return promise2;
    };
  };
});

// node_modules/kafkajs/src/network/socket.js
var require_socket = __commonJS((exports, module) => {
  module.exports = ({
    socketFactory,
    host,
    port,
    ssl,
    onConnect,
    onData,
    onEnd,
    onError,
    onTimeout
  }) => {
    const socket = socketFactory({ host, port, ssl, onConnect });
    socket.on("data", onData);
    socket.on("end", onEnd);
    socket.on("error", onError);
    socket.on("timeout", onTimeout);
    return socket;
  };
});

// node_modules/kafkajs/src/protocol/request.js
var require_request111 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  module.exports = async ({ correlationId, clientId, request: { apiKey, apiVersion, encode } }) => {
    const payload = await encode();
    const requestPayload = new Encoder().writeInt16(apiKey).writeInt16(apiVersion).writeInt32(correlationId).writeString(clientId).writeEncoder(payload);
    return new Encoder().writeInt32(requestPayload.size()).writeEncoder(requestPayload);
  };
});

// node_modules/kafkajs/src/constants.js
var require_constants = __commonJS((exports, module) => {
  var EARLIEST_OFFSET = -2;
  var LATEST_OFFSET = -1;
  var INT_32_MAX_VALUE = Math.pow(2, 31) - 1;
  module.exports = {
    EARLIEST_OFFSET,
    LATEST_OFFSET,
    INT_32_MAX_VALUE
  };
});

// node_modules/kafkajs/src/env.js
var require_env = __commonJS((exports, module) => {
  module.exports = () => ({
    KAFKAJS_DEBUG_PROTOCOL_BUFFERS: process.env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS,
    KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS: process.env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS
  });
});

// node_modules/kafkajs/src/instrumentation/eventType.js
var require_eventType = __commonJS((exports, module) => {
  module.exports = (namespace) => (type) => `${namespace}.${type}`;
});

// node_modules/kafkajs/src/network/instrumentationEvents.js
var require_instrumentationEvents = __commonJS((exports, module) => {
  var InstrumentationEventType = require_eventType();
  var eventType = InstrumentationEventType("network");
  module.exports = {
    NETWORK_REQUEST: eventType("request"),
    NETWORK_REQUEST_TIMEOUT: eventType("request_timeout"),
    NETWORK_REQUEST_QUEUE_SIZE: eventType("request_queue_size")
  };
});

// node_modules/kafkajs/src/network/requestQueue/socketRequest.js
var require_socketRequest = __commonJS((exports, module) => {
  var { KafkaJSRequestTimeoutError, KafkaJSNonRetriableError } = require_errors();
  var events = require_instrumentationEvents();
  var PRIVATE = {
    STATE: Symbol("private:SocketRequest:state"),
    EMIT_EVENT: Symbol("private:SocketRequest:emitEvent")
  };
  var REQUEST_STATE = {
    PENDING: Symbol("PENDING"),
    SENT: Symbol("SENT"),
    COMPLETED: Symbol("COMPLETED"),
    REJECTED: Symbol("REJECTED")
  };
  module.exports = class SocketRequest {
    constructor({
      requestTimeout,
      broker,
      clientId,
      entry,
      expectResponse,
      send,
      timeout,
      instrumentationEmitter = null
    }) {
      this.createdAt = Date.now();
      this.requestTimeout = requestTimeout;
      this.broker = broker;
      this.clientId = clientId;
      this.entry = entry;
      this.correlationId = entry.correlationId;
      this.expectResponse = expectResponse;
      this.sendRequest = send;
      this.timeoutHandler = timeout;
      this.sentAt = null;
      this.duration = null;
      this.pendingDuration = null;
      this[PRIVATE.STATE] = REQUEST_STATE.PENDING;
      this[PRIVATE.EMIT_EVENT] = (eventName, payload) => instrumentationEmitter && instrumentationEmitter.emit(eventName, payload);
    }
    send() {
      this.throwIfInvalidState({
        accepted: [REQUEST_STATE.PENDING],
        next: REQUEST_STATE.SENT
      });
      this.sendRequest();
      this.sentAt = Date.now();
      this.pendingDuration = this.sentAt - this.createdAt;
      this[PRIVATE.STATE] = REQUEST_STATE.SENT;
    }
    timeoutRequest() {
      const { apiName, apiKey, apiVersion } = this.entry;
      const requestInfo = `${apiName}(key: ${apiKey}, version: ${apiVersion})`;
      const eventData = {
        broker: this.broker,
        clientId: this.clientId,
        correlationId: this.correlationId,
        createdAt: this.createdAt,
        sentAt: this.sentAt,
        pendingDuration: this.pendingDuration
      };
      this.timeoutHandler();
      this.rejected(new KafkaJSRequestTimeoutError(`Request ${requestInfo} timed out`, eventData));
      this[PRIVATE.EMIT_EVENT](events.NETWORK_REQUEST_TIMEOUT, {
        ...eventData,
        apiName,
        apiKey,
        apiVersion
      });
    }
    completed({ size, payload }) {
      this.throwIfInvalidState({
        accepted: [REQUEST_STATE.SENT],
        next: REQUEST_STATE.COMPLETED
      });
      const { entry, correlationId, broker, clientId, createdAt, sentAt, pendingDuration } = this;
      this[PRIVATE.STATE] = REQUEST_STATE.COMPLETED;
      this.duration = Date.now() - this.sentAt;
      entry.resolve({ correlationId, entry, size, payload });
      this[PRIVATE.EMIT_EVENT](events.NETWORK_REQUEST, {
        broker,
        clientId,
        correlationId,
        size,
        createdAt,
        sentAt,
        pendingDuration,
        duration: this.duration,
        apiName: entry.apiName,
        apiKey: entry.apiKey,
        apiVersion: entry.apiVersion
      });
    }
    rejected(error40) {
      this.throwIfInvalidState({
        accepted: [REQUEST_STATE.PENDING, REQUEST_STATE.SENT],
        next: REQUEST_STATE.REJECTED
      });
      this[PRIVATE.STATE] = REQUEST_STATE.REJECTED;
      this.duration = Date.now() - this.sentAt;
      this.entry.reject(error40);
    }
    throwIfInvalidState({ accepted, next }) {
      if (accepted.includes(this[PRIVATE.STATE])) {
        return;
      }
      const current = this[PRIVATE.STATE].toString();
      throw new KafkaJSNonRetriableError(`Invalid state, can't transition from ${current} to ${next.toString()}`);
    }
  };
});

// node_modules/kafkajs/src/network/requestQueue/index.js
var require_requestQueue = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var SocketRequest = require_socketRequest();
  var events = require_instrumentationEvents();
  var { KafkaJSInvariantViolation } = require_errors();
  var PRIVATE = {
    EMIT_QUEUE_SIZE_EVENT: Symbol("private:RequestQueue:emitQueueSizeEvent"),
    EMIT_REQUEST_QUEUE_EMPTY: Symbol("private:RequestQueue:emitQueueEmpty")
  };
  var REQUEST_QUEUE_EMPTY = "requestQueueEmpty";
  var CHECK_PENDING_REQUESTS_INTERVAL = 10;
  module.exports = class RequestQueue extends EventEmitter {
    constructor({
      instrumentationEmitter = null,
      maxInFlightRequests,
      requestTimeout,
      enforceRequestTimeout,
      clientId,
      broker,
      logger: logger2,
      isConnected = () => true
    }) {
      super();
      this.instrumentationEmitter = instrumentationEmitter;
      this.maxInFlightRequests = maxInFlightRequests;
      this.requestTimeout = requestTimeout;
      this.enforceRequestTimeout = enforceRequestTimeout;
      this.clientId = clientId;
      this.broker = broker;
      this.logger = logger2;
      this.isConnected = isConnected;
      this.inflight = new Map;
      this.pending = [];
      this.throttledUntil = -1;
      this.throttleCheckTimeoutId = null;
      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY] = () => {
        if (this.pending.length === 0 && this.inflight.size === 0) {
          this.emit(REQUEST_QUEUE_EMPTY);
        }
      };
      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT] = () => {
        instrumentationEmitter && instrumentationEmitter.emit(events.NETWORK_REQUEST_QUEUE_SIZE, {
          broker: this.broker,
          clientId: this.clientId,
          queueSize: this.pending.length
        });
        this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();
      };
    }
    scheduleRequestTimeoutCheck() {
      if (this.enforceRequestTimeout) {
        this.destroy();
        this.requestTimeoutIntervalId = setInterval(() => {
          this.inflight.forEach((request) => {
            if (Date.now() - request.sentAt > request.requestTimeout) {
              request.timeoutRequest();
            }
          });
          if (!this.isConnected()) {
            this.destroy();
          }
        }, Math.min(this.requestTimeout, 100));
      }
    }
    maybeThrottle(clientSideThrottleTime) {
      if (clientSideThrottleTime !== null && clientSideThrottleTime > 0) {
        this.logger.debug(`Client side throttling in effect for ${clientSideThrottleTime}ms`);
        const minimumThrottledUntil = Date.now() + clientSideThrottleTime;
        this.throttledUntil = Math.max(minimumThrottledUntil, this.throttledUntil);
      }
    }
    createSocketRequest(pushedRequest) {
      const { correlationId } = pushedRequest.entry;
      const defaultRequestTimeout = this.requestTimeout;
      const customRequestTimeout = pushedRequest.requestTimeout;
      const requestTimeout = Math.max(defaultRequestTimeout, customRequestTimeout || 0);
      const socketRequest = new SocketRequest({
        entry: pushedRequest.entry,
        expectResponse: pushedRequest.expectResponse,
        broker: this.broker,
        clientId: this.clientId,
        instrumentationEmitter: this.instrumentationEmitter,
        requestTimeout,
        send: () => {
          if (this.inflight.has(correlationId)) {
            throw new KafkaJSInvariantViolation("Correlation id already exists");
          }
          this.inflight.set(correlationId, socketRequest);
          pushedRequest.sendRequest();
        },
        timeout: () => {
          this.inflight.delete(correlationId);
          this.checkPendingRequests();
          this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();
        }
      });
      return socketRequest;
    }
    push(pushedRequest) {
      const { correlationId } = pushedRequest.entry;
      const socketRequest = this.createSocketRequest(pushedRequest);
      if (this.canSendSocketRequestImmediately()) {
        this.sendSocketRequest(socketRequest);
        return;
      }
      this.pending.push(socketRequest);
      this.scheduleCheckPendingRequests();
      this.logger.debug(`Request enqueued`, {
        clientId: this.clientId,
        broker: this.broker,
        correlationId
      });
      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();
    }
    sendSocketRequest(socketRequest) {
      socketRequest.send();
      if (!socketRequest.expectResponse) {
        this.logger.debug(`Request does not expect a response, resolving immediately`, {
          clientId: this.clientId,
          broker: this.broker,
          correlationId: socketRequest.correlationId
        });
        this.inflight.delete(socketRequest.correlationId);
        socketRequest.completed({ size: 0, payload: null });
      }
    }
    fulfillRequest({ correlationId, payload, size }) {
      const socketRequest = this.inflight.get(correlationId);
      this.inflight.delete(correlationId);
      this.checkPendingRequests();
      if (socketRequest) {
        socketRequest.completed({ size, payload });
      } else {
        this.logger.warn(`Response without match`, {
          clientId: this.clientId,
          broker: this.broker,
          correlationId
        });
      }
      this[PRIVATE.EMIT_REQUEST_QUEUE_EMPTY]();
    }
    rejectAll(error40) {
      const requests = [...this.inflight.values(), ...this.pending];
      for (const socketRequest of requests) {
        socketRequest.rejected(error40);
        this.inflight.delete(socketRequest.correlationId);
      }
      this.pending = [];
      this.inflight.clear();
      this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();
    }
    waitForPendingRequests() {
      return new Promise((resolve) => {
        if (this.pending.length === 0 && this.inflight.size === 0) {
          return resolve();
        }
        this.logger.debug("Waiting for pending requests", {
          clientId: this.clientId,
          broker: this.broker,
          currentInflightRequests: this.inflight.size,
          currentPendingQueueSize: this.pending.length
        });
        this.once(REQUEST_QUEUE_EMPTY, () => resolve());
      });
    }
    destroy() {
      clearInterval(this.requestTimeoutIntervalId);
      clearTimeout(this.throttleCheckTimeoutId);
      this.throttleCheckTimeoutId = null;
    }
    canSendSocketRequestImmediately() {
      const shouldEnqueue = this.maxInFlightRequests != null && this.inflight.size >= this.maxInFlightRequests || this.throttledUntil > Date.now();
      return !shouldEnqueue;
    }
    checkPendingRequests() {
      while (this.pending.length > 0 && this.canSendSocketRequestImmediately()) {
        const pendingRequest = this.pending.shift();
        this.sendSocketRequest(pendingRequest);
        this.logger.debug(`Consumed pending request`, {
          clientId: this.clientId,
          broker: this.broker,
          correlationId: pendingRequest.correlationId,
          pendingDuration: pendingRequest.pendingDuration,
          currentPendingQueueSize: this.pending.length
        });
        this[PRIVATE.EMIT_QUEUE_SIZE_EVENT]();
      }
      this.scheduleCheckPendingRequests();
    }
    scheduleCheckPendingRequests() {
      let scheduleAt = this.throttledUntil - Date.now();
      if (!this.throttleCheckTimeoutId) {
        if (this.pending.length > 0) {
          scheduleAt = scheduleAt > 0 ? scheduleAt : CHECK_PENDING_REQUESTS_INTERVAL;
        }
        this.throttleCheckTimeoutId = setTimeout(() => {
          this.throttleCheckTimeoutId = null;
          this.checkPendingRequests();
        }, scheduleAt);
      }
    }
  };
});

// node_modules/kafkajs/src/network/connectionStatus.js
var require_connectionStatus = __commonJS((exports, module) => {
  var CONNECTION_STATUS = {
    CONNECTED: "connected",
    DISCONNECTING: "disconnecting",
    DISCONNECTED: "disconnected"
  };
  var CONNECTED_STATUS = [CONNECTION_STATUS.CONNECTED, CONNECTION_STATUS.DISCONNECTING];
  module.exports = {
    CONNECTION_STATUS,
    CONNECTED_STATUS
  };
});

// node_modules/kafkajs/src/protocol/sasl/plain/request.js
var require_request112 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var US_ASCII_NULL_CHAR = "\x00";
  module.exports = ({ authorizationIdentity = null, username, password }) => ({
    encode: async () => {
      return new Encoder().writeBytes([authorizationIdentity, username, password].join(US_ASCII_NULL_CHAR)).buffer;
    }
  });
});

// node_modules/kafkajs/src/protocol/sasl/plain/response.js
var require_response111 = __commonJS((exports, module) => {
  module.exports = {
    decode: async () => true,
    parse: async () => true
  };
});

// node_modules/kafkajs/src/protocol/sasl/plain/index.js
var require_plain = __commonJS((exports, module) => {
  module.exports = {
    request: require_request112(),
    response: require_response111()
  };
});

// node_modules/kafkajs/src/broker/saslAuthenticator/plain.js
var require_plain2 = __commonJS((exports, module) => {
  var { request, response } = require_plain();
  var { KafkaJSSASLAuthenticationError } = require_errors();
  var plainAuthenticatorProvider = (sasl) => ({ host, port, logger: logger2, saslAuthenticate }) => {
    return {
      authenticate: async () => {
        if (sasl.username == null || sasl.password == null) {
          throw new KafkaJSSASLAuthenticationError("SASL Plain: Invalid username or password");
        }
        const broker = `${host}:${port}`;
        try {
          logger2.debug("Authenticate with SASL PLAIN", { broker });
          await saslAuthenticate({ request: request(sasl), response });
          logger2.debug("SASL PLAIN authentication successful", { broker });
        } catch (e) {
          const error40 = new KafkaJSSASLAuthenticationError(`SASL PLAIN authentication failed: ${e.message}`);
          logger2.error(error40.message, { broker });
          throw error40;
        }
      }
    };
  };
  module.exports = plainAuthenticatorProvider;
});

// node_modules/kafkajs/src/protocol/sasl/scram/firstMessage/request.js
var require_request113 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  module.exports = ({ clientFirstMessage }) => ({
    encode: async () => new Encoder().writeBytes(clientFirstMessage).buffer
  });
});

// node_modules/kafkajs/src/protocol/sasl/scram/firstMessage/response.js
var require_response112 = __commonJS((exports, module) => {
  var Decoder = require_decoder();
  var ENTRY_REGEX = /^([rsiev])=(.*)$/;
  module.exports = {
    decode: async (rawData) => {
      return new Decoder(rawData).readBytes();
    },
    parse: async (data) => {
      const processed = data.toString().split(",").map((str) => {
        const [_, key, value] = str.match(ENTRY_REGEX);
        return [key, value];
      }).reduce((obj, entry) => ({ ...obj, [entry[0]]: entry[1] }), {});
      return { original: data.toString(), ...processed };
    }
  };
});

// node_modules/kafkajs/src/protocol/sasl/scram/finalMessage/request.js
var require_request114 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  module.exports = ({ finalMessage }) => ({
    encode: async () => new Encoder().writeBytes(finalMessage).buffer
  });
});

// node_modules/kafkajs/src/protocol/sasl/scram/index.js
var require_scram = __commonJS((exports, module) => {
  module.exports = {
    firstMessage: {
      request: require_request113(),
      response: require_response112()
    },
    finalMessage: {
      request: require_request114(),
      response: require_response112()
    }
  };
});

// node_modules/kafkajs/src/broker/saslAuthenticator/scram.js
var require_scram2 = __commonJS((exports, module) => {
  var crypto2 = __require("crypto");
  var scram = require_scram();
  var { KafkaJSSASLAuthenticationError, KafkaJSNonRetriableError } = require_errors();
  var GS2_HEADER = "n,,";
  var EQUAL_SIGN_REGEX = /=/g;
  var COMMA_SIGN_REGEX = /,/g;
  var URLSAFE_BASE64_PLUS_REGEX = /\+/g;
  var URLSAFE_BASE64_SLASH_REGEX = /\//g;
  var URLSAFE_BASE64_TRAILING_EQUAL_REGEX = /=+$/;
  var HMAC_CLIENT_KEY = "Client Key";
  var HMAC_SERVER_KEY = "Server Key";
  var DIGESTS = {
    SHA256: {
      length: 32,
      type: "sha256",
      minIterations: 4096
    },
    SHA512: {
      length: 64,
      type: "sha512",
      minIterations: 4096
    }
  };
  var encode64 = (str) => Buffer.from(str).toString("base64");

  class SCRAM {
    static sanitizeString(str) {
      return str.replace(EQUAL_SIGN_REGEX, "=3D").replace(COMMA_SIGN_REGEX, "=2C");
    }
    static nonce() {
      return crypto2.randomBytes(16).toString("base64").replace(URLSAFE_BASE64_PLUS_REGEX, "-").replace(URLSAFE_BASE64_SLASH_REGEX, "_").replace(URLSAFE_BASE64_TRAILING_EQUAL_REGEX, "").toString("ascii");
    }
    static hi(password, salt, iterations, digestDefinition) {
      return new Promise((resolve, reject) => {
        crypto2.pbkdf2(password, salt, iterations, digestDefinition.length, digestDefinition.type, (err, derivedKey) => err ? reject(err) : resolve(derivedKey));
      });
    }
    static xor(left, right) {
      const bufferA = Buffer.from(left);
      const bufferB = Buffer.from(right);
      const length = Buffer.byteLength(bufferA);
      if (length !== Buffer.byteLength(bufferB)) {
        throw new KafkaJSNonRetriableError("Buffers must be of the same length");
      }
      const result = [];
      for (let i = 0;i < length; i++) {
        result.push(bufferA[i] ^ bufferB[i]);
      }
      return Buffer.from(result);
    }
    constructor(sasl, host, port, logger2, saslAuthenticate, digestDefinition) {
      this.sasl = sasl;
      this.host = host;
      this.port = port;
      this.logger = logger2;
      this.saslAuthenticate = saslAuthenticate;
      this.digestDefinition = digestDefinition;
      const digestType = digestDefinition.type.toUpperCase();
      this.PREFIX = `SASL SCRAM ${digestType} authentication`;
      this.currentNonce = SCRAM.nonce();
    }
    async authenticate() {
      const { PREFIX } = this;
      const broker = `${this.host}:${this.port}`;
      if (this.sasl.username == null || this.sasl.password == null) {
        throw new KafkaJSSASLAuthenticationError(`${this.PREFIX}: Invalid username or password`);
      }
      try {
        this.logger.debug("Exchanging first client message", { broker });
        const clientMessageResponse = await this.sendClientFirstMessage();
        this.logger.debug("Sending final message", { broker });
        const finalResponse = await this.sendClientFinalMessage(clientMessageResponse);
        if (finalResponse.e) {
          throw new Error(finalResponse.e);
        }
        const serverKey = await this.serverKey(clientMessageResponse);
        const serverSignature = this.serverSignature(serverKey, clientMessageResponse);
        if (finalResponse.v !== serverSignature) {
          throw new Error("Invalid server signature in server final message");
        }
        this.logger.debug(`${PREFIX} successful`, { broker });
      } catch (e) {
        const error40 = new KafkaJSSASLAuthenticationError(`${PREFIX} failed: ${e.message}`);
        this.logger.error(error40.message, { broker });
        throw error40;
      }
    }
    async sendClientFirstMessage() {
      const clientFirstMessage = `${GS2_HEADER}${this.firstMessageBare()}`;
      const request = scram.firstMessage.request({ clientFirstMessage });
      const response = scram.firstMessage.response;
      return this.saslAuthenticate({
        request,
        response
      });
    }
    async sendClientFinalMessage(clientMessageResponse) {
      const { PREFIX } = this;
      const iterations = parseInt(clientMessageResponse.i, 10);
      const { minIterations } = this.digestDefinition;
      if (!clientMessageResponse.r.startsWith(this.currentNonce)) {
        throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Invalid server nonce, it does not start with the client nonce`);
      }
      if (iterations < minIterations) {
        throw new KafkaJSSASLAuthenticationError(`${PREFIX} failed: Requested iterations ${iterations} is less than the minimum ${minIterations}`);
      }
      const finalMessageWithoutProof = this.finalMessageWithoutProof(clientMessageResponse);
      const clientProof = await this.clientProof(clientMessageResponse);
      const finalMessage = `${finalMessageWithoutProof},p=${clientProof}`;
      const request = scram.finalMessage.request({ finalMessage });
      const response = scram.finalMessage.response;
      return this.saslAuthenticate({
        request,
        response
      });
    }
    async clientProof(clientMessageResponse) {
      const clientKey = await this.clientKey(clientMessageResponse);
      const storedKey = this.H(clientKey);
      const clientSignature = this.clientSignature(storedKey, clientMessageResponse);
      return encode64(SCRAM.xor(clientKey, clientSignature));
    }
    async clientKey(clientMessageResponse) {
      const saltedPassword = await this.saltPassword(clientMessageResponse);
      return this.HMAC(saltedPassword, HMAC_CLIENT_KEY);
    }
    async serverKey(clientMessageResponse) {
      const saltedPassword = await this.saltPassword(clientMessageResponse);
      return this.HMAC(saltedPassword, HMAC_SERVER_KEY);
    }
    clientSignature(storedKey, clientMessageResponse) {
      return this.HMAC(storedKey, this.authMessage(clientMessageResponse));
    }
    serverSignature(serverKey, clientMessageResponse) {
      return encode64(this.HMAC(serverKey, this.authMessage(clientMessageResponse)));
    }
    authMessage(clientMessageResponse) {
      return [
        this.firstMessageBare(),
        clientMessageResponse.original,
        this.finalMessageWithoutProof(clientMessageResponse)
      ].join(",");
    }
    async saltPassword(clientMessageResponse) {
      const salt = Buffer.from(clientMessageResponse.s, "base64");
      const iterations = parseInt(clientMessageResponse.i, 10);
      return SCRAM.hi(this.encodedPassword(), salt, iterations, this.digestDefinition);
    }
    firstMessageBare() {
      return `n=${this.encodedUsername()},r=${this.currentNonce}`;
    }
    finalMessageWithoutProof(clientMessageResponse) {
      const rnonce = clientMessageResponse.r;
      return `c=${encode64(GS2_HEADER)},r=${rnonce}`;
    }
    encodedUsername() {
      const { username } = this.sasl;
      return SCRAM.sanitizeString(username).toString("utf-8");
    }
    encodedPassword() {
      const { password } = this.sasl;
      return password.toString("utf-8");
    }
    H(data) {
      return crypto2.createHash(this.digestDefinition.type).update(data).digest();
    }
    HMAC(key, data) {
      return crypto2.createHmac(this.digestDefinition.type, key).update(data).digest();
    }
  }
  module.exports = {
    DIGESTS,
    SCRAM
  };
});

// node_modules/kafkajs/src/broker/saslAuthenticator/scram256.js
var require_scram256 = __commonJS((exports, module) => {
  var { SCRAM, DIGESTS } = require_scram2();
  var scram256AuthenticatorProvider = (sasl) => ({ host, port, logger: logger2, saslAuthenticate }) => {
    const scram = new SCRAM(sasl, host, port, logger2, saslAuthenticate, DIGESTS.SHA256);
    return {
      authenticate: async () => await scram.authenticate()
    };
  };
  module.exports = scram256AuthenticatorProvider;
});

// node_modules/kafkajs/src/broker/saslAuthenticator/scram512.js
var require_scram512 = __commonJS((exports, module) => {
  var { SCRAM, DIGESTS } = require_scram2();
  var scram512AuthenticatorProvider = (sasl) => ({ host, port, logger: logger2, saslAuthenticate }) => {
    const scram = new SCRAM(sasl, host, port, logger2, saslAuthenticate, DIGESTS.SHA512);
    return {
      authenticate: async () => await scram.authenticate()
    };
  };
  module.exports = scram512AuthenticatorProvider;
});

// node_modules/kafkajs/src/protocol/sasl/awsIam/request.js
var require_request115 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var US_ASCII_NULL_CHAR = "\x00";
  module.exports = ({ authorizationIdentity, accessKeyId, secretAccessKey, sessionToken = "" }) => ({
    encode: async () => {
      return new Encoder().writeBytes([authorizationIdentity, accessKeyId, secretAccessKey, sessionToken].join(US_ASCII_NULL_CHAR)).buffer;
    }
  });
});

// node_modules/kafkajs/src/protocol/sasl/awsIam/response.js
var require_response113 = __commonJS((exports, module) => {
  module.exports = {
    decode: async () => true,
    parse: async () => true
  };
});

// node_modules/kafkajs/src/protocol/sasl/awsIam/index.js
var require_awsIam = __commonJS((exports, module) => {
  module.exports = {
    request: require_request115(),
    response: require_response113()
  };
});

// node_modules/kafkajs/src/broker/saslAuthenticator/awsIam.js
var require_awsIam2 = __commonJS((exports, module) => {
  var { request, response } = require_awsIam();
  var { KafkaJSSASLAuthenticationError } = require_errors();
  var awsIAMAuthenticatorProvider = (sasl) => ({ host, port, logger: logger2, saslAuthenticate }) => {
    return {
      authenticate: async () => {
        if (!sasl.authorizationIdentity) {
          throw new KafkaJSSASLAuthenticationError("SASL AWS-IAM: Missing authorizationIdentity");
        }
        if (!sasl.accessKeyId) {
          throw new KafkaJSSASLAuthenticationError("SASL AWS-IAM: Missing accessKeyId");
        }
        if (!sasl.secretAccessKey) {
          throw new KafkaJSSASLAuthenticationError("SASL AWS-IAM: Missing secretAccessKey");
        }
        if (!sasl.sessionToken) {
          sasl.sessionToken = "";
        }
        const broker = `${host}:${port}`;
        try {
          logger2.debug("Authenticate with SASL AWS-IAM", { broker });
          await saslAuthenticate({ request: request(sasl), response });
          logger2.debug("SASL AWS-IAM authentication successful", { broker });
        } catch (e) {
          const error40 = new KafkaJSSASLAuthenticationError(`SASL AWS-IAM authentication failed: ${e.message}`);
          logger2.error(error40.message, { broker });
          throw error40;
        }
      }
    };
  };
  module.exports = awsIAMAuthenticatorProvider;
});

// node_modules/kafkajs/src/protocol/sasl/oauthBearer/request.js
var require_request116 = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var SEPARATOR = "\x01";
  function formatExtensions(extensions) {
    let msg = "";
    if (extensions == null) {
      return msg;
    }
    let prefix = "";
    for (const k in extensions) {
      msg += `${prefix}${k}=${extensions[k]}`;
      prefix = SEPARATOR;
    }
    return msg;
  }
  module.exports = async ({ authorizationIdentity = null }, oauthBearerToken) => {
    const authzid = authorizationIdentity == null ? "" : `"a=${authorizationIdentity}`;
    let ext = formatExtensions(oauthBearerToken.extensions);
    if (ext.length > 0) {
      ext = `${SEPARATOR}${ext}`;
    }
    const oauthMsg = `n,${authzid},${SEPARATOR}auth=Bearer ${oauthBearerToken.value}${ext}${SEPARATOR}${SEPARATOR}`;
    return {
      encode: async () => {
        return new Encoder().writeBytes(Buffer.from(oauthMsg)).buffer;
      }
    };
  };
});

// node_modules/kafkajs/src/protocol/sasl/oauthBearer/response.js
var require_response114 = __commonJS((exports, module) => {
  module.exports = {
    decode: async () => true,
    parse: async () => true
  };
});

// node_modules/kafkajs/src/protocol/sasl/oauthBearer/index.js
var require_oauthBearer = __commonJS((exports, module) => {
  module.exports = {
    request: require_request116(),
    response: require_response114()
  };
});

// node_modules/kafkajs/src/broker/saslAuthenticator/oauthBearer.js
var require_oauthBearer2 = __commonJS((exports, module) => {
  var { request } = require_oauthBearer();
  var { KafkaJSSASLAuthenticationError } = require_errors();
  var oauthBearerAuthenticatorProvider = (sasl) => ({ host, port, logger: logger2, saslAuthenticate }) => {
    return {
      authenticate: async () => {
        const { oauthBearerProvider } = sasl;
        if (oauthBearerProvider == null) {
          throw new KafkaJSSASLAuthenticationError("SASL OAUTHBEARER: Missing OAuth bearer token provider");
        }
        const oauthBearerToken = await oauthBearerProvider();
        if (oauthBearerToken.value == null) {
          throw new KafkaJSSASLAuthenticationError("SASL OAUTHBEARER: Invalid OAuth bearer token");
        }
        const broker = `${host}:${port}`;
        try {
          logger2.debug("Authenticate with SASL OAUTHBEARER", { broker });
          await saslAuthenticate({ request: await request(sasl, oauthBearerToken) });
          logger2.debug("SASL OAUTHBEARER authentication successful", { broker });
        } catch (e) {
          const error40 = new KafkaJSSASLAuthenticationError(`SASL OAUTHBEARER authentication failed: ${e.message}`);
          logger2.error(error40.message, { broker });
          throw error40;
        }
      }
    };
  };
  module.exports = oauthBearerAuthenticatorProvider;
});

// node_modules/kafkajs/src/broker/saslAuthenticator/index.js
var require_saslAuthenticator = __commonJS((exports, module) => {
  var { requests, lookup } = require_requests();
  var apiKeys = require_apiKeys();
  var plainAuthenticatorProvider = require_plain2();
  var scram256AuthenticatorProvider = require_scram256();
  var scram512AuthenticatorProvider = require_scram512();
  var awsIAMAuthenticatorProvider = require_awsIam2();
  var oauthBearerAuthenticatorProvider = require_oauthBearer2();
  var { KafkaJSSASLAuthenticationError } = require_errors();
  var BUILT_IN_AUTHENTICATION_PROVIDERS = {
    AWS: awsIAMAuthenticatorProvider,
    PLAIN: plainAuthenticatorProvider,
    OAUTHBEARER: oauthBearerAuthenticatorProvider,
    "SCRAM-SHA-256": scram256AuthenticatorProvider,
    "SCRAM-SHA-512": scram512AuthenticatorProvider
  };
  var UNLIMITED_SESSION_LIFETIME = "0";
  module.exports = class SASLAuthenticator {
    constructor(connection, logger2, versions2, supportAuthenticationProtocol) {
      this.connection = connection;
      this.logger = logger2;
      this.sessionLifetime = UNLIMITED_SESSION_LIFETIME;
      const lookupRequest = lookup(versions2);
      this.saslHandshake = lookupRequest(apiKeys.SaslHandshake, requests.SaslHandshake);
      this.protocolAuthentication = supportAuthenticationProtocol ? lookupRequest(apiKeys.SaslAuthenticate, requests.SaslAuthenticate) : null;
    }
    async authenticate() {
      const mechanism = this.connection.sasl.mechanism.toUpperCase();
      const handshake = await this.connection.send(this.saslHandshake({ mechanism }));
      if (!handshake.enabledMechanisms.includes(mechanism)) {
        throw new KafkaJSSASLAuthenticationError(`SASL ${mechanism} mechanism is not supported by the server`);
      }
      const saslAuthenticate = async ({ request, response }) => {
        if (this.protocolAuthentication) {
          const requestAuthBytes = await request.encode();
          const authResponse = await this.connection.send(this.protocolAuthentication({ authBytes: requestAuthBytes }));
          this.sessionLifetime = authResponse.sessionLifetimeMs || UNLIMITED_SESSION_LIFETIME;
          if (!response) {
            return;
          }
          const { authBytes: responseAuthBytes } = authResponse;
          const payloadDecoded = await response.decode(responseAuthBytes);
          return response.parse(payloadDecoded);
        }
        return this.connection.sendAuthRequest({ request, response });
      };
      if (!this.connection.sasl.authenticationProvider && Object.keys(BUILT_IN_AUTHENTICATION_PROVIDERS).includes(mechanism)) {
        this.connection.sasl.authenticationProvider = BUILT_IN_AUTHENTICATION_PROVIDERS[mechanism](this.connection.sasl);
      }
      await this.connection.sasl.authenticationProvider({
        host: this.connection.host,
        port: this.connection.port,
        logger: this.logger.namespace(`SaslAuthenticator-${mechanism}`),
        saslAuthenticate
      }).authenticate();
    }
  };
});

// node_modules/kafkajs/src/network/connection.js
var require_connection = __commonJS((exports, module) => {
  var createSocket = require_socket();
  var createRequest = require_request111();
  var Decoder = require_decoder();
  var { KafkaJSConnectionError, KafkaJSConnectionClosedError } = require_errors();
  var { INT_32_MAX_VALUE } = require_constants();
  var getEnv = require_env();
  var RequestQueue = require_requestQueue();
  var { CONNECTION_STATUS, CONNECTED_STATUS } = require_connectionStatus();
  var sharedPromiseTo = require_sharedPromiseTo();
  var Long = require_long();
  var SASLAuthenticator = require_saslAuthenticator();
  var apiKeys = require_apiKeys();
  var requestInfo = ({ apiName, apiKey, apiVersion }) => `${apiName}(key: ${apiKey}, version: ${apiVersion})`;
  var isAuthenticatedRequest = (request) => {
    return ![apiKeys.ApiVersions, apiKeys.SaslHandshake, apiKeys.SaslAuthenticate].includes(request.apiKey);
  };
  var PRIVATE = {
    SHOULD_REAUTHENTICATE: Symbol("private:Connection:shouldReauthenticate"),
    AUTHENTICATE: Symbol("private:Connection:authenticate")
  };
  module.exports = class Connection {
    constructor({
      host,
      port,
      logger: logger2,
      socketFactory,
      requestTimeout,
      reauthenticationThreshold = 1e4,
      rack = null,
      ssl = null,
      sasl = null,
      clientId = "kafkajs",
      connectionTimeout,
      enforceRequestTimeout = true,
      maxInFlightRequests = null,
      instrumentationEmitter = null
    }) {
      this.host = host;
      this.port = port;
      this.rack = rack;
      this.clientId = clientId;
      this.broker = `${this.host}:${this.port}`;
      this.logger = logger2.namespace("Connection");
      this.socketFactory = socketFactory;
      this.ssl = ssl;
      this.sasl = sasl;
      this.requestTimeout = requestTimeout;
      this.connectionTimeout = connectionTimeout;
      this.reauthenticationThreshold = reauthenticationThreshold;
      this.bytesBuffered = 0;
      this.bytesNeeded = Decoder.int32Size();
      this.chunks = [];
      this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;
      this.correlationId = 0;
      this.requestQueue = new RequestQueue({
        instrumentationEmitter,
        maxInFlightRequests,
        requestTimeout,
        enforceRequestTimeout,
        clientId,
        broker: this.broker,
        logger: logger2.namespace("RequestQueue"),
        isConnected: () => this.isConnected()
      });
      this.versions = null;
      this.authHandlers = null;
      this.authExpectResponse = false;
      const log2 = (level) => (message, extra = {}) => {
        const logFn = this.logger[level];
        logFn(message, { broker: this.broker, clientId, ...extra });
      };
      this.logDebug = log2("debug");
      this.logError = log2("error");
      const env = getEnv();
      this.shouldLogBuffers = env.KAFKAJS_DEBUG_PROTOCOL_BUFFERS === "1";
      this.shouldLogFetchBuffer = this.shouldLogBuffers && env.KAFKAJS_DEBUG_EXTENDED_PROTOCOL_BUFFERS === "1";
      this.authenticatedAt = null;
      this.sessionLifetime = Long.ZERO;
      this.supportAuthenticationProtocol = null;
      this[PRIVATE.AUTHENTICATE] = sharedPromiseTo(async () => {
        if (this.sasl && !this.isAuthenticated()) {
          const authenticator = new SASLAuthenticator(this, this.logger, this.versions, this.supportAuthenticationProtocol);
          await authenticator.authenticate();
          this.authenticatedAt = process.hrtime();
          this.sessionLifetime = Long.fromValue(authenticator.sessionLifetime);
        }
      });
    }
    getSupportAuthenticationProtocol() {
      return this.supportAuthenticationProtocol;
    }
    setSupportAuthenticationProtocol(isSupported) {
      this.supportAuthenticationProtocol = isSupported;
    }
    setVersions(versions2) {
      this.versions = versions2;
    }
    isConnected() {
      return CONNECTED_STATUS.includes(this.connectionStatus);
    }
    connect() {
      return new Promise((resolve, reject) => {
        if (this.isConnected()) {
          return resolve(true);
        }
        this.authenticatedAt = null;
        let timeoutId;
        const onConnect = () => {
          clearTimeout(timeoutId);
          this.connectionStatus = CONNECTION_STATUS.CONNECTED;
          this.requestQueue.scheduleRequestTimeoutCheck();
          resolve(true);
        };
        const onData = (data) => {
          this.processData(data);
        };
        const onEnd = async () => {
          clearTimeout(timeoutId);
          const wasConnected = this.isConnected();
          if (this.authHandlers) {
            this.authHandlers.onError();
          } else if (wasConnected) {
            this.logDebug("Kafka server has closed connection");
            this.rejectRequests(new KafkaJSConnectionClosedError("Closed connection", {
              host: this.host,
              port: this.port
            }));
          }
          await this.disconnect();
        };
        const onError = async (e) => {
          clearTimeout(timeoutId);
          const error40 = new KafkaJSConnectionError(`Connection error: ${e.message}`, {
            broker: `${this.host}:${this.port}`,
            code: e.code
          });
          this.logError(error40.message, { stack: e.stack });
          this.rejectRequests(error40);
          await this.disconnect();
          reject(error40);
        };
        const onTimeout = async () => {
          const error40 = new KafkaJSConnectionError("Connection timeout", {
            broker: `${this.host}:${this.port}`
          });
          this.logError(error40.message);
          this.rejectRequests(error40);
          await this.disconnect();
          reject(error40);
        };
        this.logDebug(`Connecting`, {
          ssl: !!this.ssl,
          sasl: !!this.sasl
        });
        try {
          timeoutId = setTimeout(onTimeout, this.connectionTimeout);
          this.socket = createSocket({
            socketFactory: this.socketFactory,
            host: this.host,
            port: this.port,
            ssl: this.ssl,
            onConnect,
            onData,
            onEnd,
            onError,
            onTimeout
          });
        } catch (e) {
          clearTimeout(timeoutId);
          reject(new KafkaJSConnectionError(`Failed to connect: ${e.message}`, {
            broker: `${this.host}:${this.port}`
          }));
        }
      });
    }
    async disconnect() {
      this.authenticatedAt = null;
      this.connectionStatus = CONNECTION_STATUS.DISCONNECTING;
      this.logDebug("disconnecting...");
      await this.requestQueue.waitForPendingRequests();
      this.requestQueue.destroy();
      if (this.socket) {
        this.socket.end();
        this.socket.unref();
      }
      this.connectionStatus = CONNECTION_STATUS.DISCONNECTED;
      this.logDebug("disconnected");
      return true;
    }
    isAuthenticated() {
      return this.authenticatedAt != null && !this[PRIVATE.SHOULD_REAUTHENTICATE]();
    }
    [PRIVATE.SHOULD_REAUTHENTICATE]() {
      if (this.sessionLifetime.equals(Long.ZERO)) {
        return false;
      }
      if (this.authenticatedAt == null) {
        return true;
      }
      const [secondsSince, remainingNanosSince] = process.hrtime(this.authenticatedAt);
      const millisSince = Long.fromValue(secondsSince).multiply(1000).add(Long.fromValue(remainingNanosSince).divide(1e6));
      const reauthenticateAt = millisSince.add(this.reauthenticationThreshold);
      return reauthenticateAt.greaterThanOrEqual(this.sessionLifetime);
    }
    async authenticate() {
      await this[PRIVATE.AUTHENTICATE]();
    }
    sendAuthRequest({ request, response }) {
      this.authExpectResponse = !!response;
      return new Promise(async (resolve, reject) => {
        this.authHandlers = {
          onSuccess: (rawData) => {
            this.authHandlers = null;
            this.authExpectResponse = false;
            response.decode(rawData).then((data) => response.parse(data)).then(resolve).catch(reject);
          },
          onError: () => {
            this.authHandlers = null;
            this.authExpectResponse = false;
            reject(new KafkaJSConnectionError("Connection closed by the server", {
              broker: `${this.host}:${this.port}`
            }));
          }
        };
        try {
          const requestPayload = await request.encode();
          this.failIfNotConnected();
          this.socket.write(requestPayload, "binary");
        } catch (e) {
          reject(e);
        }
      });
    }
    async send({ request, response, requestTimeout = null, logResponseError = true }) {
      if (!this.isAuthenticated() && isAuthenticatedRequest(request)) {
        await this[PRIVATE.AUTHENTICATE]();
      }
      this.failIfNotConnected();
      const expectResponse = !request.expectResponse || request.expectResponse();
      const sendRequest = async () => {
        const { clientId } = this;
        const correlationId2 = this.nextCorrelationId();
        const requestPayload = await createRequest({ request, correlationId: correlationId2, clientId });
        const { apiKey, apiName, apiVersion } = request;
        this.logDebug(`Request ${requestInfo(request)}`, {
          correlationId: correlationId2,
          expectResponse,
          size: Buffer.byteLength(requestPayload.buffer)
        });
        return new Promise((resolve, reject) => {
          try {
            this.failIfNotConnected();
            const entry2 = { apiKey, apiName, apiVersion, correlationId: correlationId2, resolve, reject };
            this.requestQueue.push({
              entry: entry2,
              expectResponse,
              requestTimeout,
              sendRequest: () => {
                this.socket.write(requestPayload.buffer, "binary");
              }
            });
          } catch (e) {
            reject(e);
          }
        });
      };
      const { correlationId, size, entry, payload } = await sendRequest();
      if (!expectResponse) {
        return;
      }
      try {
        const payloadDecoded = await response.decode(payload);
        this.requestQueue.maybeThrottle(payloadDecoded.clientSideThrottleTime);
        const data = await response.parse(payloadDecoded);
        const isFetchApi = entry.apiName === "Fetch";
        this.logDebug(`Response ${requestInfo(entry)}`, {
          correlationId,
          size,
          data: isFetchApi && !this.shouldLogFetchBuffer ? "[filtered]" : data
        });
        return data;
      } catch (e) {
        if (logResponseError) {
          this.logError(`Response ${requestInfo(entry)}`, {
            error: e.message,
            correlationId,
            size
          });
        }
        const isBuffer = Buffer.isBuffer(payload);
        this.logDebug(`Response ${requestInfo(entry)}`, {
          error: e.message,
          correlationId,
          payload: isBuffer && !this.shouldLogBuffers ? { type: "Buffer", data: "[filtered]" } : payload
        });
        throw e;
      }
    }
    failIfNotConnected() {
      if (!this.isConnected()) {
        throw new KafkaJSConnectionError("Not connected", {
          broker: `${this.host}:${this.port}`
        });
      }
    }
    nextCorrelationId() {
      if (this.correlationId >= INT_32_MAX_VALUE) {
        this.correlationId = 0;
      }
      return this.correlationId++;
    }
    processData(rawData) {
      if (this.authHandlers && !this.authExpectResponse) {
        return this.authHandlers.onSuccess(rawData);
      }
      this.chunks.push(rawData);
      this.bytesBuffered += Buffer.byteLength(rawData);
      while (this.bytesNeeded <= this.bytesBuffered) {
        const buffer = this.chunks.length > 1 ? Buffer.concat(this.chunks) : this.chunks[0];
        const decoder = new Decoder(buffer);
        const expectedResponseSize = decoder.readInt32();
        if (!decoder.canReadBytes(expectedResponseSize)) {
          this.chunks = [buffer];
          this.bytesBuffered = Buffer.byteLength(buffer);
          this.bytesNeeded = Decoder.int32Size() + expectedResponseSize;
          return;
        }
        const response = new Decoder(decoder.readBytes(expectedResponseSize));
        const remainderBuffer = decoder.readAll();
        this.chunks = [remainderBuffer];
        this.bytesBuffered = Buffer.byteLength(remainderBuffer);
        this.bytesNeeded = Decoder.int32Size();
        if (this.authHandlers) {
          const rawResponseSize = Decoder.int32Size() + expectedResponseSize;
          const rawResponseBuffer = buffer.slice(0, rawResponseSize);
          return this.authHandlers.onSuccess(rawResponseBuffer);
        }
        const correlationId = response.readInt32();
        const payload = response.readAll();
        this.requestQueue.fulfillRequest({
          size: expectedResponseSize,
          correlationId,
          payload
        });
      }
    }
    rejectRequests(error40) {
      this.requestQueue.rejectAll(error40);
    }
  };
});

// node_modules/kafkajs/src/network/connectionPool.js
var require_connectionPool = __commonJS((exports, module) => {
  var apiKeys = require_apiKeys();
  var Connection = require_connection();
  module.exports = class ConnectionPool {
    constructor(options) {
      this.logger = options.logger.namespace("ConnectionPool");
      this.connectionTimeout = options.connectionTimeout;
      this.host = options.host;
      this.port = options.port;
      this.rack = options.rack;
      this.ssl = options.ssl;
      this.sasl = options.sasl;
      this.clientId = options.clientId;
      this.socketFactory = options.socketFactory;
      this.pool = new Array(2).fill().map(() => new Connection(options));
    }
    isConnected() {
      return this.pool.some((c) => c.isConnected());
    }
    isAuthenticated() {
      return this.pool.some((c) => c.isAuthenticated());
    }
    setSupportAuthenticationProtocol(isSupported) {
      this.map((c) => c.setSupportAuthenticationProtocol(isSupported));
    }
    setVersions(versions2) {
      this.map((c) => c.setVersions(versions2));
    }
    map(callback) {
      return this.pool.map((c) => callback(c));
    }
    async send(protocolRequest) {
      const connection = await this.getConnectionByRequest(protocolRequest);
      return connection.send(protocolRequest);
    }
    getConnectionByRequest({ request: { apiKey } }) {
      const index = { [apiKeys.Fetch]: 1 }[apiKey] || 0;
      return this.getConnection(index);
    }
    async getConnection(index = 0) {
      const connection = this.pool[index];
      if (!connection.isConnected()) {
        await connection.connect();
      }
      return connection;
    }
    async destroy() {
      await Promise.all(this.map((c) => c.disconnect()));
    }
  };
});

// node_modules/kafkajs/src/cluster/connectionPoolBuilder.js
var require_connectionPoolBuilder = __commonJS((exports, module) => {
  var { KafkaJSConnectionError, KafkaJSNonRetriableError } = require_errors();
  var ConnectionPool = require_connectionPool();
  module.exports = ({
    socketFactory,
    brokers,
    ssl,
    sasl,
    clientId,
    requestTimeout,
    enforceRequestTimeout,
    connectionTimeout,
    maxInFlightRequests,
    logger: logger2,
    instrumentationEmitter = null,
    reauthenticationThreshold
  }) => {
    let index = 0;
    const isValidBroker = (broker) => {
      return broker && typeof broker === "string" && broker.length > 0;
    };
    const validateBrokers = (brokers2) => {
      if (!brokers2) {
        throw new KafkaJSNonRetriableError(`Failed to connect: brokers should not be null`);
      }
      if (Array.isArray(brokers2)) {
        if (!brokers2.length) {
          throw new KafkaJSNonRetriableError(`Failed to connect: brokers array is empty`);
        }
        brokers2.forEach((broker, index2) => {
          if (!isValidBroker(broker)) {
            throw new KafkaJSNonRetriableError(`Failed to connect: broker at index ${index2} is invalid "${typeof broker}"`);
          }
        });
      }
    };
    const getBrokers = async () => {
      let list;
      if (typeof brokers === "function") {
        try {
          list = await brokers();
        } catch (e) {
          const wrappedError = new KafkaJSConnectionError(`Failed to connect: "config.brokers" threw: ${e.message}`);
          wrappedError.stack = `${wrappedError.name}
  Caused by: ${e.stack}`;
          throw wrappedError;
        }
      } else {
        list = brokers;
      }
      validateBrokers(list);
      return list;
    };
    return {
      build: async ({ host, port, rack } = {}) => {
        if (!host) {
          const list = await getBrokers();
          const randomBroker = list[index++ % list.length];
          host = randomBroker.split(":")[0];
          port = Number(randomBroker.split(":")[1]);
        }
        return new ConnectionPool({
          host,
          port,
          rack,
          sasl,
          ssl,
          clientId,
          socketFactory,
          connectionTimeout,
          requestTimeout,
          enforceRequestTimeout,
          maxInFlightRequests,
          instrumentationEmitter,
          logger: logger2,
          reauthenticationThreshold
        });
      }
    };
  };
});

// node_modules/kafkajs/src/cluster/index.js
var require_cluster = __commonJS((exports, module) => {
  var BrokerPool = require_brokerPool();
  var Lock = require_lock();
  var sharedPromiseTo = require_sharedPromiseTo();
  var createRetry = require_retry();
  var connectionPoolBuilder = require_connectionPoolBuilder();
  var { EARLIEST_OFFSET, LATEST_OFFSET } = require_constants();
  var {
    KafkaJSError,
    KafkaJSBrokerNotFound,
    KafkaJSMetadataNotLoaded,
    KafkaJSTopicMetadataNotLoaded,
    KafkaJSGroupCoordinatorNotFound
  } = require_errors();
  var COORDINATOR_TYPES = require_coordinatorTypes();
  var { keys } = Object;
  var mergeTopics = (obj, { topic, partitions }) => ({
    ...obj,
    [topic]: [...obj[topic] || [], ...partitions]
  });
  var PRIVATE = {
    CONNECT: Symbol("private:Cluster:connect"),
    REFRESH_METADATA: Symbol("private:Cluster:refreshMetadata"),
    REFRESH_METADATA_IF_NECESSARY: Symbol("private:Cluster:refreshMetadataIfNecessary"),
    FIND_CONTROLLER_BROKER: Symbol("private:Cluster:findControllerBroker")
  };
  module.exports = class Cluster {
    constructor({
      logger: rootLogger,
      socketFactory,
      brokers,
      ssl,
      sasl,
      clientId,
      connectionTimeout,
      authenticationTimeout,
      reauthenticationThreshold,
      requestTimeout = 30000,
      enforceRequestTimeout,
      metadataMaxAge,
      retry,
      allowAutoTopicCreation,
      maxInFlightRequests,
      isolationLevel,
      instrumentationEmitter = null,
      offsets = new Map
    }) {
      this.rootLogger = rootLogger;
      this.logger = rootLogger.namespace("Cluster");
      this.retrier = createRetry(retry);
      this.connectionPoolBuilder = connectionPoolBuilder({
        logger: rootLogger,
        instrumentationEmitter,
        socketFactory,
        brokers,
        ssl,
        sasl,
        clientId,
        connectionTimeout,
        requestTimeout,
        enforceRequestTimeout,
        maxInFlightRequests,
        reauthenticationThreshold
      });
      this.targetTopics = new Set;
      this.mutatingTargetTopics = new Lock({
        description: `updating target topics`,
        timeout: requestTimeout
      });
      this.isolationLevel = isolationLevel;
      this.brokerPool = new BrokerPool({
        connectionPoolBuilder: this.connectionPoolBuilder,
        logger: this.rootLogger,
        retry,
        allowAutoTopicCreation,
        authenticationTimeout,
        metadataMaxAge
      });
      this.committedOffsetsByGroup = offsets;
      this[PRIVATE.CONNECT] = sharedPromiseTo(async () => {
        return await this.brokerPool.connect();
      });
      this[PRIVATE.REFRESH_METADATA] = sharedPromiseTo(async () => {
        return await this.brokerPool.refreshMetadata(Array.from(this.targetTopics));
      });
      this[PRIVATE.REFRESH_METADATA_IF_NECESSARY] = sharedPromiseTo(async () => {
        return await this.brokerPool.refreshMetadataIfNecessary(Array.from(this.targetTopics));
      });
      this[PRIVATE.FIND_CONTROLLER_BROKER] = sharedPromiseTo(async () => {
        const { metadata } = this.brokerPool;
        if (!metadata || metadata.controllerId == null) {
          throw new KafkaJSMetadataNotLoaded("Topic metadata not loaded");
        }
        const broker = await this.findBroker({ nodeId: metadata.controllerId });
        if (!broker) {
          throw new KafkaJSBrokerNotFound(`Controller broker with id ${metadata.controllerId} not found in the cached metadata`);
        }
        return broker;
      });
    }
    isConnected() {
      return this.brokerPool.hasConnectedBrokers();
    }
    async connect() {
      await this[PRIVATE.CONNECT]();
    }
    async disconnect() {
      await this.brokerPool.disconnect();
    }
    removeBroker({ host, port }) {
      this.brokerPool.removeBroker({ host, port });
    }
    async refreshMetadata() {
      await this[PRIVATE.REFRESH_METADATA]();
    }
    async refreshMetadataIfNecessary() {
      await this[PRIVATE.REFRESH_METADATA_IF_NECESSARY]();
    }
    async metadata({ topics = [] } = {}) {
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          await this.brokerPool.refreshMetadataIfNecessary(topics);
          return this.brokerPool.withBroker(async ({ broker }) => broker.metadata(topics));
        } catch (e) {
          if (e.type === "LEADER_NOT_AVAILABLE") {
            throw e;
          }
          bail(e);
        }
      });
    }
    async addTargetTopic(topic) {
      return this.addMultipleTargetTopics([topic]);
    }
    async addMultipleTargetTopics(topics) {
      await this.mutatingTargetTopics.acquire();
      try {
        const previousSize = this.targetTopics.size;
        const previousTopics = new Set(this.targetTopics);
        for (const topic of topics) {
          this.targetTopics.add(topic);
        }
        const hasChanged = previousSize !== this.targetTopics.size || !this.brokerPool.metadata;
        if (hasChanged) {
          try {
            await this.refreshMetadata();
          } catch (e) {
            if (e.type === "INVALID_TOPIC_EXCEPTION" || e.type === "UNKNOWN_TOPIC_OR_PARTITION" || e.type === "TOPIC_AUTHORIZATION_FAILED") {
              this.targetTopics = previousTopics;
            }
            throw e;
          }
        }
      } finally {
        await this.mutatingTargetTopics.release();
      }
    }
    getNodeIds() {
      return this.brokerPool.getNodeIds();
    }
    async findBroker({ nodeId }) {
      try {
        return await this.brokerPool.findBroker({ nodeId });
      } catch (e) {
        if (e.name === "KafkaJSBrokerNotFound" || e.name === "KafkaJSLockTimeout" || e.name === "KafkaJSConnectionError") {
          await this.refreshMetadata();
        }
        throw e;
      }
    }
    async findControllerBroker() {
      return await this[PRIVATE.FIND_CONTROLLER_BROKER]();
    }
    findTopicPartitionMetadata(topic) {
      const { metadata } = this.brokerPool;
      if (!metadata || !metadata.topicMetadata) {
        throw new KafkaJSTopicMetadataNotLoaded("Topic metadata not loaded", { topic });
      }
      const topicMetadata = metadata.topicMetadata.find((t) => t.topic === topic);
      return topicMetadata ? topicMetadata.partitionMetadata : [];
    }
    findLeaderForPartitions(topic, partitions) {
      const partitionMetadata = this.findTopicPartitionMetadata(topic);
      return partitions.reduce((result, id) => {
        const partitionId = parseInt(id, 10);
        const metadata = partitionMetadata.find((p) => p.partitionId === partitionId);
        if (!metadata) {
          return result;
        }
        if (metadata.leader === null || metadata.leader === undefined) {
          throw new KafkaJSError("Invalid partition metadata", { topic, partitionId, metadata });
        }
        const { leader } = metadata;
        const current = result[leader] || [];
        return { ...result, [leader]: [...current, partitionId] };
      }, {});
    }
    async findGroupCoordinator({ groupId, coordinatorType = COORDINATOR_TYPES.GROUP }) {
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          const { coordinator } = await this.findGroupCoordinatorMetadata({
            groupId,
            coordinatorType
          });
          return await this.findBroker({ nodeId: coordinator.nodeId });
        } catch (e) {
          if (e.name === "KafkaJSBrokerNotFound" || e.type === "GROUP_COORDINATOR_NOT_AVAILABLE") {
            this.logger.debug(`${e.message}, refreshing metadata and trying again...`, {
              groupId,
              retryCount,
              retryTime
            });
            await this.refreshMetadata();
            throw e;
          }
          if (e.code === "ECONNREFUSED") {
            throw e;
          }
          bail(e);
        }
      });
    }
    async findGroupCoordinatorMetadata({ groupId, coordinatorType }) {
      const brokerMetadata = await this.brokerPool.withBroker(async ({ nodeId, broker }) => {
        return await this.retrier(async (bail, retryCount, retryTime) => {
          try {
            const brokerMetadata2 = await broker.findGroupCoordinator({ groupId, coordinatorType });
            this.logger.debug("Found group coordinator", {
              broker: brokerMetadata2.host,
              nodeId: brokerMetadata2.coordinator.nodeId
            });
            return brokerMetadata2;
          } catch (e) {
            this.logger.debug("Tried to find group coordinator", {
              nodeId,
              groupId,
              error: e
            });
            if (e.type === "GROUP_COORDINATOR_NOT_AVAILABLE") {
              this.logger.debug("Group coordinator not available, retrying...", {
                nodeId,
                retryCount,
                retryTime
              });
              throw e;
            }
            bail(e);
          }
        });
      });
      if (brokerMetadata) {
        return brokerMetadata;
      }
      throw new KafkaJSGroupCoordinatorNotFound("Failed to find group coordinator");
    }
    defaultOffset({ fromBeginning }) {
      return fromBeginning ? EARLIEST_OFFSET : LATEST_OFFSET;
    }
    async fetchTopicsOffset(topics) {
      const partitionsPerBroker = {};
      const topicConfigurations = {};
      const addDefaultOffset = (topic) => (partition) => {
        const { timestamp } = topicConfigurations[topic];
        return { ...partition, timestamp };
      };
      for (const topicData of topics) {
        const { topic, partitions, fromBeginning, fromTimestamp } = topicData;
        const partitionsPerLeader = this.findLeaderForPartitions(topic, partitions.map((p) => p.partition));
        const timestamp = fromTimestamp != null ? fromTimestamp : this.defaultOffset({ fromBeginning });
        topicConfigurations[topic] = { timestamp };
        keys(partitionsPerLeader).forEach((nodeId) => {
          partitionsPerBroker[nodeId] = partitionsPerBroker[nodeId] || {};
          partitionsPerBroker[nodeId][topic] = partitions.filter((p) => partitionsPerLeader[nodeId].includes(p.partition));
        });
      }
      const requests = keys(partitionsPerBroker).map(async (nodeId) => {
        const broker = await this.findBroker({ nodeId });
        const partitions = partitionsPerBroker[nodeId];
        const { responses: topicOffsets } = await broker.listOffsets({
          isolationLevel: this.isolationLevel,
          topics: keys(partitions).map((topic) => ({
            topic,
            partitions: partitions[topic].map(addDefaultOffset(topic))
          }))
        });
        return topicOffsets;
      });
      const responses = await Promise.all(requests);
      const partitionsPerTopic = responses.flat().reduce(mergeTopics, {});
      return keys(partitionsPerTopic).map((topic) => ({
        topic,
        partitions: partitionsPerTopic[topic].map(({ partition, offset }) => ({
          partition,
          offset
        }))
      }));
    }
    committedOffsets({ groupId }) {
      if (!this.committedOffsetsByGroup.has(groupId)) {
        this.committedOffsetsByGroup.set(groupId, {});
      }
      return this.committedOffsetsByGroup.get(groupId);
    }
    markOffsetAsCommitted({ groupId, topic, partition, offset }) {
      const committedOffsets = this.committedOffsets({ groupId });
      committedOffsets[topic] = committedOffsets[topic] || {};
      committedOffsets[topic][partition] = offset;
    }
  };
});

// node_modules/kafkajs/src/producer/partitioners/default/murmur2.js
var require_murmur2 = __commonJS((exports, module) => {
  var Long = require_long();
  var SEED = Long.fromValue(2538058380);
  var M = Long.fromValue(1540483477);
  var R = Long.fromValue(24);
  module.exports = (key) => {
    const data = Buffer.isBuffer(key) ? key : Buffer.from(String(key));
    const length = data.length;
    let h = Long.fromValue(SEED.xor(length));
    let length4 = Math.floor(length / 4);
    for (let i = 0;i < length4; i++) {
      const i4 = i * 4;
      let k = (data[i4 + 0] & 255) + ((data[i4 + 1] & 255) << 8) + ((data[i4 + 2] & 255) << 16) + ((data[i4 + 3] & 255) << 24);
      k = Long.fromValue(k);
      k = k.multiply(M);
      k = k.xor(k.toInt() >>> R);
      k = Long.fromValue(k).multiply(M);
      h = h.multiply(M);
      h = h.xor(k);
    }
    switch (length % 4) {
      case 3:
        h = h.xor((data[(length & ~3) + 2] & 255) << 16);
      case 2:
        h = h.xor((data[(length & ~3) + 1] & 255) << 8);
      case 1:
        h = h.xor(data[length & ~3] & 255);
        h = h.multiply(M);
    }
    h = h.xor(h.toInt() >>> 13);
    h = h.multiply(M);
    h = h.xor(h.toInt() >>> 15);
    return h.toInt();
  };
});

// node_modules/kafkajs/src/producer/partitioners/legacy/randomBytes.js
var require_randomBytes = __commonJS((exports, module) => {
  var { KafkaJSNonRetriableError } = require_errors();
  var toNodeCompatible = (crypto2) => ({
    randomBytes: (size) => crypto2.getRandomValues(Buffer.allocUnsafe(size))
  });
  var cryptoImplementation = null;
  if (global && global.crypto) {
    cryptoImplementation = global.crypto.randomBytes === undefined ? toNodeCompatible(global.crypto) : global.crypto;
  } else if (global && global.msCrypto) {
    cryptoImplementation = toNodeCompatible(global.msCrypto);
  } else if (global && !global.crypto) {
    cryptoImplementation = __require("crypto");
  }
  var MAX_BYTES = 65536;
  module.exports = (size) => {
    if (size > MAX_BYTES) {
      throw new KafkaJSNonRetriableError(`Byte length (${size}) exceeds the max number of bytes of entropy available (${MAX_BYTES})`);
    }
    if (!cryptoImplementation) {
      throw new KafkaJSNonRetriableError("No available crypto implementation");
    }
    return cryptoImplementation.randomBytes(size);
  };
});

// node_modules/kafkajs/src/producer/partitioners/legacy/partitioner.js
var require_partitioner = __commonJS((exports, module) => {
  var randomBytes = require_randomBytes();
  var toPositive = (x) => x & 2147483647;
  module.exports = (murmur2) => () => {
    const counters = {};
    return ({ topic, partitionMetadata, message }) => {
      if (!(topic in counters)) {
        counters[topic] = randomBytes(32).readUInt32BE(0);
      }
      const numPartitions = partitionMetadata.length;
      const availablePartitions = partitionMetadata.filter((p) => p.leader >= 0);
      const numAvailablePartitions = availablePartitions.length;
      if (message.partition !== null && message.partition !== undefined) {
        return message.partition;
      }
      if (message.key !== null && message.key !== undefined) {
        return toPositive(murmur2(message.key)) % numPartitions;
      }
      if (numAvailablePartitions > 0) {
        const i = toPositive(++counters[topic]) % numAvailablePartitions;
        return availablePartitions[i].partitionId;
      }
      return toPositive(++counters[topic]) % numPartitions;
    };
  };
});

// node_modules/kafkajs/src/producer/partitioners/default/index.js
var require_default = __commonJS((exports, module) => {
  var murmur2 = require_murmur2();
  var createDefaultPartitioner = require_partitioner();
  module.exports = createDefaultPartitioner(murmur2);
});

// node_modules/kafkajs/src/producer/partitioners/legacy/murmur2.js
var require_murmur22 = __commonJS((exports, module) => {
  var SEED = 2538058380;
  var M = 1540483477;
  var R = 24;
  module.exports = (key) => {
    const data = Buffer.isBuffer(key) ? key : Buffer.from(String(key));
    const length = data.length;
    let h = SEED ^ length;
    let length4 = length / 4;
    for (let i = 0;i < length4; i++) {
      const i4 = i * 4;
      let k = (data[i4 + 0] & 255) + ((data[i4 + 1] & 255) << 8) + ((data[i4 + 2] & 255) << 16) + ((data[i4 + 3] & 255) << 24);
      k *= M;
      k ^= k >>> R;
      k *= M;
      h *= M;
      h ^= k;
    }
    switch (length % 4) {
      case 3:
        h ^= (data[(length & ~3) + 2] & 255) << 16;
      case 2:
        h ^= (data[(length & ~3) + 1] & 255) << 8;
      case 1:
        h ^= data[length & ~3] & 255;
        h *= M;
    }
    h ^= h >>> 13;
    h *= M;
    h ^= h >>> 15;
    return h;
  };
});

// node_modules/kafkajs/src/producer/partitioners/legacy/index.js
var require_legacy = __commonJS((exports, module) => {
  var murmur2 = require_murmur22();
  var createLegacyPartitioner = require_partitioner();
  module.exports = createLegacyPartitioner(murmur2);
});

// node_modules/kafkajs/src/producer/partitioners/index.js
var require_partitioners = __commonJS((exports, module) => {
  var DefaultPartitioner = require_default();
  var LegacyPartitioner = require_legacy();
  module.exports = {
    DefaultPartitioner,
    LegacyPartitioner,
    JavaCompatiblePartitioner: DefaultPartitioner
  };
});

// node_modules/kafkajs/src/producer/eosManager/transactionStates.js
var require_transactionStates = __commonJS((exports, module) => {
  module.exports = {
    UNINITIALIZED: "UNINITIALIZED",
    READY: "READY",
    TRANSACTING: "TRANSACTING",
    COMMITTING: "COMMITTING",
    ABORTING: "ABORTING"
  };
});

// node_modules/kafkajs/src/producer/eosManager/transactionStateMachine.js
var require_transactionStateMachine = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var { KafkaJSNonRetriableError } = require_errors();
  var STATES = require_transactionStates();
  var VALID_STATE_TRANSITIONS = {
    [STATES.UNINITIALIZED]: [STATES.READY],
    [STATES.READY]: [STATES.READY, STATES.TRANSACTING],
    [STATES.TRANSACTING]: [STATES.COMMITTING, STATES.ABORTING],
    [STATES.COMMITTING]: [STATES.READY],
    [STATES.ABORTING]: [STATES.READY]
  };
  module.exports = ({ logger: logger2, initialState = STATES.UNINITIALIZED }) => {
    let currentState = initialState;
    const guard = (object2, method, { legalStates, async: isAsync = true }) => {
      if (!object2[method]) {
        throw new KafkaJSNonRetriableError(`Cannot add guard on missing method "${method}"`);
      }
      return (...args) => {
        const fn = object2[method];
        if (!legalStates.includes(currentState)) {
          const error40 = new KafkaJSNonRetriableError(`Transaction state exception: Cannot call "${method}" in state "${currentState}"`);
          if (isAsync) {
            return Promise.reject(error40);
          } else {
            throw error40;
          }
        }
        return fn.apply(object2, args);
      };
    };
    const stateMachine = Object.assign(new EventEmitter, {
      createGuarded(object2, methodStateMapping) {
        const guardedMethods = Object.keys(methodStateMapping).reduce((guards, method) => {
          guards[method] = guard(object2, method, methodStateMapping[method]);
          return guards;
        }, {});
        return { ...object2, ...guardedMethods };
      },
      transitionTo(state) {
        logger2.debug(`Transaction state transition ${currentState} --> ${state}`);
        if (!VALID_STATE_TRANSITIONS[currentState].includes(state)) {
          throw new KafkaJSNonRetriableError(`Transaction state exception: Invalid transition ${currentState} --> ${state}`);
        }
        stateMachine.emit("transition", { to: state, from: currentState });
        currentState = state;
      },
      state() {
        return currentState;
      }
    });
    return stateMachine;
  };
});

// node_modules/kafkajs/src/producer/eosManager/index.js
var require_eosManager = __commonJS((exports, module) => {
  var createRetry = require_retry();
  var Lock = require_lock();
  var { KafkaJSNonRetriableError } = require_errors();
  var COORDINATOR_TYPES = require_coordinatorTypes();
  var createStateMachine = require_transactionStateMachine();
  var { INT_32_MAX_VALUE } = require_constants();
  var assert2 = __require("assert");
  var STATES = require_transactionStates();
  var NO_PRODUCER_ID = -1;
  var SEQUENCE_START = 0;
  var INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS = [
    "NOT_COORDINATOR_FOR_GROUP",
    "GROUP_COORDINATOR_NOT_AVAILABLE",
    "GROUP_LOAD_IN_PROGRESS",
    "CONCURRENT_TRANSACTIONS"
  ];
  var COMMIT_RETRIABLE_PROTOCOL_ERRORS = [
    "UNKNOWN_TOPIC_OR_PARTITION",
    "COORDINATOR_LOAD_IN_PROGRESS"
  ];
  var COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS = ["COORDINATOR_NOT_AVAILABLE", "NOT_COORDINATOR"];
  module.exports = ({
    logger: logger2,
    cluster,
    transactionTimeout = 60000,
    transactional,
    transactionalId
  }) => {
    if (transactional && !transactionalId) {
      throw new KafkaJSNonRetriableError("Cannot manage transactions without a transactionalId");
    }
    const retrier = createRetry(cluster.retry);
    let producerId = NO_PRODUCER_ID;
    let producerEpoch = 0;
    let producerSequence = {};
    let brokerMutexLocks = {};
    let transactionTopicPartitions = {};
    let hasOffsetsAddedToTransaction = false;
    const stateMachine = createStateMachine({ logger: logger2 });
    stateMachine.on("transition", ({ to }) => {
      if (to === STATES.READY) {
        transactionTopicPartitions = {};
        hasOffsetsAddedToTransaction = false;
      }
    });
    const findTransactionCoordinator = () => {
      return cluster.findGroupCoordinator({
        groupId: transactionalId,
        coordinatorType: COORDINATOR_TYPES.TRANSACTION
      });
    };
    const transactionalGuard = () => {
      if (!transactional) {
        throw new KafkaJSNonRetriableError("Method unavailable if non-transactional");
      }
    };
    const isOngoing = () => {
      return hasOffsetsAddedToTransaction || Object.entries(transactionTopicPartitions).some(([, partitions]) => {
        return Object.entries(partitions).some(([, isPartitionAddedToTransaction]) => isPartitionAddedToTransaction);
      });
    };
    const eosManager = stateMachine.createGuarded({
      getProducerId() {
        return producerId;
      },
      getProducerEpoch() {
        return producerEpoch;
      },
      getTransactionalId() {
        return transactionalId;
      },
      async initProducerId() {
        return retrier(async (bail, retryCount, retryTime) => {
          try {
            await cluster.refreshMetadataIfNecessary();
            const broker = await (transactional ? findTransactionCoordinator() : cluster.findControllerBroker());
            const result = await broker.initProducerId({
              transactionalId: transactional ? transactionalId : undefined,
              transactionTimeout
            });
            stateMachine.transitionTo(STATES.READY);
            producerId = result.producerId;
            producerEpoch = result.producerEpoch;
            producerSequence = {};
            brokerMutexLocks = {};
            logger2.debug("Initialized producer id & epoch", { producerId, producerEpoch });
          } catch (e) {
            if (INIT_PRODUCER_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {
              if (e.type === "CONCURRENT_TRANSACTIONS") {
                logger2.debug("There is an ongoing transaction on this transactionId, retrying", {
                  error: e.message,
                  stack: e.stack,
                  transactionalId,
                  retryCount,
                  retryTime
                });
              }
              throw e;
            }
            bail(e);
          }
        });
      },
      getSequence(topic, partition) {
        if (!eosManager.isInitialized()) {
          return SEQUENCE_START;
        }
        producerSequence[topic] = producerSequence[topic] || {};
        producerSequence[topic][partition] = producerSequence[topic][partition] || SEQUENCE_START;
        return producerSequence[topic][partition];
      },
      updateSequence(topic, partition, increment) {
        if (!eosManager.isInitialized()) {
          return;
        }
        const previous = eosManager.getSequence(topic, partition);
        let sequence = previous + increment;
        if (sequence >= INT_32_MAX_VALUE) {
          logger2.debug(`Sequence for ${topic} ${partition} exceeds max value (${sequence}). Rotating to 0.`);
          sequence = 0;
        }
        producerSequence[topic][partition] = sequence;
      },
      beginTransaction() {
        transactionalGuard();
        stateMachine.transitionTo(STATES.TRANSACTING);
      },
      async addPartitionsToTransaction(topicData) {
        transactionalGuard();
        const newTopicPartitions = {};
        topicData.forEach(({ topic, partitions }) => {
          transactionTopicPartitions[topic] = transactionTopicPartitions[topic] || {};
          partitions.forEach(({ partition }) => {
            if (!transactionTopicPartitions[topic][partition]) {
              newTopicPartitions[topic] = newTopicPartitions[topic] || [];
              newTopicPartitions[topic].push(partition);
            }
          });
        });
        const topics = Object.keys(newTopicPartitions).map((topic) => ({
          topic,
          partitions: newTopicPartitions[topic]
        }));
        if (topics.length) {
          const broker = await findTransactionCoordinator();
          await broker.addPartitionsToTxn({ transactionalId, producerId, producerEpoch, topics });
        }
        topics.forEach(({ topic, partitions }) => {
          partitions.forEach((partition) => {
            transactionTopicPartitions[topic][partition] = true;
          });
        });
      },
      async commit() {
        transactionalGuard();
        stateMachine.transitionTo(STATES.COMMITTING);
        if (!isOngoing()) {
          logger2.debug("No partitions or offsets registered, not sending EndTxn");
          stateMachine.transitionTo(STATES.READY);
          return;
        }
        const broker = await findTransactionCoordinator();
        await broker.endTxn({
          producerId,
          producerEpoch,
          transactionalId,
          transactionResult: true
        });
        stateMachine.transitionTo(STATES.READY);
      },
      async abort() {
        transactionalGuard();
        stateMachine.transitionTo(STATES.ABORTING);
        if (!isOngoing()) {
          logger2.debug("No partitions or offsets registered, not sending EndTxn");
          stateMachine.transitionTo(STATES.READY);
          return;
        }
        const broker = await findTransactionCoordinator();
        await broker.endTxn({
          producerId,
          producerEpoch,
          transactionalId,
          transactionResult: false
        });
        stateMachine.transitionTo(STATES.READY);
      },
      isInitialized() {
        return producerId !== NO_PRODUCER_ID;
      },
      isTransactional() {
        return transactional;
      },
      isInTransaction() {
        return stateMachine.state() === STATES.TRANSACTING;
      },
      async acquireBrokerLock(broker) {
        if (this.isInitialized()) {
          brokerMutexLocks[broker.nodeId] = brokerMutexLocks[broker.nodeId] || new Lock({ timeout: 65535 });
          await brokerMutexLocks[broker.nodeId].acquire();
        }
      },
      releaseBrokerLock(broker) {
        if (this.isInitialized())
          brokerMutexLocks[broker.nodeId].release();
      },
      async sendOffsets({ consumerGroupId, topics }) {
        assert2(consumerGroupId, "Missing consumerGroupId");
        assert2(topics, "Missing offset topics");
        const transactionCoordinator = await findTransactionCoordinator();
        await transactionCoordinator.addOffsetsToTxn({
          transactionalId,
          producerId,
          producerEpoch,
          groupId: consumerGroupId
        });
        hasOffsetsAddedToTransaction = true;
        let groupCoordinator = await cluster.findGroupCoordinator({
          groupId: consumerGroupId,
          coordinatorType: COORDINATOR_TYPES.GROUP
        });
        return retrier(async (bail, retryCount, retryTime) => {
          try {
            await groupCoordinator.txnOffsetCommit({
              transactionalId,
              producerId,
              producerEpoch,
              groupId: consumerGroupId,
              topics
            });
          } catch (e) {
            if (COMMIT_RETRIABLE_PROTOCOL_ERRORS.includes(e.type)) {
              logger2.debug("Group coordinator is not ready yet, retrying", {
                error: e.message,
                stack: e.stack,
                transactionalId,
                retryCount,
                retryTime
              });
              throw e;
            }
            if (COMMIT_STALE_COORDINATOR_PROTOCOL_ERRORS.includes(e.type) || e.code === "ECONNREFUSED") {
              logger2.debug("Invalid group coordinator, finding new group coordinator and retrying", {
                error: e.message,
                stack: e.stack,
                transactionalId,
                retryCount,
                retryTime
              });
              groupCoordinator = await cluster.findGroupCoordinator({
                groupId: consumerGroupId,
                coordinatorType: COORDINATOR_TYPES.GROUP
              });
              throw e;
            }
            bail(e);
          }
        });
      }
    }, {
      initProducerId: { legalStates: [STATES.UNINITIALIZED, STATES.READY] },
      beginTransaction: { legalStates: [STATES.READY], async: false },
      addPartitionsToTransaction: { legalStates: [STATES.TRANSACTING] },
      sendOffsets: { legalStates: [STATES.TRANSACTING] },
      commit: { legalStates: [STATES.TRANSACTING] },
      abort: { legalStates: [STATES.TRANSACTING] }
    });
    return eosManager;
  };
});

// node_modules/kafkajs/src/producer/groupMessagesPerPartition.js
var require_groupMessagesPerPartition = __commonJS((exports, module) => {
  module.exports = ({ topic, partitionMetadata, messages, partitioner }) => {
    if (partitionMetadata.length === 0) {
      return {};
    }
    return messages.reduce((result, message) => {
      const partition = partitioner({ topic, partitionMetadata, message });
      const current = result[partition] || [];
      return Object.assign(result, { [partition]: [...current, message] });
    }, {});
  };
});

// node_modules/kafkajs/src/producer/createTopicData.js
var require_createTopicData = __commonJS((exports, module) => {
  module.exports = (topicDataForBroker) => {
    return topicDataForBroker.map(({ topic, partitions, messagesPerPartition, sequencePerPartition }) => ({
      topic,
      partitions: partitions.map((partition) => ({
        partition,
        messages: messagesPerPartition[partition]
      }))
    }));
  };
});

// node_modules/kafkajs/src/producer/responseSerializer.js
var require_responseSerializer = __commonJS((exports, module) => {
  module.exports = ({ topics }) => topics.flatMap(({ topicName, partitions }) => partitions.map((partition) => ({ topicName, ...partition })));
});

// node_modules/kafkajs/src/producer/sendMessages.js
var require_sendMessages = __commonJS((exports, module) => {
  var { KafkaJSMetadataNotLoaded } = require_errors();
  var { staleMetadata } = require_error();
  var groupMessagesPerPartition = require_groupMessagesPerPartition();
  var createTopicData = require_createTopicData();
  var responseSerializer = require_responseSerializer();
  var { keys } = Object;
  module.exports = ({ logger: logger2, cluster, partitioner, eosManager, retrier }) => {
    return async ({ acks, timeout, compression, topicMessages }) => {
      const responsePerBroker = new Map;
      const createProducerRequests = async (responsePerBroker2) => {
        const topicMetadata = new Map;
        await cluster.refreshMetadataIfNecessary();
        for (const { topic, messages } of topicMessages) {
          const partitionMetadata = cluster.findTopicPartitionMetadata(topic);
          if (partitionMetadata.length === 0) {
            logger2.debug("Producing to topic without metadata", {
              topic,
              targetTopics: Array.from(cluster.targetTopics)
            });
            throw new KafkaJSMetadataNotLoaded("Producing to topic without metadata");
          }
          const messagesPerPartition = groupMessagesPerPartition({
            topic,
            partitionMetadata,
            messages,
            partitioner
          });
          const partitions = keys(messagesPerPartition);
          const partitionsPerLeader = cluster.findLeaderForPartitions(topic, partitions);
          const leaders = keys(partitionsPerLeader);
          topicMetadata.set(topic, {
            partitionsPerLeader,
            messagesPerPartition
          });
          for (const nodeId of leaders) {
            const broker = await cluster.findBroker({ nodeId });
            if (!responsePerBroker2.has(broker)) {
              responsePerBroker2.set(broker, null);
            }
          }
        }
        const brokers = Array.from(responsePerBroker2.keys());
        const brokersWithoutResponse = brokers.filter((broker) => !responsePerBroker2.get(broker));
        return brokersWithoutResponse.map(async (broker) => {
          const entries = Array.from(topicMetadata.entries());
          const topicDataForBroker = entries.filter(([_, { partitionsPerLeader }]) => !!partitionsPerLeader[broker.nodeId]).map(([topic, { partitionsPerLeader, messagesPerPartition, sequencePerPartition }]) => ({
            topic,
            partitions: partitionsPerLeader[broker.nodeId],
            messagesPerPartition
          }));
          const topicData = createTopicData(topicDataForBroker);
          await eosManager.acquireBrokerLock(broker);
          try {
            if (eosManager.isTransactional()) {
              await eosManager.addPartitionsToTransaction(topicData);
            }
            topicData.forEach(({ topic, partitions }) => {
              partitions.forEach((entry) => {
                entry["firstSequence"] = eosManager.getSequence(topic, entry.partition);
                eosManager.updateSequence(topic, entry.partition, entry.messages.length);
              });
            });
            let response;
            try {
              response = await broker.produce({
                transactionalId: eosManager.isTransactional() ? eosManager.getTransactionalId() : undefined,
                producerId: eosManager.getProducerId(),
                producerEpoch: eosManager.getProducerEpoch(),
                acks,
                timeout,
                compression,
                topicData
              });
            } catch (e) {
              topicData.forEach(({ topic, partitions }) => {
                partitions.forEach((entry) => {
                  eosManager.updateSequence(topic, entry.partition, -entry.messages.length);
                });
              });
              throw e;
            }
            const expectResponse = acks !== 0;
            const formattedResponse = expectResponse ? responseSerializer(response) : [];
            responsePerBroker2.set(broker, formattedResponse);
          } catch (e) {
            responsePerBroker2.delete(broker);
            throw e;
          } finally {
            await eosManager.releaseBrokerLock(broker);
          }
        });
      };
      return retrier(async (bail, retryCount, retryTime) => {
        const topics = topicMessages.map(({ topic }) => topic);
        await cluster.addMultipleTargetTopics(topics);
        try {
          const requests = await createProducerRequests(responsePerBroker);
          await Promise.all(requests);
          return Array.from(responsePerBroker.values()).flat();
        } catch (e) {
          if (e.name === "KafkaJSConnectionClosedError") {
            cluster.removeBroker({ host: e.host, port: e.port });
          }
          if (!cluster.isConnected()) {
            logger2.debug(`Cluster has disconnected, reconnecting: ${e.message}`, {
              retryCount,
              retryTime
            });
            await cluster.connect();
            await cluster.refreshMetadata();
            throw e;
          }
          if (staleMetadata(e) || e.name === "KafkaJSMetadataNotLoaded" || e.name === "KafkaJSConnectionError" || e.name === "KafkaJSConnectionClosedError" || e.name === "KafkaJSProtocolError" && e.retriable) {
            logger2.error(`Failed to send messages: ${e.message}`, { retryCount, retryTime });
            await cluster.refreshMetadata();
            throw e;
          }
          logger2.error(`${e.message}`, { retryCount, retryTime });
          if (e.retriable)
            throw e;
          bail(e);
        }
      });
    };
  };
});

// node_modules/kafkajs/src/producer/messageProducer.js
var require_messageProducer = __commonJS((exports, module) => {
  var createSendMessages = require_sendMessages();
  var { KafkaJSError, KafkaJSNonRetriableError } = require_errors();
  var { CONNECTION_STATUS } = require_connectionStatus();
  module.exports = ({
    logger: logger2,
    cluster,
    partitioner,
    eosManager,
    idempotent,
    retrier,
    getConnectionStatus
  }) => {
    const sendMessages = createSendMessages({
      logger: logger2,
      cluster,
      retrier,
      partitioner,
      eosManager
    });
    const validateConnectionStatus = () => {
      const connectionStatus = getConnectionStatus();
      switch (connectionStatus) {
        case CONNECTION_STATUS.DISCONNECTING:
          throw new KafkaJSNonRetriableError(`The producer is disconnecting; therefore, it can't safely accept messages anymore`);
        case CONNECTION_STATUS.DISCONNECTED:
          throw new KafkaJSError("The producer is disconnected");
      }
    };
    const sendBatch = async ({ acks = -1, timeout, compression, topicMessages = [] }) => {
      if (topicMessages.some(({ topic }) => !topic)) {
        throw new KafkaJSNonRetriableError(`Invalid topic`);
      }
      if (idempotent && acks !== -1) {
        throw new KafkaJSNonRetriableError(`Not requiring ack for all messages invalidates the idempotent producer's EoS guarantees`);
      }
      for (const { topic, messages } of topicMessages) {
        if (!messages) {
          throw new KafkaJSNonRetriableError(`Invalid messages array [${messages}] for topic "${topic}"`);
        }
        const messageWithoutValue = messages.find((message) => message.value === undefined);
        if (messageWithoutValue) {
          throw new KafkaJSNonRetriableError(`Invalid message without value for topic "${topic}": ${JSON.stringify(messageWithoutValue)}`);
        }
      }
      validateConnectionStatus();
      const mergedTopicMessages = topicMessages.reduce((merged, { topic, messages }) => {
        const index = merged.findIndex(({ topic: mergedTopic }) => topic === mergedTopic);
        if (index === -1) {
          merged.push({ topic, messages });
        } else {
          merged[index].messages = [...merged[index].messages, ...messages];
        }
        return merged;
      }, []);
      return await sendMessages({
        acks,
        timeout,
        compression,
        topicMessages: mergedTopicMessages
      });
    };
    const send = async ({ acks, timeout, compression, topic, messages }) => {
      const topicMessage = { topic, messages };
      return sendBatch({
        acks,
        timeout,
        compression,
        topicMessages: [topicMessage]
      });
    };
    return {
      send,
      sendBatch
    };
  };
});

// node_modules/kafkajs/src/utils/swapObject.js
var require_swapObject = __commonJS((exports, module) => {
  var { keys } = Object;
  module.exports = (object2) => keys(object2).reduce((result, key) => ({ ...result, [object2[key]]: key }), {});
});

// node_modules/kafkajs/src/producer/instrumentationEvents.js
var require_instrumentationEvents2 = __commonJS((exports, module) => {
  var swapObject = require_swapObject();
  var networkEvents = require_instrumentationEvents();
  var InstrumentationEventType = require_eventType();
  var producerType = InstrumentationEventType("producer");
  var events = {
    CONNECT: producerType("connect"),
    DISCONNECT: producerType("disconnect"),
    REQUEST: producerType(networkEvents.NETWORK_REQUEST),
    REQUEST_TIMEOUT: producerType(networkEvents.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: producerType(networkEvents.NETWORK_REQUEST_QUEUE_SIZE)
  };
  var wrappedEvents = {
    [events.REQUEST]: networkEvents.NETWORK_REQUEST,
    [events.REQUEST_TIMEOUT]: networkEvents.NETWORK_REQUEST_TIMEOUT,
    [events.REQUEST_QUEUE_SIZE]: networkEvents.NETWORK_REQUEST_QUEUE_SIZE
  };
  var reversedWrappedEvents = swapObject(wrappedEvents);
  var unwrap = (eventName) => wrappedEvents[eventName] || eventName;
  var wrap = (eventName) => reversedWrappedEvents[eventName] || eventName;
  module.exports = {
    events,
    wrap,
    unwrap
  };
});

// node_modules/kafkajs/src/producer/index.js
var require_producer = __commonJS((exports, module) => {
  var createRetry = require_retry();
  var { CONNECTION_STATUS } = require_connectionStatus();
  var { DefaultPartitioner } = require_partitioners();
  var InstrumentationEventEmitter = require_emitter();
  var createEosManager = require_eosManager();
  var createMessageProducer = require_messageProducer();
  var { events, wrap: wrapEvent, unwrap: unwrapEvent } = require_instrumentationEvents2();
  var { KafkaJSNonRetriableError } = require_errors();
  var { values, keys } = Object;
  var eventNames = values(events);
  var eventKeys = keys(events).map((key) => `producer.events.${key}`).join(", ");
  var { CONNECT, DISCONNECT } = events;
  module.exports = ({
    cluster,
    logger: rootLogger,
    createPartitioner = DefaultPartitioner,
    retry,
    idempotent = false,
    transactionalId,
    transactionTimeout,
    instrumentationEmitter: rootInstrumentationEmitter
  }) => {
    let connectionStatus = CONNECTION_STATUS.DISCONNECTED;
    retry = retry || { retries: idempotent ? Number.MAX_SAFE_INTEGER : 5 };
    if (idempotent && retry.retries < 1) {
      throw new KafkaJSNonRetriableError("Idempotent producer must allow retries to protect against transient errors");
    }
    const logger2 = rootLogger.namespace("Producer");
    if (idempotent && retry.retries < Number.MAX_SAFE_INTEGER) {
      logger2.warn("Limiting retries for the idempotent producer may invalidate EoS guarantees");
    }
    const partitioner = createPartitioner();
    const retrier = createRetry(Object.assign({}, cluster.retry, retry));
    const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter;
    const idempotentEosManager = createEosManager({
      logger: logger2,
      cluster,
      transactionTimeout,
      transactional: false,
      transactionalId
    });
    const { send, sendBatch } = createMessageProducer({
      logger: logger2,
      cluster,
      partitioner,
      eosManager: idempotentEosManager,
      idempotent,
      retrier,
      getConnectionStatus: () => connectionStatus
    });
    let transactionalEosManager;
    const on = (eventName, listener) => {
      if (!eventNames.includes(eventName)) {
        throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`);
      }
      return instrumentationEmitter.addListener(unwrapEvent(eventName), (event) => {
        event.type = wrapEvent(event.type);
        Promise.resolve(listener(event)).catch((e) => {
          logger2.error(`Failed to execute listener: ${e.message}`, {
            eventName,
            stack: e.stack
          });
        });
      });
    };
    const transaction = async () => {
      if (!transactionalId) {
        throw new KafkaJSNonRetriableError("Must provide transactional id for transactional producer");
      }
      let transactionDidEnd = false;
      transactionalEosManager = transactionalEosManager || createEosManager({
        logger: logger2,
        cluster,
        transactionTimeout,
        transactional: true,
        transactionalId
      });
      if (transactionalEosManager.isInTransaction()) {
        throw new KafkaJSNonRetriableError("There is already an ongoing transaction for this producer. Please end the transaction before beginning another.");
      }
      if (!transactionalEosManager.isInitialized()) {
        await transactionalEosManager.initProducerId();
      }
      transactionalEosManager.beginTransaction();
      const { send: sendTxn, sendBatch: sendBatchTxn } = createMessageProducer({
        logger: logger2,
        cluster,
        partitioner,
        retrier,
        eosManager: transactionalEosManager,
        idempotent: true,
        getConnectionStatus: () => connectionStatus
      });
      const isActive = () => transactionalEosManager.isInTransaction() && !transactionDidEnd;
      const transactionGuard = (fn) => (...args) => {
        if (!isActive()) {
          return Promise.reject(new KafkaJSNonRetriableError("Cannot continue to use transaction once ended"));
        }
        return fn(...args);
      };
      return {
        sendBatch: transactionGuard(sendBatchTxn),
        send: transactionGuard(sendTxn),
        abort: transactionGuard(async () => {
          await transactionalEosManager.abort();
          transactionDidEnd = true;
        }),
        commit: transactionGuard(async () => {
          await transactionalEosManager.commit();
          transactionDidEnd = true;
        }),
        sendOffsets: transactionGuard(async ({ consumerGroupId, topics }) => {
          await transactionalEosManager.sendOffsets({ consumerGroupId, topics });
          for (const topicOffsets of topics) {
            const { topic, partitions } = topicOffsets;
            for (const { partition, offset } of partitions) {
              cluster.markOffsetAsCommitted({
                groupId: consumerGroupId,
                topic,
                partition,
                offset
              });
            }
          }
        }),
        isActive
      };
    };
    const getLogger = () => logger2;
    return {
      connect: async () => {
        await cluster.connect();
        connectionStatus = CONNECTION_STATUS.CONNECTED;
        instrumentationEmitter.emit(CONNECT);
        if (idempotent && !idempotentEosManager.isInitialized()) {
          await idempotentEosManager.initProducerId();
        }
      },
      disconnect: async () => {
        connectionStatus = CONNECTION_STATUS.DISCONNECTING;
        await cluster.disconnect();
        connectionStatus = CONNECTION_STATUS.DISCONNECTED;
        instrumentationEmitter.emit(DISCONNECT);
      },
      isIdempotent: () => {
        return idempotent;
      },
      events,
      on,
      send,
      sendBatch,
      transaction,
      logger: getLogger
    };
  };
});

// node_modules/kafkajs/src/utils/sleep.js
var require_sleep = __commonJS((exports, module) => {
  module.exports = (timeInMs) => new Promise((resolve) => {
    setTimeout(resolve, timeInMs);
  });
});

// node_modules/kafkajs/src/consumer/offsetManager/isInvalidOffset.js
var require_isInvalidOffset = __commonJS((exports, module) => {
  var Long = require_long();
  module.exports = (offset) => !offset && offset !== 0 || Long.fromValue(offset).isNegative();
});

// node_modules/kafkajs/src/consumer/offsetManager/initializeConsumerOffsets.js
var require_initializeConsumerOffsets = __commonJS((exports, module) => {
  var isInvalidOffset = require_isInvalidOffset();
  var { keys, assign } = Object;
  var indexPartitions = (obj, { partition, offset }) => assign(obj, { [partition]: offset });
  var indexTopics = (obj, { topic, partitions }) => assign(obj, { [topic]: partitions.reduce(indexPartitions, {}) });
  module.exports = (consumerOffsets, topicOffsets) => {
    const indexedConsumerOffsets = consumerOffsets.reduce(indexTopics, {});
    const indexedTopicOffsets = topicOffsets.reduce(indexTopics, {});
    return keys(indexedConsumerOffsets).map((topic) => {
      const partitions = indexedConsumerOffsets[topic];
      return {
        topic,
        partitions: keys(partitions).map((partition) => {
          const offset = partitions[partition];
          const resolvedOffset = isInvalidOffset(offset) ? indexedTopicOffsets[topic][partition] : offset;
          return { partition: Number(partition), offset: resolvedOffset };
        })
      };
    });
  };
});

// node_modules/kafkajs/src/consumer/instrumentationEvents.js
var require_instrumentationEvents3 = __commonJS((exports, module) => {
  var swapObject = require_swapObject();
  var InstrumentationEventType = require_eventType();
  var networkEvents = require_instrumentationEvents();
  var consumerType = InstrumentationEventType("consumer");
  var events = {
    HEARTBEAT: consumerType("heartbeat"),
    COMMIT_OFFSETS: consumerType("commit_offsets"),
    GROUP_JOIN: consumerType("group_join"),
    FETCH: consumerType("fetch"),
    FETCH_START: consumerType("fetch_start"),
    START_BATCH_PROCESS: consumerType("start_batch_process"),
    END_BATCH_PROCESS: consumerType("end_batch_process"),
    CONNECT: consumerType("connect"),
    DISCONNECT: consumerType("disconnect"),
    STOP: consumerType("stop"),
    CRASH: consumerType("crash"),
    REBALANCING: consumerType("rebalancing"),
    RECEIVED_UNSUBSCRIBED_TOPICS: consumerType("received_unsubscribed_topics"),
    REQUEST: consumerType(networkEvents.NETWORK_REQUEST),
    REQUEST_TIMEOUT: consumerType(networkEvents.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: consumerType(networkEvents.NETWORK_REQUEST_QUEUE_SIZE)
  };
  var wrappedEvents = {
    [events.REQUEST]: networkEvents.NETWORK_REQUEST,
    [events.REQUEST_TIMEOUT]: networkEvents.NETWORK_REQUEST_TIMEOUT,
    [events.REQUEST_QUEUE_SIZE]: networkEvents.NETWORK_REQUEST_QUEUE_SIZE
  };
  var reversedWrappedEvents = swapObject(wrappedEvents);
  var unwrap = (eventName) => wrappedEvents[eventName] || eventName;
  var wrap = (eventName) => reversedWrappedEvents[eventName] || eventName;
  module.exports = {
    events,
    wrap,
    unwrap
  };
});

// node_modules/kafkajs/src/consumer/offsetManager/index.js
var require_offsetManager = __commonJS((exports, module) => {
  var Long = require_long();
  var isInvalidOffset = require_isInvalidOffset();
  var initializeConsumerOffsets = require_initializeConsumerOffsets();
  var {
    events: { COMMIT_OFFSETS }
  } = require_instrumentationEvents3();
  var { keys, assign } = Object;
  var indexTopics = (topics) => topics.reduce((obj, topic) => assign(obj, { [topic]: {} }), {});
  var PRIVATE = {
    COMMITTED_OFFSETS: Symbol("private:OffsetManager:committedOffsets")
  };
  module.exports = class OffsetManager {
    constructor({
      cluster,
      coordinator,
      memberAssignment,
      autoCommit,
      autoCommitInterval,
      autoCommitThreshold,
      topicConfigurations,
      instrumentationEmitter,
      groupId,
      generationId,
      memberId
    }) {
      this.cluster = cluster;
      this.coordinator = coordinator;
      this.memberAssignment = memberAssignment;
      this.topicConfigurations = topicConfigurations;
      this.instrumentationEmitter = instrumentationEmitter;
      this.groupId = groupId;
      this.generationId = generationId;
      this.memberId = memberId;
      this.autoCommit = autoCommit;
      this.autoCommitInterval = autoCommitInterval;
      this.autoCommitThreshold = autoCommitThreshold;
      this.lastCommit = Date.now();
      this.topics = keys(memberAssignment);
      this.clearAllOffsets();
    }
    nextOffset(topic, partition) {
      if (!this.resolvedOffsets[topic][partition]) {
        this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];
      }
      let offset = this.resolvedOffsets[topic][partition];
      if (isInvalidOffset(offset)) {
        offset = "0";
      }
      return Long.fromValue(offset);
    }
    async getCoordinator() {
      if (!this.coordinator.isConnected()) {
        this.coordinator = await this.cluster.findBroker(this.coordinator);
      }
      return this.coordinator;
    }
    resetOffset({ topic, partition }) {
      this.resolvedOffsets[topic][partition] = this.committedOffsets()[topic][partition];
    }
    resolveOffset({ topic, partition, offset }) {
      this.resolvedOffsets[topic][partition] = Long.fromValue(offset).add(1).toString();
    }
    countResolvedOffsets() {
      const committedOffsets = this.committedOffsets();
      const subtractOffsets = (resolvedOffset, committedOffset) => {
        const resolvedOffsetLong = Long.fromValue(resolvedOffset);
        return isInvalidOffset(committedOffset) ? resolvedOffsetLong : resolvedOffsetLong.subtract(Long.fromValue(committedOffset));
      };
      const subtractPartitionOffsets = (resolvedTopicOffsets, committedTopicOffsets) => keys(resolvedTopicOffsets).map((partition) => subtractOffsets(resolvedTopicOffsets[partition], committedTopicOffsets[partition]));
      const subtractTopicOffsets = (topic) => subtractPartitionOffsets(this.resolvedOffsets[topic], committedOffsets[topic]);
      const offsetsDiff = this.topics.flatMap(subtractTopicOffsets);
      return offsetsDiff.reduce((sum, offset) => sum.add(offset), Long.fromValue(0));
    }
    async setDefaultOffset({ topic, partition }) {
      const { groupId, generationId, memberId } = this;
      const defaultOffset = this.cluster.defaultOffset(this.topicConfigurations[topic]);
      const coordinator = await this.getCoordinator();
      await coordinator.offsetCommit({
        groupId,
        memberId,
        groupGenerationId: generationId,
        topics: [
          {
            topic,
            partitions: [{ partition, offset: defaultOffset }]
          }
        ]
      });
      this.clearOffsets({ topic, partition });
    }
    async seek({ topic, partition, offset }) {
      if (!this.memberAssignment[topic] || !this.memberAssignment[topic].includes(partition)) {
        return;
      }
      if (!this.autoCommit) {
        this.resolveOffset({
          topic,
          partition,
          offset: Long.fromValue(offset).subtract(1).toString()
        });
        return;
      }
      const { groupId, generationId, memberId } = this;
      const coordinator = await this.getCoordinator();
      await coordinator.offsetCommit({
        groupId,
        memberId,
        groupGenerationId: generationId,
        topics: [
          {
            topic,
            partitions: [{ partition, offset }]
          }
        ]
      });
      this.clearOffsets({ topic, partition });
    }
    async commitOffsetsIfNecessary() {
      const now = Date.now();
      const timeoutReached = this.autoCommitInterval != null && now >= this.lastCommit + this.autoCommitInterval;
      const thresholdReached = this.autoCommitThreshold != null && this.countResolvedOffsets().gte(Long.fromValue(this.autoCommitThreshold));
      if (timeoutReached || thresholdReached) {
        return this.commitOffsets();
      }
    }
    uncommittedOffsets() {
      const offsets = (topic) => keys(this.resolvedOffsets[topic]);
      const emptyPartitions = ({ partitions }) => partitions.length > 0;
      const toPartitions = (topic) => (partition) => ({
        partition,
        offset: this.resolvedOffsets[topic][partition]
      });
      const changedOffsets = (topic) => ({ partition, offset }) => {
        return offset !== this.committedOffsets()[topic][partition] && Long.fromValue(offset).greaterThanOrEqual(0);
      };
      const topicsWithPartitionsToCommit = this.topics.map((topic) => ({
        topic,
        partitions: offsets(topic).map(toPartitions(topic)).filter(changedOffsets(topic))
      })).filter(emptyPartitions);
      return { topics: topicsWithPartitionsToCommit };
    }
    async commitOffsets(offsets = {}) {
      const { groupId, generationId, memberId } = this;
      const { topics = this.uncommittedOffsets().topics } = offsets;
      if (topics.length === 0) {
        this.lastCommit = Date.now();
        return;
      }
      const payload = {
        groupId,
        memberId,
        groupGenerationId: generationId,
        topics
      };
      try {
        const coordinator = await this.getCoordinator();
        await coordinator.offsetCommit(payload);
        this.instrumentationEmitter.emit(COMMIT_OFFSETS, payload);
        topics.forEach(({ topic, partitions }) => {
          const updatedOffsets = partitions.reduce((obj, { partition, offset }) => assign(obj, { [partition]: offset }), {});
          this[PRIVATE.COMMITTED_OFFSETS][topic] = assign({}, this.committedOffsets()[topic], updatedOffsets);
        });
        this.lastCommit = Date.now();
      } catch (e) {
        if (e.type === "NOT_COORDINATOR_FOR_GROUP") {
          await this.cluster.refreshMetadata();
        }
        throw e;
      }
    }
    async resolveOffsets() {
      const { groupId } = this;
      const invalidOffset = (topic) => (partition) => {
        return isInvalidOffset(this.committedOffsets()[topic][partition]);
      };
      const pendingPartitions = this.topics.map((topic) => ({
        topic,
        partitions: this.memberAssignment[topic].filter(invalidOffset(topic)).map((partition) => ({ partition }))
      })).filter((t) => t.partitions.length > 0);
      if (pendingPartitions.length === 0) {
        return;
      }
      const coordinator = await this.getCoordinator();
      const { responses: consumerOffsets } = await coordinator.offsetFetch({
        groupId,
        topics: pendingPartitions
      });
      const unresolvedPartitions = consumerOffsets.map(({ topic, partitions }) => assign({
        topic,
        partitions: partitions.filter(({ offset }) => isInvalidOffset(offset)).map(({ partition }) => assign({ partition }))
      }, this.topicConfigurations[topic]));
      const indexPartitions = (obj, { partition, offset }) => {
        return assign(obj, { [partition]: offset });
      };
      const hasUnresolvedPartitions = () => unresolvedPartitions.some((t) => t.partitions.length > 0);
      let offsets = consumerOffsets;
      if (hasUnresolvedPartitions()) {
        const topicOffsets = await this.cluster.fetchTopicsOffset(unresolvedPartitions);
        offsets = initializeConsumerOffsets(consumerOffsets, topicOffsets);
      }
      offsets.forEach(({ topic, partitions }) => {
        this.committedOffsets()[topic] = partitions.reduce(indexPartitions, {
          ...this.committedOffsets()[topic]
        });
      });
    }
    clearOffsets({ topic, partition }) {
      delete this.committedOffsets()[topic][partition];
      delete this.resolvedOffsets[topic][partition];
    }
    clearAllOffsets() {
      const committedOffsets = this.committedOffsets();
      for (const topic in committedOffsets) {
        delete committedOffsets[topic];
      }
      for (const topic of this.topics) {
        committedOffsets[topic] = {};
      }
      this.resolvedOffsets = indexTopics(this.topics);
    }
    committedOffsets() {
      if (!this[PRIVATE.COMMITTED_OFFSETS]) {
        this[PRIVATE.COMMITTED_OFFSETS] = this.groupId ? this.cluster.committedOffsets({ groupId: this.groupId }) : {};
      }
      return this[PRIVATE.COMMITTED_OFFSETS];
    }
  };
});

// node_modules/kafkajs/src/consumer/filterAbortedMessages.js
var require_filterAbortedMessages = __commonJS((exports, module) => {
  var Long = require_long();
  var ABORTED_MESSAGE_KEY = Buffer.from([0, 0, 0, 0]);
  var isAbortMarker = ({ key }) => {
    if (!key)
      return false;
    return Buffer.from(key).equals(ABORTED_MESSAGE_KEY);
  };
  module.exports = ({ messages, abortedTransactions }) => {
    const currentAbortedTransactions = new Map;
    if (!abortedTransactions || !abortedTransactions.length) {
      return messages;
    }
    const remainingAbortedTransactions = [...abortedTransactions];
    return messages.filter((message) => {
      if (remainingAbortedTransactions.length && Long.fromValue(message.offset).gte(remainingAbortedTransactions[0].firstOffset)) {
        const { producerId: producerId2 } = remainingAbortedTransactions.shift();
        currentAbortedTransactions.set(producerId2, true);
      }
      const { producerId, inTransaction } = message.batchContext;
      if (isAbortMarker(message)) {
        currentAbortedTransactions.delete(producerId);
      } else if (currentAbortedTransactions.has(producerId) && inTransaction) {
        return false;
      }
      return true;
    });
  };
});

// node_modules/kafkajs/src/consumer/batch.js
var require_batch = __commonJS((exports, module) => {
  var Long = require_long();
  var filterAbortedMessages = require_filterAbortedMessages();
  module.exports = class Batch {
    constructor(topic, fetchedOffset, partitionData) {
      this.fetchedOffset = fetchedOffset;
      const longFetchedOffset = Long.fromValue(this.fetchedOffset);
      const { abortedTransactions, messages } = partitionData;
      this.topic = topic;
      this.partition = partitionData.partition;
      this.highWatermark = partitionData.highWatermark;
      this.rawMessages = messages;
      this.messagesWithinOffset = this.rawMessages.filter((message) => Long.fromValue(message.offset).gte(longFetchedOffset));
      this.messages = filterAbortedMessages({
        messages: this.messagesWithinOffset,
        abortedTransactions
      }).filter((message) => !message.isControlRecord);
    }
    isEmpty() {
      return this.messages.length === 0;
    }
    isEmptyIncludingFiltered() {
      return this.messagesWithinOffset.length === 0;
    }
    isEmptyDueToFiltering() {
      return this.isEmpty() && this.rawMessages.length > 0;
    }
    isEmptyControlRecord() {
      return this.isEmpty() && this.messagesWithinOffset.some(({ isControlRecord }) => isControlRecord);
    }
    isEmptyDueToLogCompactedMessages() {
      const hasMessages = this.rawMessages.length > 0;
      return hasMessages && this.isEmptyIncludingFiltered();
    }
    firstOffset() {
      return this.isEmptyIncludingFiltered() ? null : this.messagesWithinOffset[0].offset;
    }
    lastOffset() {
      if (this.isEmptyDueToLogCompactedMessages()) {
        return this.fetchedOffset;
      }
      if (this.isEmptyIncludingFiltered()) {
        return Long.fromValue(this.highWatermark).add(-1).toString();
      }
      return this.messagesWithinOffset[this.messagesWithinOffset.length - 1].offset;
    }
    offsetLag() {
      const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);
      const lastConsumedOffset = Long.fromValue(this.lastOffset());
      return lastOffsetOfPartition.add(lastConsumedOffset.multiply(-1)).toString();
    }
    offsetLagLow() {
      if (this.isEmptyIncludingFiltered()) {
        return "0";
      }
      const lastOffsetOfPartition = Long.fromValue(this.highWatermark).add(-1);
      const firstConsumedOffset = Long.fromValue(this.firstOffset());
      return lastOffsetOfPartition.add(firstConsumedOffset.multiply(-1)).toString();
    }
  };
});

// node_modules/kafkajs/src/consumer/seekOffsets.js
var require_seekOffsets = __commonJS((exports, module) => {
  module.exports = class SeekOffsets extends Map {
    getKey(topic, partition) {
      return JSON.stringify([topic, partition]);
    }
    set(topic, partition, offset) {
      const key = this.getKey(topic, partition);
      super.set(key, offset);
    }
    has(topic, partition) {
      const key = this.getKey(topic, partition);
      return super.has(key);
    }
    pop(topic, partition) {
      if (this.size === 0 || !this.has(topic, partition)) {
        return;
      }
      const key = this.getKey(topic, partition);
      const offset = this.get(key);
      this.delete(key);
      return { topic, partition, offset };
    }
  };
});

// node_modules/kafkajs/src/consumer/subscriptionState.js
var require_subscriptionState = __commonJS((exports, module) => {
  var createState = (topic) => ({
    topic,
    paused: new Set,
    pauseAll: false,
    resumed: new Set
  });
  module.exports = class SubscriptionState {
    constructor() {
      this.assignedPartitionsByTopic = {};
      this.subscriptionStatesByTopic = {};
    }
    assign(topicPartitions = []) {
      this.assignedPartitionsByTopic = topicPartitions.reduce((assigned, { topic, partitions = [] }) => {
        return { ...assigned, [topic]: { topic, partitions } };
      }, {});
    }
    pause(topicPartitions = []) {
      topicPartitions.forEach(({ topic, partitions }) => {
        const state = this.subscriptionStatesByTopic[topic] || createState(topic);
        if (typeof partitions === "undefined") {
          state.paused.clear();
          state.resumed.clear();
          state.pauseAll = true;
        } else if (Array.isArray(partitions)) {
          partitions.forEach((partition) => {
            state.paused.add(partition);
            state.resumed.delete(partition);
          });
          state.pauseAll = false;
        }
        this.subscriptionStatesByTopic[topic] = state;
      });
    }
    resume(topicPartitions = []) {
      topicPartitions.forEach(({ topic, partitions }) => {
        const state = this.subscriptionStatesByTopic[topic] || createState(topic);
        if (typeof partitions === "undefined") {
          state.paused.clear();
          state.resumed.clear();
          state.pauseAll = false;
        } else if (Array.isArray(partitions)) {
          partitions.forEach((partition) => {
            state.paused.delete(partition);
            if (state.pauseAll) {
              state.resumed.add(partition);
            }
          });
        }
        this.subscriptionStatesByTopic[topic] = state;
      });
    }
    assigned() {
      return Object.values(this.assignedPartitionsByTopic).map(({ topic, partitions }) => ({
        topic,
        partitions: partitions.sort()
      }));
    }
    active() {
      return Object.values(this.assignedPartitionsByTopic).map(({ topic, partitions }) => ({
        topic,
        partitions: partitions.filter((partition) => !this.isPaused(topic, partition)).sort()
      }));
    }
    paused() {
      return Object.values(this.assignedPartitionsByTopic).map(({ topic, partitions }) => ({
        topic,
        partitions: partitions.filter((partition) => this.isPaused(topic, partition)).sort()
      })).filter(({ partitions }) => partitions.length !== 0);
    }
    isPaused(topic, partition) {
      const state = this.subscriptionStatesByTopic[topic];
      if (!state) {
        return false;
      }
      const partitionResumed = state.resumed.has(partition);
      const partitionPaused = state.paused.has(partition);
      return state.pauseAll && !partitionResumed || partitionPaused;
    }
  };
});

// node_modules/kafkajs/src/consumer/assignerProtocol.js
var require_assignerProtocol = __commonJS((exports, module) => {
  var Encoder = require_encoder();
  var Decoder = require_decoder();
  var MemberMetadata = {
    encode({ version: version2, topics, userData = Buffer.alloc(0) }) {
      return new Encoder().writeInt16(version2).writeArray(topics).writeBytes(userData).buffer;
    },
    decode(buffer) {
      const decoder = new Decoder(buffer);
      return {
        version: decoder.readInt16(),
        topics: decoder.readArray((d) => d.readString()),
        userData: decoder.readBytes()
      };
    }
  };
  var MemberAssignment = {
    encode({ version: version2, assignment, userData = Buffer.alloc(0) }) {
      return new Encoder().writeInt16(version2).writeArray(Object.keys(assignment).map((topic) => new Encoder().writeString(topic).writeArray(assignment[topic]))).writeBytes(userData).buffer;
    },
    decode(buffer) {
      const decoder = new Decoder(buffer);
      const decodePartitions = (d) => d.readInt32();
      const decodeAssignment = (d) => ({
        topic: d.readString(),
        partitions: d.readArray(decodePartitions)
      });
      const indexAssignment = (obj, { topic, partitions }) => Object.assign(obj, { [topic]: partitions });
      if (!decoder.canReadInt16()) {
        return null;
      }
      return {
        version: decoder.readInt16(),
        assignment: decoder.readArray(decodeAssignment).reduce(indexAssignment, {}),
        userData: decoder.readBytes()
      };
    }
  };
  module.exports = {
    MemberMetadata,
    MemberAssignment
  };
});

// node_modules/kafkajs/src/consumer/consumerGroup.js
var require_consumerGroup = __commonJS((exports, module) => {
  var sleep = require_sleep();
  var websiteUrl = require_websiteUrl();
  var arrayDiff = require_arrayDiff();
  var createRetry = require_retry();
  var sharedPromiseTo = require_sharedPromiseTo();
  var OffsetManager = require_offsetManager();
  var Batch = require_batch();
  var SeekOffsets = require_seekOffsets();
  var SubscriptionState = require_subscriptionState();
  var {
    events: { GROUP_JOIN, HEARTBEAT, CONNECT, RECEIVED_UNSUBSCRIBED_TOPICS }
  } = require_instrumentationEvents3();
  var { MemberAssignment } = require_assignerProtocol();
  var {
    KafkaJSError,
    KafkaJSNonRetriableError,
    KafkaJSStaleTopicMetadataAssignment,
    isRebalancing
  } = require_errors();
  var { keys } = Object;
  var STALE_METADATA_ERRORS = [
    "LEADER_NOT_AVAILABLE",
    "NOT_LEADER_FOR_PARTITION",
    "FENCED_LEADER_EPOCH",
    "UNKNOWN_LEADER_EPOCH",
    "UNKNOWN_TOPIC_OR_PARTITION"
  ];
  var PRIVATE = {
    JOIN: Symbol("private:ConsumerGroup:join"),
    SYNC: Symbol("private:ConsumerGroup:sync"),
    SHARED_HEARTBEAT: Symbol("private:ConsumerGroup:sharedHeartbeat")
  };
  module.exports = class ConsumerGroup {
    constructor({
      retry,
      cluster,
      groupId,
      topics,
      topicConfigurations,
      logger: logger2,
      instrumentationEmitter,
      assigners,
      sessionTimeout,
      rebalanceTimeout,
      maxBytesPerPartition,
      minBytes,
      maxBytes,
      maxWaitTimeInMs,
      autoCommit,
      autoCommitInterval,
      autoCommitThreshold,
      isolationLevel,
      rackId,
      metadataMaxAge
    }) {
      this.cluster = cluster;
      this.groupId = groupId;
      this.topics = topics;
      this.topicsSubscribed = topics;
      this.topicConfigurations = topicConfigurations;
      this.logger = logger2.namespace("ConsumerGroup");
      this.instrumentationEmitter = instrumentationEmitter;
      this.retrier = createRetry(Object.assign({}, retry));
      this.assigners = assigners;
      this.sessionTimeout = sessionTimeout;
      this.rebalanceTimeout = rebalanceTimeout;
      this.maxBytesPerPartition = maxBytesPerPartition;
      this.minBytes = minBytes;
      this.maxBytes = maxBytes;
      this.maxWaitTime = maxWaitTimeInMs;
      this.autoCommit = autoCommit;
      this.autoCommitInterval = autoCommitInterval;
      this.autoCommitThreshold = autoCommitThreshold;
      this.isolationLevel = isolationLevel;
      this.rackId = rackId;
      this.metadataMaxAge = metadataMaxAge;
      this.seekOffset = new SeekOffsets;
      this.coordinator = null;
      this.generationId = null;
      this.leaderId = null;
      this.memberId = null;
      this.members = null;
      this.groupProtocol = null;
      this.partitionsPerSubscribedTopic = null;
      this.preferredReadReplicasPerTopicPartition = {};
      this.offsetManager = null;
      this.subscriptionState = new SubscriptionState;
      this.lastRequest = Date.now();
      this[PRIVATE.SHARED_HEARTBEAT] = sharedPromiseTo(async ({ interval }) => {
        const { groupId: groupId2, generationId, memberId } = this;
        const now = Date.now();
        if (memberId && now >= this.lastRequest + interval) {
          const payload = {
            groupId: groupId2,
            memberId,
            groupGenerationId: generationId
          };
          await this.coordinator.heartbeat(payload);
          this.instrumentationEmitter.emit(HEARTBEAT, payload);
          this.lastRequest = Date.now();
        }
      });
    }
    isLeader() {
      return this.leaderId && this.memberId === this.leaderId;
    }
    getNodeIds() {
      return this.cluster.getNodeIds();
    }
    async connect() {
      await this.cluster.connect();
      this.instrumentationEmitter.emit(CONNECT);
      await this.cluster.refreshMetadataIfNecessary();
    }
    async[PRIVATE.JOIN]() {
      const { groupId, sessionTimeout, rebalanceTimeout } = this;
      this.coordinator = await this.cluster.findGroupCoordinator({ groupId });
      const groupData = await this.coordinator.joinGroup({
        groupId,
        sessionTimeout,
        rebalanceTimeout,
        memberId: this.memberId || "",
        groupProtocols: this.assigners.map((assigner) => assigner.protocol({
          topics: this.topicsSubscribed
        }))
      });
      this.generationId = groupData.generationId;
      this.leaderId = groupData.leaderId;
      this.memberId = groupData.memberId;
      this.members = groupData.members;
      this.groupProtocol = groupData.groupProtocol;
    }
    async leave() {
      const { groupId, memberId } = this;
      if (memberId) {
        await this.coordinator.leaveGroup({ groupId, memberId });
        this.memberId = null;
      }
    }
    async[PRIVATE.SYNC]() {
      let assignment = [];
      const {
        groupId,
        generationId,
        memberId,
        members,
        groupProtocol,
        topics,
        topicsSubscribed,
        coordinator
      } = this;
      if (this.isLeader()) {
        this.logger.debug("Chosen as group leader", { groupId, generationId, memberId, topics });
        const assigner = this.assigners.find(({ name }) => name === groupProtocol);
        if (!assigner) {
          throw new KafkaJSNonRetriableError(`Unsupported partition assigner "${groupProtocol}", the assigner wasn't found in the assigners list`);
        }
        await this.cluster.refreshMetadata();
        assignment = await assigner.assign({ members, topics: topicsSubscribed });
        this.logger.debug("Group assignment", {
          groupId,
          generationId,
          groupProtocol,
          assignment,
          topics: topicsSubscribed
        });
      }
      this.partitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
      const { memberAssignment } = await this.coordinator.syncGroup({
        groupId,
        generationId,
        memberId,
        groupAssignment: assignment
      });
      const decodedMemberAssignment = MemberAssignment.decode(memberAssignment);
      const decodedAssignment = decodedMemberAssignment != null ? decodedMemberAssignment.assignment : {};
      this.logger.debug("Received assignment", {
        groupId,
        generationId,
        memberId,
        memberAssignment: decodedAssignment
      });
      const assignedTopics = keys(decodedAssignment);
      const topicsNotSubscribed = arrayDiff(assignedTopics, topicsSubscribed);
      if (topicsNotSubscribed.length > 0) {
        const payload = {
          groupId,
          generationId,
          memberId,
          assignedTopics,
          topicsSubscribed,
          topicsNotSubscribed
        };
        this.instrumentationEmitter.emit(RECEIVED_UNSUBSCRIBED_TOPICS, payload);
        this.logger.warn("Consumer group received unsubscribed topics", {
          ...payload,
          helpUrl: websiteUrl("docs/faq", "why-am-i-receiving-messages-for-topics-i-m-not-subscribed-to")
        });
      }
      const safeAssignment = arrayDiff(assignedTopics, topicsNotSubscribed);
      const currentMemberAssignment = safeAssignment.map((topic) => ({
        topic,
        partitions: decodedAssignment[topic]
      }));
      for (const assignment2 of currentMemberAssignment) {
        const { topic, partitions: assignedPartitions } = assignment2;
        const knownPartitions = this.partitionsPerSubscribedTopic.get(topic);
        const isAwareOfAllAssignedPartitions = assignedPartitions.every((partition) => knownPartitions.includes(partition));
        if (!isAwareOfAllAssignedPartitions) {
          this.logger.warn("Consumer is not aware of all assigned partitions, refreshing metadata", {
            groupId,
            generationId,
            memberId,
            topic,
            knownPartitions,
            assignedPartitions
          });
          await this.cluster.refreshMetadata();
          this.partitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
          break;
        }
      }
      this.topics = currentMemberAssignment.map(({ topic }) => topic);
      this.subscriptionState.assign(currentMemberAssignment);
      this.offsetManager = new OffsetManager({
        cluster: this.cluster,
        topicConfigurations: this.topicConfigurations,
        instrumentationEmitter: this.instrumentationEmitter,
        memberAssignment: currentMemberAssignment.reduce((partitionsByTopic, { topic, partitions }) => ({
          ...partitionsByTopic,
          [topic]: partitions
        }), {}),
        autoCommit: this.autoCommit,
        autoCommitInterval: this.autoCommitInterval,
        autoCommitThreshold: this.autoCommitThreshold,
        coordinator,
        groupId,
        generationId,
        memberId
      });
    }
    joinAndSync() {
      const startJoin = Date.now();
      return this.retrier(async (bail) => {
        try {
          await this[PRIVATE.JOIN]();
          await this[PRIVATE.SYNC]();
          const memberAssignment = this.assigned().reduce((result, { topic, partitions }) => ({ ...result, [topic]: partitions }), {});
          const payload = {
            groupId: this.groupId,
            memberId: this.memberId,
            leaderId: this.leaderId,
            isLeader: this.isLeader(),
            memberAssignment,
            groupProtocol: this.groupProtocol,
            duration: Date.now() - startJoin
          };
          this.instrumentationEmitter.emit(GROUP_JOIN, payload);
          this.logger.info("Consumer has joined the group", payload);
        } catch (e) {
          if (isRebalancing(e)) {
            throw new KafkaJSError(e);
          }
          if (e.type === "UNKNOWN_MEMBER_ID") {
            this.memberId = null;
            throw new KafkaJSError(e);
          }
          bail(e);
        }
      });
    }
    resetOffset({ topic, partition }) {
      this.offsetManager.resetOffset({ topic, partition });
    }
    resolveOffset({ topic, partition, offset }) {
      this.offsetManager.resolveOffset({ topic, partition, offset });
    }
    seek({ topic, partition, offset }) {
      this.seekOffset.set(topic, partition, offset);
    }
    pause(topicPartitions) {
      this.logger.info(`Pausing fetching from ${topicPartitions.length} topics`, {
        topicPartitions
      });
      this.subscriptionState.pause(topicPartitions);
    }
    resume(topicPartitions) {
      this.logger.info(`Resuming fetching from ${topicPartitions.length} topics`, {
        topicPartitions
      });
      this.subscriptionState.resume(topicPartitions);
    }
    assigned() {
      return this.subscriptionState.assigned();
    }
    paused() {
      return this.subscriptionState.paused();
    }
    isPaused(topic, partition) {
      return this.subscriptionState.isPaused(topic, partition);
    }
    async commitOffsetsIfNecessary() {
      await this.offsetManager.commitOffsetsIfNecessary();
    }
    async commitOffsets(offsets) {
      await this.offsetManager.commitOffsets(offsets);
    }
    uncommittedOffsets() {
      return this.offsetManager.uncommittedOffsets();
    }
    async heartbeat({ interval }) {
      return this[PRIVATE.SHARED_HEARTBEAT]({ interval });
    }
    async fetch(nodeId) {
      try {
        await this.cluster.refreshMetadataIfNecessary();
        this.checkForStaleAssignment();
        let topicPartitions = this.subscriptionState.assigned();
        topicPartitions = this.filterPartitionsByNode(nodeId, topicPartitions);
        await this.seekOffsets(topicPartitions);
        const committedOffsets = this.offsetManager.committedOffsets();
        const activeTopicPartitions = this.getActiveTopicPartitions();
        const requests = topicPartitions.map(({ topic, partitions }) => ({
          topic,
          partitions: partitions.filter((partition) => committedOffsets[topic][partition] != null && activeTopicPartitions[topic].has(partition)).map((partition) => ({
            partition,
            fetchOffset: this.offsetManager.nextOffset(topic, partition).toString(),
            maxBytes: this.maxBytesPerPartition
          }))
        })).filter(({ partitions }) => partitions.length);
        if (!requests.length) {
          await sleep(this.maxWaitTime);
          return [];
        }
        const broker = await this.cluster.findBroker({ nodeId });
        const { responses } = await broker.fetch({
          maxWaitTime: this.maxWaitTime,
          minBytes: this.minBytes,
          maxBytes: this.maxBytes,
          isolationLevel: this.isolationLevel,
          topics: requests,
          rackId: this.rackId
        });
        return responses.flatMap(({ topicName, partitions }) => {
          const topicRequestData = requests.find(({ topic }) => topic === topicName);
          let preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[topicName];
          if (!preferredReadReplicas) {
            this.preferredReadReplicasPerTopicPartition[topicName] = preferredReadReplicas = {};
          }
          return partitions.filter(({ partition }) => !this.seekOffset.has(topicName, partition) && !this.subscriptionState.isPaused(topicName, partition)).map((partitionData) => {
            const { partition, preferredReadReplica } = partitionData;
            if (preferredReadReplica != null && preferredReadReplica !== -1) {
              const { nodeId: currentPreferredReadReplica } = preferredReadReplicas[partition] || {};
              if (currentPreferredReadReplica !== preferredReadReplica) {
                this.logger.info(`Preferred read replica is now ${preferredReadReplica}`, {
                  groupId: this.groupId,
                  memberId: this.memberId,
                  topic: topicName,
                  partition
                });
              }
              preferredReadReplicas[partition] = {
                nodeId: preferredReadReplica,
                expireAt: Date.now() + this.metadataMaxAge
              };
            }
            const partitionRequestData = topicRequestData.partitions.find(({ partition: partition2 }) => partition2 === partitionData.partition);
            const fetchedOffset = partitionRequestData.fetchOffset;
            return new Batch(topicName, fetchedOffset, partitionData);
          });
        });
      } catch (e) {
        await this.recoverFromFetch(e);
        return [];
      }
    }
    async recoverFromFetch(e) {
      if (STALE_METADATA_ERRORS.includes(e.type) || e.name === "KafkaJSTopicMetadataNotLoaded") {
        this.logger.debug("Stale cluster metadata, refreshing...", {
          groupId: this.groupId,
          memberId: this.memberId,
          error: e.message
        });
        await this.cluster.refreshMetadata();
        await this.joinAndSync();
        return;
      }
      if (e.name === "KafkaJSStaleTopicMetadataAssignment") {
        this.logger.warn(`${e.message}, resync group`, {
          groupId: this.groupId,
          memberId: this.memberId,
          topic: e.topic,
          unknownPartitions: e.unknownPartitions
        });
        await this.joinAndSync();
        return;
      }
      if (e.name === "KafkaJSOffsetOutOfRange") {
        await this.recoverFromOffsetOutOfRange(e);
        return;
      }
      if (e.name === "KafkaJSConnectionClosedError") {
        this.cluster.removeBroker({ host: e.host, port: e.port });
        return;
      }
      if (e.name === "KafkaJSBrokerNotFound" || e.name === "KafkaJSConnectionClosedError") {
        this.logger.debug(`${e.message}, refreshing metadata and retrying...`);
        await this.cluster.refreshMetadata();
        return;
      }
      throw e;
    }
    async recoverFromOffsetOutOfRange(e) {
      const preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[e.topic];
      if (preferredReadReplicas && typeof preferredReadReplicas[e.partition] === "number") {
        this.logger.info("Offset out of range while fetching from follower, retrying with leader", {
          topic: e.topic,
          partition: e.partition,
          groupId: this.groupId,
          memberId: this.memberId
        });
        delete preferredReadReplicas[e.partition];
      } else {
        this.logger.error("Offset out of range, resetting to default offset", {
          topic: e.topic,
          partition: e.partition,
          groupId: this.groupId,
          memberId: this.memberId
        });
        await this.offsetManager.setDefaultOffset({
          topic: e.topic,
          partition: e.partition
        });
      }
    }
    generatePartitionsPerSubscribedTopic() {
      const map2 = new Map;
      for (const topic of this.topicsSubscribed) {
        const partitions = this.cluster.findTopicPartitionMetadata(topic).map((m) => m.partitionId).sort();
        map2.set(topic, partitions);
      }
      return map2;
    }
    checkForStaleAssignment() {
      if (!this.partitionsPerSubscribedTopic) {
        return;
      }
      const newPartitionsPerSubscribedTopic = this.generatePartitionsPerSubscribedTopic();
      for (const [topic, partitions] of newPartitionsPerSubscribedTopic) {
        const diff = arrayDiff(partitions, this.partitionsPerSubscribedTopic.get(topic));
        if (diff.length > 0) {
          throw new KafkaJSStaleTopicMetadataAssignment("Topic has been updated", {
            topic,
            unknownPartitions: diff
          });
        }
      }
    }
    async seekOffsets(topicPartitions) {
      for (const { topic, partitions } of topicPartitions) {
        for (const partition of partitions) {
          const seekEntry = this.seekOffset.pop(topic, partition);
          if (!seekEntry) {
            continue;
          }
          this.logger.debug("Seek offset", {
            groupId: this.groupId,
            memberId: this.memberId,
            seek: seekEntry
          });
          await this.offsetManager.seek(seekEntry);
        }
      }
      await this.offsetManager.resolveOffsets();
    }
    hasSeekOffset({ topic, partition }) {
      return this.seekOffset.has(topic, partition);
    }
    findReadReplicaForPartitions(topic, partitions) {
      const partitionMetadata = this.cluster.findTopicPartitionMetadata(topic);
      const preferredReadReplicas = this.preferredReadReplicasPerTopicPartition[topic];
      return partitions.reduce((result, id) => {
        const partitionId = parseInt(id, 10);
        const metadata = partitionMetadata.find((p) => p.partitionId === partitionId);
        if (!metadata) {
          return result;
        }
        if (metadata.leader == null) {
          throw new KafkaJSError("Invalid partition metadata", { topic, partitionId, metadata });
        }
        let nodeId = metadata.leader;
        if (preferredReadReplicas) {
          const { nodeId: preferredReadReplica, expireAt } = preferredReadReplicas[partitionId] || {};
          if (Date.now() >= expireAt) {
            this.logger.debug("Preferred read replica information has expired, using leader", {
              topic,
              partitionId,
              groupId: this.groupId,
              memberId: this.memberId,
              preferredReadReplica,
              leader: metadata.leader
            });
            delete preferredReadReplicas[partitionId];
          } else if (preferredReadReplica != null) {
            const offlineReplicas = metadata.offlineReplicas;
            if (Array.isArray(offlineReplicas) && offlineReplicas.includes(nodeId)) {
              this.logger.debug("Preferred read replica is offline, using leader", {
                topic,
                partitionId,
                groupId: this.groupId,
                memberId: this.memberId,
                preferredReadReplica,
                leader: metadata.leader
              });
            } else {
              nodeId = preferredReadReplica;
            }
          }
        }
        const current = result[nodeId] || [];
        return { ...result, [nodeId]: [...current, partitionId] };
      }, {});
    }
    filterPartitionsByNode(nodeId, topicPartitions) {
      return topicPartitions.map(({ topic, partitions }) => ({
        topic,
        partitions: this.findReadReplicaForPartitions(topic, partitions)[nodeId] || []
      }));
    }
    getActiveTopicPartitions() {
      const activeSubscriptionState = this.subscriptionState.active();
      const activeTopicPartitions = {};
      activeSubscriptionState.forEach(({ topic, partitions }) => {
        activeTopicPartitions[topic] = new Set(partitions);
      });
      return activeTopicPartitions;
    }
  };
});

// node_modules/kafkajs/src/utils/seq.js
var require_seq = __commonJS((exports, module) => {
  var seq = (count, callback = (x) => x) => new Array(count).fill(0).map((_, index) => callback(index));
  module.exports = seq;
});

// node_modules/kafkajs/src/consumer/fetcher.js
var require_fetcher = __commonJS((exports, module) => {
  var EventEmitter = __require("events");
  var createFetcher = ({
    nodeId,
    workerQueue,
    partitionAssignments,
    fetch,
    logger: rootLogger
  }) => {
    const logger2 = rootLogger.namespace(`Fetcher ${nodeId}`);
    const emitter = new EventEmitter;
    let isRunning = false;
    const getWorkerQueue = () => workerQueue;
    const assignmentKey = ({ topic, partition }) => `${topic}|${partition}`;
    const getAssignedFetcher = (batch) => partitionAssignments.get(assignmentKey(batch));
    const assignTopicPartition = (batch) => partitionAssignments.set(assignmentKey(batch), nodeId);
    const unassignTopicPartition = (batch) => partitionAssignments.delete(assignmentKey(batch));
    const filterUnassignedBatches = (batches) => batches.filter((batch) => {
      const assignedFetcher = getAssignedFetcher(batch);
      if (assignedFetcher != null && assignedFetcher !== nodeId) {
        logger2.info("Filtering out batch due to partition already being processed by another fetcher", {
          topic: batch.topic,
          partition: batch.partition,
          assignedFetcher,
          fetcher: nodeId
        });
        return false;
      }
      return true;
    });
    const start = async () => {
      if (isRunning)
        return;
      isRunning = true;
      while (isRunning) {
        try {
          const batches = await fetch(nodeId);
          if (isRunning) {
            const availableBatches = filterUnassignedBatches(batches);
            if (availableBatches.length > 0) {
              availableBatches.forEach(assignTopicPartition);
              try {
                await workerQueue.push(...availableBatches);
              } finally {
                availableBatches.forEach(unassignTopicPartition);
              }
            }
          }
        } catch (error40) {
          isRunning = false;
          emitter.emit("end");
          throw error40;
        }
      }
      emitter.emit("end");
    };
    const stop = async () => {
      if (!isRunning)
        return;
      isRunning = false;
      await new Promise((resolve) => emitter.once("end", () => resolve()));
    };
    return { start, stop, getWorkerQueue };
  };
  module.exports = createFetcher;
});

// node_modules/kafkajs/src/consumer/worker.js
var require_worker = __commonJS((exports, module) => {
  var sharedPromiseTo = require_sharedPromiseTo();
  var createWorker = ({ handler, workerId }) => {
    const run = sharedPromiseTo(async ({ next }) => {
      while (true) {
        const item = next();
        if (!item)
          break;
        const { batch, resolve, reject } = item;
        try {
          await handler(batch, { workerId });
          resolve();
        } catch (error40) {
          reject(error40);
        }
      }
    });
    return { run };
  };
  module.exports = createWorker;
});

// node_modules/kafkajs/src/consumer/workerQueue.js
var require_workerQueue = __commonJS((exports, module) => {
  var createWorkerQueue = ({ workers }) => {
    const queue = [];
    const getWorkers = () => workers;
    const push = async (...batches) => {
      const promises = batches.map((batch) => new Promise((resolve, reject) => queue.push({ batch, resolve, reject })));
      workers.forEach((worker) => worker.run({ next: () => queue.shift() }));
      const results = await Promise.allSettled(promises);
      const rejected = results.find((result) => result.status === "rejected");
      if (rejected) {
        throw rejected.reason;
      }
    };
    return { push, getWorkers };
  };
  module.exports = createWorkerQueue;
});

// node_modules/kafkajs/src/consumer/fetchManager.js
var require_fetchManager = __commonJS((exports, module) => {
  var seq = require_seq();
  var createFetcher = require_fetcher();
  var createWorker = require_worker();
  var createWorkerQueue = require_workerQueue();
  var { KafkaJSFetcherRebalanceError, KafkaJSNoBrokerAvailableError } = require_errors();
  var createFetchManager = ({
    logger: rootLogger,
    getNodeIds,
    fetch,
    handler,
    concurrency = 1
  }) => {
    const logger2 = rootLogger.namespace("FetchManager");
    const workers = seq(concurrency, (workerId) => createWorker({ handler, workerId }));
    const workerQueue = createWorkerQueue({ workers });
    let fetchers = [];
    const getFetchers = () => fetchers;
    const createFetchers = () => {
      const nodeIds = getNodeIds();
      const partitionAssignments = new Map;
      if (nodeIds.length === 0) {
        throw new KafkaJSNoBrokerAvailableError;
      }
      const validateShouldRebalance = () => {
        const current = getNodeIds();
        const hasChanged = nodeIds.length !== current.length || nodeIds.some((nodeId) => !current.includes(nodeId));
        if (hasChanged && current.length !== 0) {
          throw new KafkaJSFetcherRebalanceError;
        }
      };
      const fetchers2 = nodeIds.map((nodeId) => createFetcher({
        nodeId,
        workerQueue,
        partitionAssignments,
        fetch: async (nodeId2) => {
          validateShouldRebalance();
          return fetch(nodeId2);
        },
        logger: logger2
      }));
      logger2.debug(`Created ${fetchers2.length} fetchers`, { nodeIds, concurrency });
      return fetchers2;
    };
    const start = async () => {
      logger2.debug("Starting...");
      while (true) {
        fetchers = createFetchers();
        try {
          await Promise.all(fetchers.map((fetcher) => fetcher.start()));
        } catch (error40) {
          await stop();
          if (error40 instanceof KafkaJSFetcherRebalanceError) {
            logger2.debug("Rebalancing fetchers...");
            continue;
          }
          throw error40;
        }
        break;
      }
    };
    const stop = async () => {
      logger2.debug("Stopping fetchers...");
      await Promise.all(fetchers.map((fetcher) => fetcher.stop()));
      logger2.debug("Stopped fetchers");
    };
    return { start, stop, getFetchers };
  };
  module.exports = createFetchManager;
});

// node_modules/kafkajs/src/consumer/runner.js
var require_runner = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Long = require_long();
  var createRetry = require_retry();
  var { isKafkaJSError, isRebalancing } = require_errors();
  var {
    events: { FETCH, FETCH_START, START_BATCH_PROCESS, END_BATCH_PROCESS, REBALANCING }
  } = require_instrumentationEvents3();
  var createFetchManager = require_fetchManager();
  var isSameOffset = (offsetA, offsetB) => Long.fromValue(offsetA).equals(Long.fromValue(offsetB));
  var CONSUMING_START = "consuming-start";
  var CONSUMING_STOP = "consuming-stop";
  module.exports = class Runner extends EventEmitter {
    constructor({
      logger: logger2,
      consumerGroup,
      instrumentationEmitter,
      eachBatchAutoResolve = true,
      concurrency,
      eachBatch,
      eachMessage,
      heartbeatInterval,
      onCrash,
      retry,
      autoCommit = true
    }) {
      super();
      this.logger = logger2.namespace("Runner");
      this.consumerGroup = consumerGroup;
      this.instrumentationEmitter = instrumentationEmitter;
      this.eachBatchAutoResolve = eachBatchAutoResolve;
      this.eachBatch = eachBatch;
      this.eachMessage = eachMessage;
      this.heartbeatInterval = heartbeatInterval;
      this.retrier = createRetry(Object.assign({}, retry));
      this.onCrash = onCrash;
      this.autoCommit = autoCommit;
      this.fetchManager = createFetchManager({
        logger: this.logger,
        getNodeIds: () => this.consumerGroup.getNodeIds(),
        fetch: (nodeId) => this.fetch(nodeId),
        handler: (batch) => this.handleBatch(batch),
        concurrency
      });
      this.running = false;
      this.consuming = false;
    }
    get consuming() {
      return this._consuming;
    }
    set consuming(value) {
      if (this._consuming !== value) {
        this._consuming = value;
        this.emit(value ? CONSUMING_START : CONSUMING_STOP);
      }
    }
    async start() {
      if (this.running) {
        return;
      }
      try {
        await this.consumerGroup.connect();
        await this.consumerGroup.joinAndSync();
      } catch (e) {
        return this.onCrash(e);
      }
      this.running = true;
      this.scheduleFetchManager();
    }
    scheduleFetchManager() {
      if (!this.running) {
        this.consuming = false;
        this.logger.info("consumer not running, exiting", {
          groupId: this.consumerGroup.groupId,
          memberId: this.consumerGroup.memberId
        });
        return;
      }
      this.consuming = true;
      this.retrier(async (bail, retryCount, retryTime) => {
        if (!this.running) {
          return;
        }
        try {
          await this.fetchManager.start();
        } catch (e) {
          if (isRebalancing(e)) {
            this.logger.warn("The group is rebalancing, re-joining", {
              groupId: this.consumerGroup.groupId,
              memberId: this.consumerGroup.memberId,
              error: e.message
            });
            this.instrumentationEmitter.emit(REBALANCING, {
              groupId: this.consumerGroup.groupId,
              memberId: this.consumerGroup.memberId
            });
            await this.consumerGroup.joinAndSync();
            return;
          }
          if (e.type === "UNKNOWN_MEMBER_ID") {
            this.logger.error("The coordinator is not aware of this member, re-joining the group", {
              groupId: this.consumerGroup.groupId,
              memberId: this.consumerGroup.memberId,
              error: e.message
            });
            this.consumerGroup.memberId = null;
            await this.consumerGroup.joinAndSync();
            return;
          }
          if (e.name === "KafkaJSNotImplemented") {
            return bail(e);
          }
          if (e.name === "KafkaJSNoBrokerAvailableError") {
            return bail(e);
          }
          this.logger.debug("Error while scheduling fetch manager, trying again...", {
            groupId: this.consumerGroup.groupId,
            memberId: this.consumerGroup.memberId,
            error: e.message,
            stack: e.stack,
            retryCount,
            retryTime
          });
          throw e;
        }
      }).then(() => {
        this.scheduleFetchManager();
      }).catch((e) => {
        this.onCrash(e);
        this.consuming = false;
        this.running = false;
      });
    }
    async stop() {
      if (!this.running) {
        return;
      }
      this.logger.debug("stop consumer group", {
        groupId: this.consumerGroup.groupId,
        memberId: this.consumerGroup.memberId
      });
      this.running = false;
      try {
        await this.fetchManager.stop();
        await this.waitForConsumer();
        await this.consumerGroup.leave();
      } catch (e) {}
    }
    waitForConsumer() {
      return new Promise((resolve) => {
        if (!this.consuming) {
          return resolve();
        }
        this.logger.debug("waiting for consumer to finish...", {
          groupId: this.consumerGroup.groupId,
          memberId: this.consumerGroup.memberId
        });
        this.once(CONSUMING_STOP, () => resolve());
      });
    }
    async heartbeat() {
      try {
        await this.consumerGroup.heartbeat({ interval: this.heartbeatInterval });
      } catch (e) {
        if (isRebalancing(e)) {
          await this.autoCommitOffsets();
        }
        throw e;
      }
    }
    async processEachMessage(batch) {
      const { topic, partition } = batch;
      const pause = () => {
        this.consumerGroup.pause([{ topic, partitions: [partition] }]);
        return () => this.consumerGroup.resume([{ topic, partitions: [partition] }]);
      };
      for (const message of batch.messages) {
        if (!this.running || this.consumerGroup.hasSeekOffset({ topic, partition })) {
          break;
        }
        try {
          await this.eachMessage({
            topic,
            partition,
            message,
            heartbeat: () => this.heartbeat(),
            pause
          });
        } catch (e) {
          if (!isKafkaJSError(e)) {
            this.logger.error(`Error when calling eachMessage`, {
              topic,
              partition,
              offset: message.offset,
              stack: e.stack,
              error: e
            });
          }
          await this.autoCommitOffsets();
          throw e;
        }
        this.consumerGroup.resolveOffset({ topic, partition, offset: message.offset });
        await this.heartbeat();
        await this.autoCommitOffsetsIfNecessary();
        if (this.consumerGroup.isPaused(topic, partition)) {
          break;
        }
      }
    }
    async processEachBatch(batch) {
      const { topic, partition } = batch;
      const lastFilteredMessage = batch.messages[batch.messages.length - 1];
      const pause = () => {
        this.consumerGroup.pause([{ topic, partitions: [partition] }]);
        return () => this.consumerGroup.resume([{ topic, partitions: [partition] }]);
      };
      try {
        await this.eachBatch({
          batch,
          resolveOffset: (offset) => {
            const offsetToResolve = lastFilteredMessage && isSameOffset(offset, lastFilteredMessage.offset) ? batch.lastOffset() : offset;
            this.consumerGroup.resolveOffset({ topic, partition, offset: offsetToResolve });
          },
          heartbeat: () => this.heartbeat(),
          pause,
          commitOffsetsIfNecessary: async (offsets) => {
            return offsets ? this.consumerGroup.commitOffsets(offsets) : this.consumerGroup.commitOffsetsIfNecessary();
          },
          uncommittedOffsets: () => this.consumerGroup.uncommittedOffsets(),
          isRunning: () => this.running,
          isStale: () => this.consumerGroup.hasSeekOffset({ topic, partition })
        });
      } catch (e) {
        if (!isKafkaJSError(e)) {
          this.logger.error(`Error when calling eachBatch`, {
            topic,
            partition,
            offset: batch.firstOffset(),
            stack: e.stack,
            error: e
          });
        }
        await this.autoCommitOffsets();
        throw e;
      }
      if (this.eachBatchAutoResolve) {
        this.consumerGroup.resolveOffset({ topic, partition, offset: batch.lastOffset() });
      }
    }
    async fetch(nodeId) {
      if (!this.running) {
        this.logger.debug("consumer not running, exiting", {
          groupId: this.consumerGroup.groupId,
          memberId: this.consumerGroup.memberId
        });
        return [];
      }
      const startFetch = Date.now();
      this.instrumentationEmitter.emit(FETCH_START, { nodeId });
      const batches = await this.consumerGroup.fetch(nodeId);
      this.instrumentationEmitter.emit(FETCH, {
        numberOfBatches: 0,
        duration: Date.now() - startFetch,
        nodeId
      });
      if (batches.length === 0) {
        await this.heartbeat();
      }
      return batches;
    }
    async handleBatch(batch) {
      if (!this.running) {
        this.logger.debug("consumer not running, exiting", {
          groupId: this.consumerGroup.groupId,
          memberId: this.consumerGroup.memberId
        });
        return;
      }
      const onBatch = async (batch2) => {
        const startBatchProcess = Date.now();
        const payload = {
          topic: batch2.topic,
          partition: batch2.partition,
          highWatermark: batch2.highWatermark,
          offsetLag: batch2.offsetLag(),
          offsetLagLow: batch2.offsetLagLow(),
          batchSize: batch2.messages.length,
          firstOffset: batch2.firstOffset(),
          lastOffset: batch2.lastOffset()
        };
        if (batch2.isEmptyDueToFiltering()) {
          this.instrumentationEmitter.emit(START_BATCH_PROCESS, payload);
          this.consumerGroup.resolveOffset({
            topic: batch2.topic,
            partition: batch2.partition,
            offset: batch2.lastOffset()
          });
          await this.autoCommitOffsetsIfNecessary();
          this.instrumentationEmitter.emit(END_BATCH_PROCESS, {
            ...payload,
            duration: Date.now() - startBatchProcess
          });
          await this.heartbeat();
          return;
        }
        if (batch2.isEmpty()) {
          await this.heartbeat();
          return;
        }
        this.instrumentationEmitter.emit(START_BATCH_PROCESS, payload);
        if (this.eachMessage) {
          await this.processEachMessage(batch2);
        } else if (this.eachBatch) {
          await this.processEachBatch(batch2);
        }
        this.instrumentationEmitter.emit(END_BATCH_PROCESS, {
          ...payload,
          duration: Date.now() - startBatchProcess
        });
        await this.autoCommitOffsets();
        await this.heartbeat();
      };
      await onBatch(batch);
    }
    autoCommitOffsets() {
      if (this.autoCommit) {
        return this.consumerGroup.commitOffsets();
      }
    }
    autoCommitOffsetsIfNecessary() {
      if (this.autoCommit) {
        return this.consumerGroup.commitOffsetsIfNecessary();
      }
    }
    commitOffsets(offsets) {
      if (!this.running) {
        this.logger.debug("consumer not running, exiting", {
          groupId: this.consumerGroup.groupId,
          memberId: this.consumerGroup.memberId,
          offsets
        });
        return;
      }
      return this.retrier(async (bail, retryCount, retryTime) => {
        try {
          await this.consumerGroup.commitOffsets(offsets);
        } catch (e) {
          if (!this.running) {
            this.logger.debug("consumer not running, exiting", {
              error: e.message,
              groupId: this.consumerGroup.groupId,
              memberId: this.consumerGroup.memberId,
              offsets
            });
            return;
          }
          if (e.name === "KafkaJSNotImplemented") {
            return bail(e);
          }
          this.logger.debug("Error while committing offsets, trying again...", {
            groupId: this.consumerGroup.groupId,
            memberId: this.consumerGroup.memberId,
            error: e.message,
            stack: e.stack,
            retryCount,
            retryTime,
            offsets
          });
          throw e;
        }
      });
    }
  };
});

// node_modules/kafkajs/src/consumer/assigners/roundRobinAssigner/index.js
var require_roundRobinAssigner = __commonJS((exports, module) => {
  var { MemberMetadata, MemberAssignment } = require_assignerProtocol();
  module.exports = ({ cluster }) => ({
    name: "RoundRobinAssigner",
    version: 0,
    async assign({ members, topics }) {
      const membersCount = members.length;
      const sortedMembers = members.map(({ memberId }) => memberId).sort();
      const assignment = {};
      const topicsPartitions = topics.flatMap((topic) => {
        const partitionMetadata = cluster.findTopicPartitionMetadata(topic);
        return partitionMetadata.map((m) => ({ topic, partitionId: m.partitionId }));
      });
      topicsPartitions.forEach((topicPartition, i) => {
        const assignee = sortedMembers[i % membersCount];
        if (!assignment[assignee]) {
          assignment[assignee] = Object.create(null);
        }
        if (!assignment[assignee][topicPartition.topic]) {
          assignment[assignee][topicPartition.topic] = [];
        }
        assignment[assignee][topicPartition.topic].push(topicPartition.partitionId);
      });
      return Object.keys(assignment).map((memberId) => ({
        memberId,
        memberAssignment: MemberAssignment.encode({
          version: this.version,
          assignment: assignment[memberId]
        })
      }));
    },
    protocol({ topics }) {
      return {
        name: this.name,
        metadata: MemberMetadata.encode({
          version: this.version,
          topics
        })
      };
    }
  });
});

// node_modules/kafkajs/src/consumer/assigners/index.js
var require_assigners = __commonJS((exports, module) => {
  var roundRobin = require_roundRobinAssigner();
  module.exports = {
    roundRobin
  };
});

// node_modules/kafkajs/src/consumer/index.js
var require_consumer = __commonJS((exports, module) => {
  var Long = require_long();
  var createRetry = require_retry();
  var { initialRetryTime } = require_defaults();
  var ConsumerGroup = require_consumerGroup();
  var Runner = require_runner();
  var { events, wrap: wrapEvent, unwrap: unwrapEvent } = require_instrumentationEvents3();
  var InstrumentationEventEmitter = require_emitter();
  var { KafkaJSNonRetriableError } = require_errors();
  var { roundRobin } = require_assigners();
  var { EARLIEST_OFFSET, LATEST_OFFSET } = require_constants();
  var ISOLATION_LEVEL = require_isolationLevel();
  var sharedPromiseTo = require_sharedPromiseTo();
  var { keys, values } = Object;
  var { CONNECT, DISCONNECT, STOP, CRASH } = events;
  var eventNames = values(events);
  var eventKeys = keys(events).map((key) => `consumer.events.${key}`).join(", ");
  var specialOffsets = [
    Long.fromValue(EARLIEST_OFFSET).toString(),
    Long.fromValue(LATEST_OFFSET).toString()
  ];
  module.exports = ({
    cluster,
    groupId,
    retry,
    logger: rootLogger,
    partitionAssigners = [roundRobin],
    sessionTimeout = 30000,
    rebalanceTimeout = 60000,
    heartbeatInterval = 3000,
    maxBytesPerPartition = 1048576,
    minBytes = 1,
    maxBytes = 10485760,
    maxWaitTimeInMs = 5000,
    isolationLevel = ISOLATION_LEVEL.READ_COMMITTED,
    rackId = "",
    instrumentationEmitter: rootInstrumentationEmitter,
    metadataMaxAge
  }) => {
    if (!groupId) {
      throw new KafkaJSNonRetriableError("Consumer groupId must be a non-empty string.");
    }
    const logger2 = rootLogger.namespace("Consumer");
    const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter;
    const assigners = partitionAssigners.map((createAssigner) => createAssigner({ groupId, logger: logger2, cluster }));
    const topics = {};
    let runner = null;
    let consumerGroup = null;
    let restartTimeout = null;
    if (heartbeatInterval >= sessionTimeout) {
      throw new KafkaJSNonRetriableError(`Consumer heartbeatInterval (${heartbeatInterval}) must be lower than sessionTimeout (${sessionTimeout}). It is recommended to set heartbeatInterval to approximately a third of the sessionTimeout.`);
    }
    const connect = async () => {
      await cluster.connect();
      instrumentationEmitter.emit(CONNECT);
    };
    const disconnect = async () => {
      try {
        await stop();
        logger2.debug("consumer has stopped, disconnecting", { groupId });
        await cluster.disconnect();
        instrumentationEmitter.emit(DISCONNECT);
      } catch (e) {
        logger2.error(`Caught error when disconnecting the consumer: ${e.message}`, {
          stack: e.stack,
          groupId
        });
        throw e;
      }
    };
    const stop = sharedPromiseTo(async () => {
      try {
        if (runner) {
          await runner.stop();
          runner = null;
          consumerGroup = null;
          instrumentationEmitter.emit(STOP);
        }
        clearTimeout(restartTimeout);
        logger2.info("Stopped", { groupId });
      } catch (e) {
        logger2.error(`Caught error when stopping the consumer: ${e.message}`, {
          stack: e.stack,
          groupId
        });
        throw e;
      }
    });
    const subscribe = async ({ topic, topics: subscriptionTopics, fromBeginning = false }) => {
      if (consumerGroup) {
        throw new KafkaJSNonRetriableError("Cannot subscribe to topic while consumer is running");
      }
      if (!topic && !subscriptionTopics) {
        throw new KafkaJSNonRetriableError('Missing required argument "topics"');
      }
      if (subscriptionTopics != null && !Array.isArray(subscriptionTopics)) {
        throw new KafkaJSNonRetriableError('Argument "topics" must be an array');
      }
      const subscriptions = subscriptionTopics || [topic];
      for (const subscription of subscriptions) {
        if (typeof subscription !== "string" && !(subscription instanceof RegExp)) {
          throw new KafkaJSNonRetriableError(`Invalid topic ${subscription} (${typeof subscription}), the topic name has to be a String or a RegExp`);
        }
      }
      const hasRegexSubscriptions = subscriptions.some((subscription) => subscription instanceof RegExp);
      const metadata = hasRegexSubscriptions ? await cluster.metadata() : undefined;
      const topicsToSubscribe = [];
      for (const subscription of subscriptions) {
        const isRegExp = subscription instanceof RegExp;
        if (isRegExp) {
          const topicRegExp = subscription;
          const matchedTopics = metadata.topicMetadata.map(({ topic: topicName }) => topicName).filter((topicName) => topicRegExp.test(topicName));
          logger2.debug("Subscription based on RegExp", {
            groupId,
            topicRegExp: topicRegExp.toString(),
            matchedTopics
          });
          topicsToSubscribe.push(...matchedTopics);
        } else {
          topicsToSubscribe.push(subscription);
        }
      }
      for (const t of topicsToSubscribe) {
        topics[t] = { fromBeginning };
      }
      await cluster.addMultipleTargetTopics(topicsToSubscribe);
    };
    const run = async ({
      autoCommit = true,
      autoCommitInterval = null,
      autoCommitThreshold = null,
      eachBatchAutoResolve = true,
      partitionsConsumedConcurrently: concurrency = 1,
      eachBatch = null,
      eachMessage = null
    } = {}) => {
      if (consumerGroup) {
        logger2.warn("consumer#run was called, but the consumer is already running", { groupId });
        return;
      }
      const start = async (onCrash2) => {
        logger2.info("Starting", { groupId });
        consumerGroup = new ConsumerGroup({
          logger: rootLogger,
          topics: keys(topics),
          topicConfigurations: topics,
          retry,
          cluster,
          groupId,
          assigners,
          sessionTimeout,
          rebalanceTimeout,
          maxBytesPerPartition,
          minBytes,
          maxBytes,
          maxWaitTimeInMs,
          instrumentationEmitter,
          isolationLevel,
          rackId,
          metadataMaxAge,
          autoCommit,
          autoCommitInterval,
          autoCommitThreshold
        });
        runner = new Runner({
          logger: rootLogger,
          consumerGroup,
          instrumentationEmitter,
          heartbeatInterval,
          retry,
          autoCommit,
          eachBatchAutoResolve,
          eachBatch,
          eachMessage,
          onCrash: onCrash2,
          concurrency
        });
        await runner.start();
      };
      const onCrash = async (e) => {
        logger2.error(`Crash: ${e.name}: ${e.message}`, {
          groupId,
          retryCount: e.retryCount,
          stack: e.stack
        });
        if (e.name === "KafkaJSConnectionClosedError") {
          cluster.removeBroker({ host: e.host, port: e.port });
        }
        await disconnect();
        const getOriginalCause = (error40) => {
          if (error40.cause) {
            return getOriginalCause(error40.cause);
          }
          return error40;
        };
        const isErrorRetriable = e.name === "KafkaJSNumberOfRetriesExceeded" || getOriginalCause(e).retriable === true;
        const shouldRestart = isErrorRetriable && (!retry || !retry.restartOnFailure || await retry.restartOnFailure(e).catch((error40) => {
          logger2.error('Caught error when invoking user-provided "restartOnFailure" callback. Defaulting to restarting.', {
            error: error40.message || error40,
            cause: e.message || e,
            groupId
          });
          return true;
        }));
        instrumentationEmitter.emit(CRASH, {
          error: e,
          groupId,
          restart: shouldRestart
        });
        if (shouldRestart) {
          const retryTime = e.retryTime || retry && retry.initialRetryTime || initialRetryTime;
          logger2.error(`Restarting the consumer in ${retryTime}ms`, {
            retryCount: e.retryCount,
            retryTime,
            groupId
          });
          restartTimeout = setTimeout(() => start(onCrash), retryTime);
        }
      };
      await start(onCrash);
    };
    const on = (eventName, listener) => {
      if (!eventNames.includes(eventName)) {
        throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`);
      }
      return instrumentationEmitter.addListener(unwrapEvent(eventName), (event) => {
        event.type = wrapEvent(event.type);
        Promise.resolve(listener(event)).catch((e) => {
          logger2.error(`Failed to execute listener: ${e.message}`, {
            eventName,
            stack: e.stack
          });
        });
      });
    };
    const commitOffsets = async (topicPartitions = []) => {
      const commitsByTopic = topicPartitions.reduce((payload, { topic, partition, offset, metadata = null }) => {
        if (!topic) {
          throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
        }
        if (isNaN(partition)) {
          throw new KafkaJSNonRetriableError(`Invalid partition, expected a number received ${partition}`);
        }
        let commitOffset;
        try {
          commitOffset = Long.fromValue(offset);
        } catch (_) {
          throw new KafkaJSNonRetriableError(`Invalid offset, expected a long received ${offset}`);
        }
        if (commitOffset.lessThan(0)) {
          throw new KafkaJSNonRetriableError("Offset must not be a negative number");
        }
        if (metadata !== null && typeof metadata !== "string") {
          throw new KafkaJSNonRetriableError(`Invalid offset metadata, expected string or null, received ${metadata}`);
        }
        const topicCommits = payload[topic] || [];
        topicCommits.push({ partition, offset: commitOffset, metadata });
        return { ...payload, [topic]: topicCommits };
      }, {});
      if (!consumerGroup) {
        throw new KafkaJSNonRetriableError("Consumer group was not initialized, consumer#run must be called first");
      }
      const topics2 = Object.keys(commitsByTopic);
      return runner.commitOffsets({
        topics: topics2.map((topic) => {
          return {
            topic,
            partitions: commitsByTopic[topic]
          };
        })
      });
    };
    const seek = ({ topic, partition, offset }) => {
      if (!topic) {
        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
      }
      if (isNaN(partition)) {
        throw new KafkaJSNonRetriableError(`Invalid partition, expected a number received ${partition}`);
      }
      let seekOffset;
      try {
        seekOffset = Long.fromValue(offset);
      } catch (_) {
        throw new KafkaJSNonRetriableError(`Invalid offset, expected a long received ${offset}`);
      }
      if (seekOffset.lessThan(0) && !specialOffsets.includes(seekOffset.toString())) {
        throw new KafkaJSNonRetriableError("Offset must not be a negative number");
      }
      if (!consumerGroup) {
        throw new KafkaJSNonRetriableError("Consumer group was not initialized, consumer#run must be called first");
      }
      consumerGroup.seek({ topic, partition, offset: seekOffset.toString() });
    };
    const describeGroup = async () => {
      const coordinator = await cluster.findGroupCoordinator({ groupId });
      const retrier = createRetry(retry);
      return retrier(async () => {
        const { groups } = await coordinator.describeGroups({ groupIds: [groupId] });
        return groups.find((group) => group.groupId === groupId);
      });
    };
    const pause = (topicPartitions = []) => {
      for (const topicPartition of topicPartitions) {
        if (!topicPartition || !topicPartition.topic) {
          throw new KafkaJSNonRetriableError(`Invalid topic ${topicPartition && topicPartition.topic || topicPartition}`);
        } else if (typeof topicPartition.partitions !== "undefined" && (!Array.isArray(topicPartition.partitions) || topicPartition.partitions.some(isNaN))) {
          throw new KafkaJSNonRetriableError(`Array of valid partitions required to pause specific partitions instead of ${topicPartition.partitions}`);
        }
      }
      if (!consumerGroup) {
        throw new KafkaJSNonRetriableError("Consumer group was not initialized, consumer#run must be called first");
      }
      consumerGroup.pause(topicPartitions);
    };
    const paused = () => {
      if (!consumerGroup) {
        return [];
      }
      return consumerGroup.paused();
    };
    const resume = (topicPartitions = []) => {
      for (const topicPartition of topicPartitions) {
        if (!topicPartition || !topicPartition.topic) {
          throw new KafkaJSNonRetriableError(`Invalid topic ${topicPartition && topicPartition.topic || topicPartition}`);
        } else if (typeof topicPartition.partitions !== "undefined" && (!Array.isArray(topicPartition.partitions) || topicPartition.partitions.some(isNaN))) {
          throw new KafkaJSNonRetriableError(`Array of valid partitions required to resume specific partitions instead of ${topicPartition.partitions}`);
        }
      }
      if (!consumerGroup) {
        throw new KafkaJSNonRetriableError("Consumer group was not initialized, consumer#run must be called first");
      }
      consumerGroup.resume(topicPartitions);
    };
    const getLogger = () => logger2;
    return {
      connect,
      disconnect,
      subscribe,
      stop,
      run,
      commitOffsets,
      seek,
      describeGroup,
      pause,
      paused,
      resume,
      on,
      events,
      logger: getLogger
    };
  };
});

// node_modules/kafkajs/src/utils/waitFor.js
var require_waitFor = __commonJS((exports, module) => {
  var sleep = require_sleep();
  var { KafkaJSTimeout } = require_errors();
  module.exports = (fn, { delay = 50, maxWait = 1e4, timeoutMessage = "Timeout", ignoreTimeout = false } = {}) => {
    let timeoutId;
    let totalWait = 0;
    let fulfilled = false;
    const checkCondition = async (resolve, reject) => {
      totalWait += delay;
      if (fulfilled) {
        return;
      }
      await sleep(delay);
      try {
        const result = await fn(totalWait);
        if (result) {
          fulfilled = true;
          clearTimeout(timeoutId);
          return resolve(result);
        }
        checkCondition(resolve, reject);
      } catch (e) {
        fulfilled = true;
        clearTimeout(timeoutId);
        reject(e);
      }
    };
    return new Promise((resolve, reject) => {
      checkCondition(resolve, reject);
      if (ignoreTimeout) {
        return;
      }
      timeoutId = setTimeout(() => {
        if (!fulfilled) {
          fulfilled = true;
          return reject(new KafkaJSTimeout(timeoutMessage));
        }
      }, maxWait);
    });
  };
});

// node_modules/kafkajs/src/utils/groupBy.js
var require_groupBy = __commonJS((exports, module) => {
  module.exports = async (array2, groupFn) => {
    const result = new Map;
    for (const item of array2) {
      const group = await Promise.resolve(groupFn(item));
      result.set(group, result.has(group) ? [...result.get(group), item] : [item]);
    }
    return result;
  };
});

// node_modules/kafkajs/src/admin/instrumentationEvents.js
var require_instrumentationEvents4 = __commonJS((exports, module) => {
  var swapObject = require_swapObject();
  var networkEvents = require_instrumentationEvents();
  var InstrumentationEventType = require_eventType();
  var adminType = InstrumentationEventType("admin");
  var events = {
    CONNECT: adminType("connect"),
    DISCONNECT: adminType("disconnect"),
    REQUEST: adminType(networkEvents.NETWORK_REQUEST),
    REQUEST_TIMEOUT: adminType(networkEvents.NETWORK_REQUEST_TIMEOUT),
    REQUEST_QUEUE_SIZE: adminType(networkEvents.NETWORK_REQUEST_QUEUE_SIZE)
  };
  var wrappedEvents = {
    [events.REQUEST]: networkEvents.NETWORK_REQUEST,
    [events.REQUEST_TIMEOUT]: networkEvents.NETWORK_REQUEST_TIMEOUT,
    [events.REQUEST_QUEUE_SIZE]: networkEvents.NETWORK_REQUEST_QUEUE_SIZE
  };
  var reversedWrappedEvents = swapObject(wrappedEvents);
  var unwrap = (eventName) => wrappedEvents[eventName] || eventName;
  var wrap = (eventName) => reversedWrappedEvents[eventName] || eventName;
  module.exports = {
    events,
    wrap,
    unwrap
  };
});

// node_modules/kafkajs/src/protocol/aclResourceTypes.js
var require_aclResourceTypes = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    ANY: 1,
    TOPIC: 2,
    GROUP: 3,
    CLUSTER: 4,
    TRANSACTIONAL_ID: 5,
    DELEGATION_TOKEN: 6
  };
});

// node_modules/kafkajs/src/protocol/aclOperationTypes.js
var require_aclOperationTypes = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    ANY: 1,
    ALL: 2,
    READ: 3,
    WRITE: 4,
    CREATE: 5,
    DELETE: 6,
    ALTER: 7,
    DESCRIBE: 8,
    CLUSTER_ACTION: 9,
    DESCRIBE_CONFIGS: 10,
    ALTER_CONFIGS: 11,
    IDEMPOTENT_WRITE: 12
  };
});

// node_modules/kafkajs/src/protocol/aclPermissionTypes.js
var require_aclPermissionTypes = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    ANY: 1,
    DENY: 2,
    ALLOW: 3
  };
});

// node_modules/kafkajs/src/protocol/resourcePatternTypes.js
var require_resourcePatternTypes = __commonJS((exports, module) => {
  module.exports = {
    UNKNOWN: 0,
    ANY: 1,
    MATCH: 2,
    LITERAL: 3,
    PREFIXED: 4
  };
});

// node_modules/kafkajs/src/admin/index.js
var require_admin = __commonJS((exports, module) => {
  var createRetry = require_retry();
  var waitFor = require_waitFor();
  var groupBy = require_groupBy();
  var createConsumer = require_consumer();
  var InstrumentationEventEmitter = require_emitter();
  var { events, wrap: wrapEvent, unwrap: unwrapEvent } = require_instrumentationEvents4();
  var { LEVELS } = require_loggers();
  var {
    KafkaJSNonRetriableError,
    KafkaJSDeleteGroupsError,
    KafkaJSBrokerNotFound,
    KafkaJSDeleteTopicRecordsError,
    KafkaJSAggregateError
  } = require_errors();
  var { staleMetadata } = require_error();
  var CONFIG_RESOURCE_TYPES = require_configResourceTypes();
  var ACL_RESOURCE_TYPES = require_aclResourceTypes();
  var ACL_OPERATION_TYPES = require_aclOperationTypes();
  var ACL_PERMISSION_TYPES = require_aclPermissionTypes();
  var RESOURCE_PATTERN_TYPES = require_resourcePatternTypes();
  var { EARLIEST_OFFSET, LATEST_OFFSET } = require_constants();
  var { CONNECT, DISCONNECT } = events;
  var NO_CONTROLLER_ID = -1;
  var { values, keys, entries } = Object;
  var eventNames = values(events);
  var eventKeys = keys(events).map((key) => `admin.events.${key}`).join(", ");
  var retryOnLeaderNotAvailable = (fn, opts = {}) => {
    const callback = async () => {
      try {
        return await fn();
      } catch (e) {
        if (e.type !== "LEADER_NOT_AVAILABLE") {
          throw e;
        }
        return false;
      }
    };
    return waitFor(callback, opts);
  };
  var isConsumerGroupRunning = (description) => ["Empty", "Dead"].includes(description.state);
  var findTopicPartitions = async (cluster, topic) => {
    await cluster.addTargetTopic(topic);
    await cluster.refreshMetadataIfNecessary();
    return cluster.findTopicPartitionMetadata(topic).map(({ partitionId }) => partitionId).sort();
  };
  var indexByPartition = (array2) => array2.reduce((obj, { partition, ...props }) => Object.assign(obj, { [partition]: { ...props } }), {});
  module.exports = ({
    logger: rootLogger,
    instrumentationEmitter: rootInstrumentationEmitter,
    retry,
    cluster
  }) => {
    const logger2 = rootLogger.namespace("Admin");
    const instrumentationEmitter = rootInstrumentationEmitter || new InstrumentationEventEmitter;
    const connect = async () => {
      await cluster.connect();
      instrumentationEmitter.emit(CONNECT);
    };
    const disconnect = async () => {
      await cluster.disconnect();
      instrumentationEmitter.emit(DISCONNECT);
    };
    const listTopics = async () => {
      const { topicMetadata } = await cluster.metadata();
      const topics = topicMetadata.map((t) => t.topic);
      return topics;
    };
    const createTopics = async ({ topics, validateOnly, timeout, waitForLeaders = true }) => {
      if (!topics || !Array.isArray(topics)) {
        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);
      }
      if (topics.filter(({ topic }) => typeof topic !== "string").length > 0) {
        throw new KafkaJSNonRetriableError("Invalid topics array, the topic names have to be a valid string");
      }
      const topicNames = new Set(topics.map(({ topic }) => topic));
      if (topicNames.size < topics.length) {
        throw new KafkaJSNonRetriableError("Invalid topics array, it cannot have multiple entries for the same topic");
      }
      for (const { topic, configEntries } of topics) {
        if (configEntries == null) {
          continue;
        }
        if (!Array.isArray(configEntries)) {
          throw new KafkaJSNonRetriableError(`Invalid configEntries for topic "${topic}", must be an array`);
        }
        configEntries.forEach((entry, index) => {
          if (typeof entry !== "object" || entry == null) {
            throw new KafkaJSNonRetriableError(`Invalid configEntries for topic "${topic}". Entry ${index} must be an object`);
          }
          for (const requiredProperty of ["name", "value"]) {
            if (!Object.prototype.hasOwnProperty.call(entry, requiredProperty) || typeof entry[requiredProperty] !== "string") {
              throw new KafkaJSNonRetriableError(`Invalid configEntries for topic "${topic}". Entry ${index} must have a valid "${requiredProperty}" property`);
            }
          }
        });
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          await broker.createTopics({ topics, validateOnly, timeout });
          if (waitForLeaders) {
            const topicNamesArray = Array.from(topicNames.values());
            await retryOnLeaderNotAvailable(async () => await broker.metadata(topicNamesArray), {
              delay: 100,
              maxWait: timeout,
              timeoutMessage: "Timed out while waiting for topic leaders"
            });
          }
          return true;
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not create topics", { error: e.message, retryCount, retryTime });
            throw e;
          }
          if (e instanceof KafkaJSAggregateError) {
            if (e.errors.every((error40) => error40.type === "TOPIC_ALREADY_EXISTS")) {
              return false;
            }
          }
          bail(e);
        }
      });
    };
    const createPartitions = async ({ topicPartitions, validateOnly, timeout }) => {
      if (!topicPartitions || !Array.isArray(topicPartitions)) {
        throw new KafkaJSNonRetriableError(`Invalid topic partitions array ${topicPartitions}`);
      }
      if (topicPartitions.length === 0) {
        throw new KafkaJSNonRetriableError(`Empty topic partitions array`);
      }
      if (topicPartitions.filter(({ topic }) => typeof topic !== "string").length > 0) {
        throw new KafkaJSNonRetriableError("Invalid topic partitions array, the topic names have to be a valid string");
      }
      const topicNames = new Set(topicPartitions.map(({ topic }) => topic));
      if (topicNames.size < topicPartitions.length) {
        throw new KafkaJSNonRetriableError("Invalid topic partitions array, it cannot have multiple entries for the same topic");
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          await broker.createPartitions({ topicPartitions, validateOnly, timeout });
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not create topics", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const deleteTopics = async ({ topics, timeout }) => {
      if (!topics || !Array.isArray(topics)) {
        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);
      }
      if (topics.filter((topic) => typeof topic !== "string").length > 0) {
        throw new KafkaJSNonRetriableError("Invalid topics array, the names must be a valid string");
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          await broker.deleteTopics({ topics, timeout });
          for (const topic of topics) {
            cluster.targetTopics.delete(topic);
          }
          await cluster.refreshMetadata();
        } catch (e) {
          if (["NOT_CONTROLLER", "UNKNOWN_TOPIC_OR_PARTITION"].includes(e.type)) {
            logger2.warn("Could not delete topics", { error: e.message, retryCount, retryTime });
            throw e;
          }
          if (e.type === "REQUEST_TIMED_OUT") {
            logger2.error('Could not delete topics, check if "delete.topic.enable" is set to "true" (the default value is "false") or increase the timeout', {
              error: e.message,
              retryCount,
              retryTime
            });
          }
          bail(e);
        }
      });
    };
    const fetchTopicOffsets = async (topic) => {
      if (!topic || typeof topic !== "string") {
        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.addTargetTopic(topic);
          await cluster.refreshMetadataIfNecessary();
          const metadata = cluster.findTopicPartitionMetadata(topic);
          const high = await cluster.fetchTopicsOffset([
            {
              topic,
              fromBeginning: false,
              partitions: metadata.map((p) => ({ partition: p.partitionId }))
            }
          ]);
          const low = await cluster.fetchTopicsOffset([
            {
              topic,
              fromBeginning: true,
              partitions: metadata.map((p) => ({ partition: p.partitionId }))
            }
          ]);
          const { partitions: highPartitions } = high.pop();
          const { partitions: lowPartitions } = low.pop();
          return highPartitions.map(({ partition, offset }) => ({
            partition,
            offset,
            high: offset,
            low: lowPartitions.find(({ partition: lowPartition }) => lowPartition === partition).offset
          }));
        } catch (e) {
          if (e.type === "UNKNOWN_TOPIC_OR_PARTITION") {
            await cluster.refreshMetadata();
            throw e;
          }
          bail(e);
        }
      });
    };
    const fetchTopicOffsetsByTimestamp = async (topic, timestamp) => {
      if (!topic || typeof topic !== "string") {
        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.addTargetTopic(topic);
          await cluster.refreshMetadataIfNecessary();
          const metadata = cluster.findTopicPartitionMetadata(topic);
          const partitions = metadata.map((p) => ({ partition: p.partitionId }));
          const high = await cluster.fetchTopicsOffset([
            {
              topic,
              fromBeginning: false,
              partitions
            }
          ]);
          const { partitions: highPartitions } = high.pop();
          const offsets = await cluster.fetchTopicsOffset([
            {
              topic,
              fromTimestamp: timestamp,
              partitions
            }
          ]);
          const { partitions: lowPartitions } = offsets.pop();
          return lowPartitions.map(({ partition, offset }) => ({
            partition,
            offset: parseInt(offset, 10) >= 0 ? offset : highPartitions.find(({ partition: highPartition }) => highPartition === partition).offset
          }));
        } catch (e) {
          if (e.type === "UNKNOWN_TOPIC_OR_PARTITION") {
            await cluster.refreshMetadata();
            throw e;
          }
          bail(e);
        }
      });
    };
    const fetchOffsets = async ({ groupId, topics, resolveOffsets = false }) => {
      if (!groupId) {
        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);
      }
      if (!topics) {
        topics = [];
      }
      if (!Array.isArray(topics)) {
        throw new KafkaJSNonRetriableError("Expected topics array to be set");
      }
      const coordinator = await cluster.findGroupCoordinator({ groupId });
      const topicsToFetch = await Promise.all(topics.map(async (topic) => {
        const partitions = await findTopicPartitions(cluster, topic);
        const partitionsToFetch = partitions.map((partition) => ({ partition }));
        return { topic, partitions: partitionsToFetch };
      }));
      let { responses: consumerOffsets } = await coordinator.offsetFetch({
        groupId,
        topics: topicsToFetch
      });
      if (resolveOffsets) {
        consumerOffsets = await Promise.all(consumerOffsets.map(async ({ topic, partitions }) => {
          const indexedOffsets = indexByPartition(await fetchTopicOffsets(topic));
          const recalculatedPartitions = partitions.map(({ offset, partition, ...props }) => {
            let resolvedOffset = offset;
            if (Number(offset) === EARLIEST_OFFSET) {
              resolvedOffset = indexedOffsets[partition].low;
            }
            if (Number(offset) === LATEST_OFFSET) {
              resolvedOffset = indexedOffsets[partition].high;
            }
            return {
              partition,
              offset: resolvedOffset,
              ...props
            };
          });
          await setOffsets({ groupId, topic, partitions: recalculatedPartitions });
          return {
            topic,
            partitions: recalculatedPartitions
          };
        }));
      }
      return consumerOffsets.map(({ topic, partitions }) => {
        const completePartitions = partitions.map(({ partition, offset, metadata }) => ({
          partition,
          offset,
          metadata: metadata || null
        }));
        return { topic, partitions: completePartitions };
      });
    };
    const resetOffsets = async ({ groupId, topic, earliest = false }) => {
      if (!groupId) {
        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);
      }
      if (!topic) {
        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
      }
      const partitions = await findTopicPartitions(cluster, topic);
      const partitionsToSeek = partitions.map((partition) => ({
        partition,
        offset: cluster.defaultOffset({ fromBeginning: earliest })
      }));
      return setOffsets({ groupId, topic, partitions: partitionsToSeek });
    };
    const setOffsets = async ({ groupId, topic, partitions }) => {
      if (!groupId) {
        throw new KafkaJSNonRetriableError(`Invalid groupId ${groupId}`);
      }
      if (!topic) {
        throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
      }
      if (!partitions || partitions.length === 0) {
        throw new KafkaJSNonRetriableError(`Invalid partitions`);
      }
      const consumer = createConsumer({
        logger: rootLogger.namespace("Admin", LEVELS.NOTHING),
        cluster,
        groupId
      });
      await consumer.subscribe({ topic, fromBeginning: true });
      const description = await consumer.describeGroup();
      if (!isConsumerGroupRunning(description)) {
        throw new KafkaJSNonRetriableError(`The consumer group must have no running instances, current state: ${description.state}`);
      }
      return new Promise((resolve, reject) => {
        consumer.on(consumer.events.FETCH, async () => consumer.stop().then(resolve).catch(reject));
        consumer.run({
          eachBatchAutoResolve: false,
          eachBatch: async () => true
        }).catch(reject);
        consumer.pause([{ topic }]);
        for (const seekData of partitions) {
          consumer.seek({ topic, ...seekData });
        }
      });
    };
    const isBrokerConfig = (type) => [CONFIG_RESOURCE_TYPES.BROKER, CONFIG_RESOURCE_TYPES.BROKER_LOGGER].includes(type);
    const groupResourcesByBroker = ({ resources, defaultBroker }) => groupBy(resources, async ({ type, name: nodeId }) => {
      return isBrokerConfig(type) ? await cluster.findBroker({ nodeId: String(nodeId) }) : defaultBroker;
    });
    const describeConfigs = async ({ resources, includeSynonyms }) => {
      if (!resources || !Array.isArray(resources)) {
        throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);
      }
      if (resources.length === 0) {
        throw new KafkaJSNonRetriableError("Resources array cannot be empty");
      }
      const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);
      const invalidType = resources.find((r) => !validResourceTypes.includes(r.type));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);
      }
      const invalidName = resources.find((r) => !r.name || typeof r.name !== "string");
      if (invalidName) {
        throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);
      }
      const invalidConfigs = resources.find((r) => !Array.isArray(r.configNames) && r.configNames != null);
      if (invalidConfigs) {
        const { configNames } = invalidConfigs;
        throw new KafkaJSNonRetriableError(`Invalid resource configNames ${configNames}: ${JSON.stringify(invalidConfigs)}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const controller = await cluster.findControllerBroker();
          const resourcerByBroker = await groupResourcesByBroker({
            resources,
            defaultBroker: controller
          });
          const describeConfigsAction = async (broker) => {
            const targetBroker = broker || controller;
            return targetBroker.describeConfigs({
              resources: resourcerByBroker.get(targetBroker),
              includeSynonyms
            });
          };
          const brokers = Array.from(resourcerByBroker.keys());
          const responses = await Promise.all(brokers.map(describeConfigsAction));
          const responseResources = responses.reduce((result, { resources: resources2 }) => [...result, ...resources2], []);
          return { resources: responseResources };
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not describe configs", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const alterConfigs = async ({ resources, validateOnly }) => {
      if (!resources || !Array.isArray(resources)) {
        throw new KafkaJSNonRetriableError(`Invalid resources array ${resources}`);
      }
      if (resources.length === 0) {
        throw new KafkaJSNonRetriableError("Resources array cannot be empty");
      }
      const validResourceTypes = Object.values(CONFIG_RESOURCE_TYPES);
      const invalidType = resources.find((r) => !validResourceTypes.includes(r.type));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.type}: ${JSON.stringify(invalidType)}`);
      }
      const invalidName = resources.find((r) => !r.name || typeof r.name !== "string");
      if (invalidName) {
        throw new KafkaJSNonRetriableError(`Invalid resource name ${invalidName.name}: ${JSON.stringify(invalidName)}`);
      }
      const invalidConfigs = resources.find((r) => !Array.isArray(r.configEntries));
      if (invalidConfigs) {
        const { configEntries } = invalidConfigs;
        throw new KafkaJSNonRetriableError(`Invalid resource configEntries ${configEntries}: ${JSON.stringify(invalidConfigs)}`);
      }
      const invalidConfigValue = resources.find((r) => r.configEntries.some((e) => typeof e.name !== "string" || typeof e.value !== "string"));
      if (invalidConfigValue) {
        throw new KafkaJSNonRetriableError(`Invalid resource config value: ${JSON.stringify(invalidConfigValue)}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const controller = await cluster.findControllerBroker();
          const resourcerByBroker = await groupResourcesByBroker({
            resources,
            defaultBroker: controller
          });
          const alterConfigsAction = async (broker) => {
            const targetBroker = broker || controller;
            return targetBroker.alterConfigs({
              resources: resourcerByBroker.get(targetBroker),
              validateOnly: !!validateOnly
            });
          };
          const brokers = Array.from(resourcerByBroker.keys());
          const responses = await Promise.all(brokers.map(alterConfigsAction));
          const responseResources = responses.reduce((result, { resources: resources2 }) => [...result, ...resources2], []);
          return { resources: responseResources };
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not alter configs", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const fetchTopicMetadata = async ({ topics = [] } = {}) => {
      if (topics) {
        topics.forEach((topic) => {
          if (!topic || typeof topic !== "string") {
            throw new KafkaJSNonRetriableError(`Invalid topic ${topic}`);
          }
        });
      }
      const metadata = await cluster.metadata({ topics });
      return {
        topics: metadata.topicMetadata.map((topicMetadata) => ({
          name: topicMetadata.topic,
          partitions: topicMetadata.partitionMetadata
        }))
      };
    };
    const describeCluster = async () => {
      const { brokers: nodes, clusterId, controllerId } = await cluster.metadata({ topics: [] });
      const brokers = nodes.map(({ nodeId, host, port }) => ({
        nodeId,
        host,
        port
      }));
      const controller = controllerId == null || controllerId === NO_CONTROLLER_ID ? null : controllerId;
      return {
        brokers,
        controller,
        clusterId
      };
    };
    const listGroups = async () => {
      await cluster.refreshMetadata();
      let groups = [];
      for (var nodeId in cluster.brokerPool.brokers) {
        const broker = await cluster.findBroker({ nodeId });
        const response = await broker.listGroups();
        groups = groups.concat(response.groups);
      }
      return { groups };
    };
    const describeGroups = async (groupIds) => {
      const coordinatorsForGroup = await Promise.all(groupIds.map(async (groupId) => {
        const coordinator = await cluster.findGroupCoordinator({ groupId });
        return {
          coordinator,
          groupId
        };
      }));
      const groupsByCoordinator = Object.values(coordinatorsForGroup.reduce((coordinators, { coordinator, groupId }) => {
        const group = coordinators[coordinator.nodeId];
        if (group) {
          coordinators[coordinator.nodeId] = {
            ...group,
            groupIds: [...group.groupIds, groupId]
          };
        } else {
          coordinators[coordinator.nodeId] = { coordinator, groupIds: [groupId] };
        }
        return coordinators;
      }, {}));
      const responses = await Promise.all(groupsByCoordinator.map(async ({ coordinator, groupIds: groupIds2 }) => {
        const retrier = createRetry(retry);
        const { groups: groups2 } = await retrier(() => coordinator.describeGroups({ groupIds: groupIds2 }));
        return groups2;
      }));
      const groups = [].concat.apply([], responses);
      return { groups };
    };
    const deleteGroups = async (groupIds) => {
      if (!groupIds || !Array.isArray(groupIds)) {
        throw new KafkaJSNonRetriableError(`Invalid groupIds array ${groupIds}`);
      }
      const invalidGroupId = groupIds.some((g) => typeof g !== "string");
      if (invalidGroupId) {
        throw new KafkaJSNonRetriableError(`Invalid groupId name: ${JSON.stringify(invalidGroupId)}`);
      }
      const retrier = createRetry(retry);
      let results = [];
      let clonedGroupIds = groupIds.slice();
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          if (clonedGroupIds.length === 0)
            return [];
          await cluster.refreshMetadata();
          const brokersPerGroups = {};
          const brokersPerNode = {};
          for (const groupId of clonedGroupIds) {
            const broker = await cluster.findGroupCoordinator({ groupId });
            if (brokersPerGroups[broker.nodeId] === undefined)
              brokersPerGroups[broker.nodeId] = [];
            brokersPerGroups[broker.nodeId].push(groupId);
            brokersPerNode[broker.nodeId] = broker;
          }
          const res = await Promise.all(Object.keys(brokersPerNode).map(async (nodeId) => await brokersPerNode[nodeId].deleteGroups(brokersPerGroups[nodeId])));
          const errors3 = res.flatMap(({ results: results2 }) => results2.map(({ groupId, errorCode, error: error40 }) => {
            return { groupId, errorCode, error: error40 };
          })).filter(({ errorCode }) => errorCode !== 0);
          clonedGroupIds = errors3.map(({ groupId }) => groupId);
          if (errors3.length > 0)
            throw new KafkaJSDeleteGroupsError("Error in DeleteGroups", errors3);
          results = res.flatMap(({ results: results2 }) => results2);
          return results;
        } catch (e) {
          if (e.type === "NOT_CONTROLLER" || e.type === "COORDINATOR_NOT_AVAILABLE") {
            logger2.warn("Could not delete groups", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const deleteTopicRecords = async ({ topic, partitions }) => {
      if (!topic || typeof topic !== "string") {
        throw new KafkaJSNonRetriableError(`Invalid topic "${topic}"`);
      }
      if (!partitions || partitions.length === 0) {
        throw new KafkaJSNonRetriableError(`Invalid partitions`);
      }
      const partitionsByBroker = cluster.findLeaderForPartitions(topic, partitions.map((p) => p.partition));
      const partitionsFound = values(partitionsByBroker).flat();
      const topicOffsets = await fetchTopicOffsets(topic);
      const leaderNotFoundErrors = [];
      partitions.forEach(({ partition, offset }) => {
        if (!partitionsFound.includes(partition)) {
          leaderNotFoundErrors.push({
            partition,
            offset,
            error: new KafkaJSBrokerNotFound("Could not find the leader for the partition", {
              retriable: false
            })
          });
          return;
        }
        const { low } = topicOffsets.find((p) => p.partition === partition) || {
          high: undefined,
          low: undefined
        };
        if (parseInt(offset) < parseInt(low) && parseInt(offset) !== -1) {
          logger2.warn("The requested offset is before the earliest offset maintained on the partition - no records will be deleted from this partition", {
            topic,
            partition,
            offset
          });
        }
      });
      if (leaderNotFoundErrors.length > 0) {
        throw new KafkaJSDeleteTopicRecordsError({ topic, partitions: leaderNotFoundErrors });
      }
      const seekEntriesByBroker = entries(partitionsByBroker).reduce((obj, [nodeId, nodePartitions]) => {
        obj[nodeId] = {
          topic,
          partitions: partitions.filter((p) => nodePartitions.includes(p.partition))
        };
        return obj;
      }, {});
      const retrier = createRetry(retry);
      return retrier(async (bail) => {
        try {
          const partitionErrors = [];
          const brokerRequests = entries(seekEntriesByBroker).map(([nodeId, { topic: topic2, partitions: partitions2 }]) => async () => {
            const broker = await cluster.findBroker({ nodeId });
            await broker.deleteRecords({ topics: [{ topic: topic2, partitions: partitions2 }] });
            delete seekEntriesByBroker[nodeId];
          });
          await Promise.all(brokerRequests.map((request) => request().catch((e) => {
            if (e.name === "KafkaJSDeleteTopicRecordsError") {
              e.partitions.forEach(({ partition, offset, error: error40 }) => {
                partitionErrors.push({
                  partition,
                  offset,
                  error: error40
                });
              });
            } else {
              throw e;
            }
          })));
          if (partitionErrors.length > 0) {
            throw new KafkaJSDeleteTopicRecordsError({
              topic,
              partitions: partitionErrors
            });
          }
        } catch (e) {
          if (e.retriable && e.partitions.some(({ error: error40 }) => staleMetadata(error40) || error40.name === "KafkaJSMetadataNotLoaded")) {
            await cluster.refreshMetadata();
          }
          throw e;
        }
      });
    };
    const createAcls = async ({ acl }) => {
      if (!acl || !Array.isArray(acl)) {
        throw new KafkaJSNonRetriableError(`Invalid ACL array ${acl}`);
      }
      if (acl.length === 0) {
        throw new KafkaJSNonRetriableError("Empty ACL array");
      }
      if (acl.some(({ principal }) => typeof principal !== "string")) {
        throw new KafkaJSNonRetriableError("Invalid ACL array, the principals have to be a valid string");
      }
      if (acl.some(({ host }) => typeof host !== "string")) {
        throw new KafkaJSNonRetriableError("Invalid ACL array, the hosts have to be a valid string");
      }
      if (acl.some(({ resourceName }) => typeof resourceName !== "string")) {
        throw new KafkaJSNonRetriableError("Invalid ACL array, the resourceNames have to be a valid string");
      }
      let invalidType;
      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
      invalidType = acl.find((i) => !validOperationTypes.includes(i.operation));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);
      }
      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
      invalidType = acl.find((i) => !validResourcePatternTypes.includes(i.resourcePatternType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);
      }
      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
      invalidType = acl.find((i) => !validPermissionTypes.includes(i.permissionType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);
      }
      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
      invalidType = acl.find((i) => !validResourceTypes.includes(i.resourceType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          await broker.createAcls({ acl });
          return true;
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not create ACL", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const describeAcls = async ({
      resourceType,
      resourceName,
      resourcePatternType,
      principal,
      host,
      operation,
      permissionType
    }) => {
      if (typeof principal !== "string" && typeof principal !== "undefined") {
        throw new KafkaJSNonRetriableError("Invalid principal, the principal have to be a valid string");
      }
      if (typeof host !== "string" && typeof host !== "undefined") {
        throw new KafkaJSNonRetriableError("Invalid host, the host have to be a valid string");
      }
      if (typeof resourceName !== "string" && typeof resourceName !== "undefined") {
        throw new KafkaJSNonRetriableError("Invalid resourceName, the resourceName have to be a valid string");
      }
      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
      if (!validOperationTypes.includes(operation)) {
        throw new KafkaJSNonRetriableError(`Invalid operation type ${operation}`);
      }
      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
      if (!validResourcePatternTypes.includes(resourcePatternType)) {
        throw new KafkaJSNonRetriableError(`Invalid resource pattern filter type ${resourcePatternType}`);
      }
      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
      if (!validPermissionTypes.includes(permissionType)) {
        throw new KafkaJSNonRetriableError(`Invalid permission type ${permissionType}`);
      }
      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
      if (!validResourceTypes.includes(resourceType)) {
        throw new KafkaJSNonRetriableError(`Invalid resource type ${resourceType}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          const { resources } = await broker.describeAcls({
            resourceType,
            resourceName,
            resourcePatternType,
            principal,
            host,
            operation,
            permissionType
          });
          return { resources };
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not describe ACL", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const deleteAcls = async ({ filters }) => {
      if (!filters || !Array.isArray(filters)) {
        throw new KafkaJSNonRetriableError(`Invalid ACL Filter array ${filters}`);
      }
      if (filters.length === 0) {
        throw new KafkaJSNonRetriableError("Empty ACL Filter array");
      }
      if (filters.some(({ principal }) => typeof principal !== "string" && typeof principal !== "undefined")) {
        throw new KafkaJSNonRetriableError("Invalid ACL Filter array, the principals have to be a valid string");
      }
      if (filters.some(({ host }) => typeof host !== "string" && typeof host !== "undefined")) {
        throw new KafkaJSNonRetriableError("Invalid ACL Filter array, the hosts have to be a valid string");
      }
      if (filters.some(({ resourceName }) => typeof resourceName !== "string" && typeof resourceName !== "undefined")) {
        throw new KafkaJSNonRetriableError("Invalid ACL Filter array, the resourceNames have to be a valid string");
      }
      let invalidType;
      const validOperationTypes = Object.values(ACL_OPERATION_TYPES);
      invalidType = filters.find((i) => !validOperationTypes.includes(i.operation));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid operation type ${invalidType.operation}: ${JSON.stringify(invalidType)}`);
      }
      const validResourcePatternTypes = Object.values(RESOURCE_PATTERN_TYPES);
      invalidType = filters.find((i) => !validResourcePatternTypes.includes(i.resourcePatternType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource pattern type ${invalidType.resourcePatternType}: ${JSON.stringify(invalidType)}`);
      }
      const validPermissionTypes = Object.values(ACL_PERMISSION_TYPES);
      invalidType = filters.find((i) => !validPermissionTypes.includes(i.permissionType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid permission type ${invalidType.permissionType}: ${JSON.stringify(invalidType)}`);
      }
      const validResourceTypes = Object.values(ACL_RESOURCE_TYPES);
      invalidType = filters.find((i) => !validResourceTypes.includes(i.resourceType));
      if (invalidType) {
        throw new KafkaJSNonRetriableError(`Invalid resource type ${invalidType.resourceType}: ${JSON.stringify(invalidType)}`);
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          const { filterResponses } = await broker.deleteAcls({ filters });
          return { filterResponses };
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not delete ACL", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const alterPartitionReassignments = async ({ topics, timeout }) => {
      if (!topics || !Array.isArray(topics)) {
        throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);
      }
      if (topics.filter(({ topic }) => typeof topic !== "string").length > 0) {
        throw new KafkaJSNonRetriableError("Invalid topics array, the topic names have to be a valid string");
      }
      const topicNames = new Set(topics.map(({ topic }) => topic));
      if (topicNames.size < topics.length) {
        throw new KafkaJSNonRetriableError("Invalid topics array, it cannot have multiple entries for the same topic");
      }
      for (const { topic, partitionAssignment } of topics) {
        if (!partitionAssignment || !Array.isArray(partitionAssignment)) {
          throw new KafkaJSNonRetriableError(`Invalid partitions array: ${partitionAssignment} for topic: ${topic}`);
        }
        for (const { partition, replicas } of partitionAssignment) {
          if (partition === null || partition === undefined || typeof partition !== "number" || partition < 0) {
            throw new KafkaJSNonRetriableError(`Invalid partitions index: ${partition} for topic: ${topic}`);
          }
          if (!replicas || !Array.isArray(replicas)) {
            throw new KafkaJSNonRetriableError(`Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}`);
          }
          if (replicas.filter((replica) => typeof replica !== "number" || replica < 0).length >= 1) {
            throw new KafkaJSNonRetriableError(`Invalid replica assignment: ${replicas} for topic: ${topic} on partition: ${partition}. Replicas must be a non negative number`);
          }
        }
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          await broker.alterPartitionReassignments({ topics, timeout });
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not reassign partitions", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const listPartitionReassignments = async ({ topics = null, timeout }) => {
      if (topics) {
        if (!Array.isArray(topics)) {
          throw new KafkaJSNonRetriableError(`Invalid topics array ${topics}`);
        }
        if (topics.filter(({ topic }) => typeof topic !== "string").length > 0) {
          throw new KafkaJSNonRetriableError("Invalid topics array, the topic names have to be a valid string");
        }
        const topicNames = new Set(topics.map(({ topic }) => topic));
        if (topicNames.size < topics.length) {
          throw new KafkaJSNonRetriableError("Invalid topics array, it cannot have multiple entries for the same topic");
        }
        for (const { topic, partitions } of topics) {
          if (!partitions || !Array.isArray(partitions)) {
            throw new KafkaJSNonRetriableError(`Invalid partition array: ${partitions} for topic: ${topic}`);
          }
          if (partitions.filter((partition) => typeof partition !== "number" || partition < 0).length >= 1) {
            throw new KafkaJSNonRetriableError(`Invalid partition array: ${partitions} for topic: ${topic}. The partition indices have to be a valid number greater than 0.`);
          }
        }
      }
      const retrier = createRetry(retry);
      return retrier(async (bail, retryCount, retryTime) => {
        try {
          await cluster.refreshMetadata();
          const broker = await cluster.findControllerBroker();
          const response = await broker.listPartitionReassignments({ topics, timeout });
          return { topics: response.topics };
        } catch (e) {
          if (e.type === "NOT_CONTROLLER") {
            logger2.warn("Could not reassign partitions", { error: e.message, retryCount, retryTime });
            throw e;
          }
          bail(e);
        }
      });
    };
    const on = (eventName, listener) => {
      if (!eventNames.includes(eventName)) {
        throw new KafkaJSNonRetriableError(`Event name should be one of ${eventKeys}`);
      }
      return instrumentationEmitter.addListener(unwrapEvent(eventName), (event) => {
        event.type = wrapEvent(event.type);
        Promise.resolve(listener(event)).catch((e) => {
          logger2.error(`Failed to execute listener: ${e.message}`, {
            eventName,
            stack: e.stack
          });
        });
      });
    };
    const getLogger = () => logger2;
    return {
      connect,
      disconnect,
      listTopics,
      createTopics,
      deleteTopics,
      createPartitions,
      fetchTopicMetadata,
      describeCluster,
      events,
      fetchOffsets,
      fetchTopicOffsets,
      fetchTopicOffsetsByTimestamp,
      setOffsets,
      resetOffsets,
      describeConfigs,
      alterConfigs,
      on,
      logger: getLogger,
      listGroups,
      describeGroups,
      deleteGroups,
      describeAcls,
      deleteAcls,
      createAcls,
      deleteTopicRecords,
      alterPartitionReassignments,
      listPartitionReassignments
    };
  };
});

// node_modules/kafkajs/src/network/socketFactory.js
var require_socketFactory = __commonJS((exports, module) => {
  var KEEP_ALIVE_DELAY = 60000;
  module.exports = () => {
    const net = __require("net");
    const tls = __require("tls");
    return ({ host, port, ssl, onConnect }) => {
      const socket = ssl ? tls.connect(Object.assign({ host, port }, !net.isIP(host) ? { servername: host } : {}, ssl), onConnect) : net.connect({ host, port }, onConnect);
      socket.setKeepAlive(true, KEEP_ALIVE_DELAY);
      return socket;
    };
  };
});

// node_modules/kafkajs/src/utils/once.js
var require_once = __commonJS((exports, module) => {
  module.exports = (fn) => {
    let called = false;
    return (...args) => {
      if (!called) {
        called = true;
        return fn(...args);
      }
    };
  };
});

// node_modules/kafkajs/src/index.js
var require_src = __commonJS((exports, module) => {
  var {
    createLogger,
    LEVELS: { INFO }
  } = require_loggers();
  var InstrumentationEventEmitter = require_emitter();
  var LoggerConsole = require_console();
  var Cluster = require_cluster();
  var createProducer = require_producer();
  var createConsumer = require_consumer();
  var createAdmin = require_admin();
  var ISOLATION_LEVEL = require_isolationLevel();
  var defaultSocketFactory = require_socketFactory();
  var once = require_once();
  var websiteUrl = require_websiteUrl();
  var PRIVATE = {
    CREATE_CLUSTER: Symbol("private:Kafka:createCluster"),
    CLUSTER_RETRY: Symbol("private:Kafka:clusterRetry"),
    LOGGER: Symbol("private:Kafka:logger"),
    OFFSETS: Symbol("private:Kafka:offsets")
  };
  var DEFAULT_METADATA_MAX_AGE = 300000;
  var warnOfDefaultPartitioner = once((logger2) => {
    if (process.env.KAFKAJS_NO_PARTITIONER_WARNING == null) {
      logger2.warn(`KafkaJS v2.0.0 switched default partitioner. To retain the same partitioning behavior as in previous versions, create the producer with the option "createPartitioner: Partitioners.LegacyPartitioner". See the migration guide at ${websiteUrl("docs/migration-guide-v2.0.0", "producer-new-default-partitioner")} for details. Silence this warning by setting the environment variable "KAFKAJS_NO_PARTITIONER_WARNING=1"`);
    }
  });
  module.exports = class Client {
    constructor({
      brokers,
      ssl,
      sasl,
      clientId,
      connectionTimeout = 1000,
      authenticationTimeout,
      reauthenticationThreshold,
      requestTimeout,
      enforceRequestTimeout = true,
      retry,
      socketFactory = defaultSocketFactory(),
      logLevel = INFO,
      logCreator = LoggerConsole
    }) {
      this[PRIVATE.OFFSETS] = new Map;
      this[PRIVATE.LOGGER] = createLogger({ level: logLevel, logCreator });
      this[PRIVATE.CLUSTER_RETRY] = retry;
      this[PRIVATE.CREATE_CLUSTER] = ({
        metadataMaxAge,
        allowAutoTopicCreation = true,
        maxInFlightRequests = null,
        instrumentationEmitter = null,
        isolationLevel
      }) => new Cluster({
        logger: this[PRIVATE.LOGGER],
        retry: this[PRIVATE.CLUSTER_RETRY],
        offsets: this[PRIVATE.OFFSETS],
        socketFactory,
        brokers,
        ssl,
        sasl,
        clientId,
        connectionTimeout,
        authenticationTimeout,
        reauthenticationThreshold,
        requestTimeout,
        enforceRequestTimeout,
        metadataMaxAge,
        instrumentationEmitter,
        allowAutoTopicCreation,
        maxInFlightRequests,
        isolationLevel
      });
    }
    producer({
      createPartitioner,
      retry,
      metadataMaxAge = DEFAULT_METADATA_MAX_AGE,
      allowAutoTopicCreation,
      idempotent,
      transactionalId,
      transactionTimeout,
      maxInFlightRequests
    } = {}) {
      const instrumentationEmitter = new InstrumentationEventEmitter;
      const cluster = this[PRIVATE.CREATE_CLUSTER]({
        metadataMaxAge,
        allowAutoTopicCreation,
        maxInFlightRequests,
        instrumentationEmitter
      });
      if (createPartitioner == null) {
        warnOfDefaultPartitioner(this[PRIVATE.LOGGER]);
      }
      return createProducer({
        retry: { ...this[PRIVATE.CLUSTER_RETRY], ...retry },
        logger: this[PRIVATE.LOGGER],
        cluster,
        createPartitioner,
        idempotent,
        transactionalId,
        transactionTimeout,
        instrumentationEmitter
      });
    }
    consumer({
      groupId,
      partitionAssigners,
      metadataMaxAge = DEFAULT_METADATA_MAX_AGE,
      sessionTimeout,
      rebalanceTimeout,
      heartbeatInterval,
      maxBytesPerPartition,
      minBytes,
      maxBytes,
      maxWaitTimeInMs,
      retry = { retries: 5 },
      allowAutoTopicCreation,
      maxInFlightRequests,
      readUncommitted = false,
      rackId = ""
    } = {}) {
      const isolationLevel = readUncommitted ? ISOLATION_LEVEL.READ_UNCOMMITTED : ISOLATION_LEVEL.READ_COMMITTED;
      const instrumentationEmitter = new InstrumentationEventEmitter;
      const cluster = this[PRIVATE.CREATE_CLUSTER]({
        metadataMaxAge,
        allowAutoTopicCreation,
        maxInFlightRequests,
        isolationLevel,
        instrumentationEmitter
      });
      return createConsumer({
        retry: { ...this[PRIVATE.CLUSTER_RETRY], ...retry },
        logger: this[PRIVATE.LOGGER],
        cluster,
        groupId,
        partitionAssigners,
        sessionTimeout,
        rebalanceTimeout,
        heartbeatInterval,
        maxBytesPerPartition,
        minBytes,
        maxBytes,
        maxWaitTimeInMs,
        isolationLevel,
        instrumentationEmitter,
        rackId,
        metadataMaxAge
      });
    }
    admin({ retry } = {}) {
      const instrumentationEmitter = new InstrumentationEventEmitter;
      const cluster = this[PRIVATE.CREATE_CLUSTER]({
        allowAutoTopicCreation: false,
        instrumentationEmitter
      });
      return createAdmin({
        retry: { ...this[PRIVATE.CLUSTER_RETRY], ...retry },
        logger: this[PRIVATE.LOGGER],
        instrumentationEmitter,
        cluster
      });
    }
    logger() {
      return this[PRIVATE.LOGGER];
    }
  };
});

// node_modules/kafkajs/index.js
var require_kafkajs = __commonJS((exports, module) => {
  var Kafka = require_src();
  var PartitionAssigners = require_assigners();
  var AssignerProtocol = require_assignerProtocol();
  var Partitioners = require_partitioners();
  var Compression = require_compression();
  var ConfigResourceTypes = require_configResourceTypes();
  var ConfigSource = require_configSource();
  var AclResourceTypes = require_aclResourceTypes();
  var AclOperationTypes = require_aclOperationTypes();
  var AclPermissionTypes = require_aclPermissionTypes();
  var ResourcePatternTypes = require_resourcePatternTypes();
  var { isRebalancing, isKafkaJSError, ...errors3 } = require_errors();
  var { LEVELS } = require_loggers();
  module.exports = {
    Kafka,
    PartitionAssigners,
    AssignerProtocol,
    Partitioners,
    logLevel: LEVELS,
    CompressionTypes: Compression.Types,
    CompressionCodecs: Compression.Codecs,
    ConfigResourceTypes,
    AclResourceTypes,
    AclOperationTypes,
    AclPermissionTypes,
    ResourcePatternTypes,
    ConfigSource,
    ...errors3
  };
});

// node_modules/@redis/client/dist/lib/RESP/verbatim-string.js
var require_verbatim_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VerbatimString = undefined;

  class VerbatimString extends String {
    format;
    constructor(format, value) {
      super(value);
      this.format = format;
    }
  }
  exports.VerbatimString = VerbatimString;
});

// node_modules/@redis/client/dist/lib/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MultiErrorReply = exports.TimeoutError = exports.BlobError = exports.SimpleError = exports.ErrorReply = exports.ReconnectStrategyError = exports.RootNodesUnavailableError = exports.SocketClosedUnexpectedlyError = exports.DisconnectsClientError = exports.ClientOfflineError = exports.ClientClosedError = exports.SocketTimeoutError = exports.ConnectionTimeoutError = exports.WatchError = exports.AbortError = undefined;

  class AbortError extends Error {
    constructor() {
      super("The command was aborted");
    }
  }
  exports.AbortError = AbortError;

  class WatchError extends Error {
    constructor(message = "One (or more) of the watched keys has been changed") {
      super(message);
    }
  }
  exports.WatchError = WatchError;

  class ConnectionTimeoutError extends Error {
    constructor() {
      super("Connection timeout");
    }
  }
  exports.ConnectionTimeoutError = ConnectionTimeoutError;

  class SocketTimeoutError extends Error {
    constructor(timeout) {
      super(`Socket timeout timeout. Expecting data, but didn't receive any in ${timeout}ms.`);
    }
  }
  exports.SocketTimeoutError = SocketTimeoutError;

  class ClientClosedError extends Error {
    constructor() {
      super("The client is closed");
    }
  }
  exports.ClientClosedError = ClientClosedError;

  class ClientOfflineError extends Error {
    constructor() {
      super("The client is offline");
    }
  }
  exports.ClientOfflineError = ClientOfflineError;

  class DisconnectsClientError extends Error {
    constructor() {
      super("Disconnects client");
    }
  }
  exports.DisconnectsClientError = DisconnectsClientError;

  class SocketClosedUnexpectedlyError extends Error {
    constructor() {
      super("Socket closed unexpectedly");
    }
  }
  exports.SocketClosedUnexpectedlyError = SocketClosedUnexpectedlyError;

  class RootNodesUnavailableError extends Error {
    constructor() {
      super("All the root nodes are unavailable");
    }
  }
  exports.RootNodesUnavailableError = RootNodesUnavailableError;

  class ReconnectStrategyError extends Error {
    originalError;
    socketError;
    constructor(originalError, socketError) {
      super(originalError.message);
      this.originalError = originalError;
      this.socketError = socketError;
    }
  }
  exports.ReconnectStrategyError = ReconnectStrategyError;

  class ErrorReply extends Error {
    constructor(message) {
      super(message);
      this.stack = undefined;
    }
  }
  exports.ErrorReply = ErrorReply;

  class SimpleError extends ErrorReply {
  }
  exports.SimpleError = SimpleError;

  class BlobError extends ErrorReply {
  }
  exports.BlobError = BlobError;

  class TimeoutError extends Error {
  }
  exports.TimeoutError = TimeoutError;

  class MultiErrorReply extends ErrorReply {
    replies;
    errorIndexes;
    constructor(replies, errorIndexes) {
      super(`${errorIndexes.length} commands failed, see .replies and .errorIndexes for more information`);
      this.replies = replies;
      this.errorIndexes = errorIndexes;
    }
    *errors() {
      for (const index of this.errorIndexes) {
        yield this.replies[index];
      }
    }
  }
  exports.MultiErrorReply = MultiErrorReply;
});

// node_modules/@redis/client/dist/lib/RESP/decoder.js
var require_decoder9 = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Decoder = exports.PUSH_TYPE_MAPPING = exports.RESP_TYPES = undefined;
  var verbatim_string_1 = require_verbatim_string();
  var errors_1 = require_errors2();
  exports.RESP_TYPES = {
    NULL: 95,
    BOOLEAN: 35,
    NUMBER: 58,
    BIG_NUMBER: 40,
    DOUBLE: 44,
    SIMPLE_STRING: 43,
    BLOB_STRING: 36,
    VERBATIM_STRING: 61,
    SIMPLE_ERROR: 45,
    BLOB_ERROR: 33,
    ARRAY: 42,
    SET: 126,
    MAP: 37,
    PUSH: 62
  };
  var ASCII = {
    "\r": 13,
    t: 116,
    "+": 43,
    "-": 45,
    "0": 48,
    ".": 46,
    i: 105,
    n: 110,
    E: 69,
    e: 101
  };
  exports.PUSH_TYPE_MAPPING = {
    [exports.RESP_TYPES.BLOB_STRING]: Buffer
  };

  class Decoder {
    onReply;
    onErrorReply;
    onPush;
    getTypeMapping;
    #cursor = 0;
    #next;
    constructor(config2) {
      this.onReply = config2.onReply;
      this.onErrorReply = config2.onErrorReply;
      this.onPush = config2.onPush;
      this.getTypeMapping = config2.getTypeMapping;
    }
    reset() {
      this.#cursor = 0;
      this.#next = undefined;
    }
    write(chunk) {
      if (this.#cursor >= chunk.length) {
        this.#cursor -= chunk.length;
        return;
      }
      if (this.#next) {
        if (this.#next(chunk) || this.#cursor >= chunk.length) {
          this.#cursor -= chunk.length;
          return;
        }
      }
      do {
        const type = chunk[this.#cursor];
        if (++this.#cursor === chunk.length) {
          this.#next = this.#continueDecodeTypeValue.bind(this, type);
          break;
        }
        if (this.#decodeTypeValue(type, chunk)) {
          break;
        }
      } while (this.#cursor < chunk.length);
      this.#cursor -= chunk.length;
    }
    #continueDecodeTypeValue(type, chunk) {
      this.#next = undefined;
      return this.#decodeTypeValue(type, chunk);
    }
    #decodeTypeValue(type, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          this.onReply(this.#decodeNull());
          return false;
        case exports.RESP_TYPES.BOOLEAN:
          return this.#handleDecodedValue(this.onReply, this.#decodeBoolean(chunk));
        case exports.RESP_TYPES.NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeNumber(this.getTypeMapping()[exports.RESP_TYPES.NUMBER], chunk));
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#handleDecodedValue(this.onReply, this.#decodeBigNumber(this.getTypeMapping()[exports.RESP_TYPES.BIG_NUMBER], chunk));
        case exports.RESP_TYPES.DOUBLE:
          return this.#handleDecodedValue(this.onReply, this.#decodeDouble(this.getTypeMapping()[exports.RESP_TYPES.DOUBLE], chunk));
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeSimpleString(this.getTypeMapping()[exports.RESP_TYPES.SIMPLE_STRING], chunk));
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeBlobString(this.getTypeMapping()[exports.RESP_TYPES.BLOB_STRING], chunk));
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#handleDecodedValue(this.onReply, this.#decodeVerbatimString(this.getTypeMapping()[exports.RESP_TYPES.VERBATIM_STRING], chunk));
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeSimpleError(chunk));
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#handleDecodedValue(this.onErrorReply, this.#decodeBlobError(chunk));
        case exports.RESP_TYPES.ARRAY:
          return this.#handleDecodedValue(this.onReply, this.#decodeArray(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.SET:
          return this.#handleDecodedValue(this.onReply, this.#decodeSet(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.MAP:
          return this.#handleDecodedValue(this.onReply, this.#decodeMap(this.getTypeMapping(), chunk));
        case exports.RESP_TYPES.PUSH:
          return this.#handleDecodedValue(this.onPush, this.#decodeArray(exports.PUSH_TYPE_MAPPING, chunk));
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #handleDecodedValue(cb, value) {
      if (typeof value === "function") {
        this.#next = this.#continueDecodeValue.bind(this, cb, value);
        return true;
      }
      cb(value);
      return false;
    }
    #continueDecodeValue(cb, next, chunk) {
      this.#next = undefined;
      return this.#handleDecodedValue(cb, next(chunk));
    }
    #decodeNull() {
      this.#cursor += 2;
      return null;
    }
    #decodeBoolean(chunk) {
      const boolean4 = chunk[this.#cursor] === ASCII.t;
      this.#cursor += 3;
      return boolean4;
    }
    #decodeNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeNumberValue(true, chunk);
        default:
          return this.#decodeNumberValue(false, this.#decodeUnsingedNumber.bind(this, 0), chunk);
      }
    }
    #maybeDecodeNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedNumber.bind(this, 0);
      return ++this.#cursor === chunk.length ? this.#decodeNumberValue.bind(this, isNegative, cb) : this.#decodeNumberValue(isNegative, cb, chunk);
    }
    #decodeNumberValue(isNegative, numberCb, chunk) {
      const number4 = numberCb(chunk);
      return typeof number4 === "function" ? this.#decodeNumberValue.bind(this, isNegative, number4) : isNegative ? -number4 : number4;
    }
    #decodeUnsingedNumber(number4, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return number4;
        }
        number4 = number4 * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedNumber.bind(this, number4);
    }
    #decodeBigNumber(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return this.#maybeDecodeBigNumberValue(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeBigNumberValue(true, chunk);
        default:
          return this.#decodeBigNumberValue(false, this.#decodeUnsingedBigNumber.bind(this, 0n), chunk);
      }
    }
    #maybeDecodeBigNumberValue(isNegative, chunk) {
      const cb = this.#decodeUnsingedBigNumber.bind(this, 0n);
      return ++this.#cursor === chunk.length ? this.#decodeBigNumberValue.bind(this, isNegative, cb) : this.#decodeBigNumberValue(isNegative, cb, chunk);
    }
    #decodeBigNumberValue(isNegative, bigNumberCb, chunk) {
      const bigNumber = bigNumberCb(chunk);
      return typeof bigNumber === "function" ? this.#decodeBigNumberValue.bind(this, isNegative, bigNumber) : isNegative ? -bigNumber : bigNumber;
    }
    #decodeUnsingedBigNumber(bigNumber, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return bigNumber;
        }
        bigNumber = bigNumber * 10n + BigInt(byte - ASCII["0"]);
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeUnsingedBigNumber.bind(this, bigNumber);
    }
    #decodeDouble(type, chunk) {
      if (type === String) {
        return this.#decodeSimpleString(String, chunk);
      }
      switch (chunk[this.#cursor]) {
        case ASCII.n:
          this.#cursor += 5;
          return NaN;
        case ASCII["+"]:
          return this.#maybeDecodeDoubleInteger(false, chunk);
        case ASCII["-"]:
          return this.#maybeDecodeDoubleInteger(true, chunk);
        default:
          return this.#decodeDoubleInteger(false, 0, chunk);
      }
    }
    #maybeDecodeDoubleInteger(isNegative, chunk) {
      return ++this.#cursor === chunk.length ? this.#decodeDoubleInteger.bind(this, isNegative, 0) : this.#decodeDoubleInteger(isNegative, 0, chunk);
    }
    #decodeDoubleInteger(isNegative, integer2, chunk) {
      if (chunk[this.#cursor] === ASCII.i) {
        this.#cursor += 5;
        return isNegative ? -Infinity : Infinity;
      }
      return this.#continueDecodeDoubleInteger(isNegative, integer2, chunk);
    }
    #continueDecodeDoubleInteger(isNegative, integer2, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII["."]:
            this.#cursor = cursor + 1;
            return this.#cursor < chunk.length ? this.#decodeDoubleDecimal(isNegative, 0, integer2, chunk) : this.#decodeDoubleDecimal.bind(this, isNegative, 0, integer2);
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const i = isNegative ? -integer2 : integer2;
            return this.#cursor < chunk.length ? this.#decodeDoubleExponent(i, chunk) : this.#decodeDoubleExponent.bind(this, i);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -integer2 : integer2;
          default:
            integer2 = integer2 * 10 + byte - ASCII["0"];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleInteger.bind(this, isNegative, integer2);
    }
    static #DOUBLE_DECIMAL_MULTIPLIERS = [
      0.1,
      0.01,
      0.001,
      0.0001,
      0.00001,
      0.000001,
      0.0000001,
      0.00000001,
      0.000000001,
      0.0000000001,
      0.00000000001,
      0.000000000001,
      0.0000000000001,
      0.00000000000001,
      0.000000000000001,
      0.0000000000000001,
      0.00000000000000001
    ];
    #decodeDoubleDecimal(isNegative, decimalIndex, double, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        switch (byte) {
          case ASCII.E:
          case ASCII.e:
            this.#cursor = cursor + 1;
            const d = isNegative ? -double : double;
            return this.#cursor === chunk.length ? this.#decodeDoubleExponent.bind(this, d) : this.#decodeDoubleExponent(d, chunk);
          case ASCII["\r"]:
            this.#cursor = cursor + 2;
            return isNegative ? -double : double;
        }
        if (decimalIndex < _a.#DOUBLE_DECIMAL_MULTIPLIERS.length) {
          double += (byte - ASCII["0"]) * _a.#DOUBLE_DECIMAL_MULTIPLIERS[decimalIndex++];
        }
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#decodeDoubleDecimal.bind(this, isNegative, decimalIndex, double);
    }
    #decodeDoubleExponent(double, chunk) {
      switch (chunk[this.#cursor]) {
        case ASCII["+"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, false, double, 0) : this.#continueDecodeDoubleExponent(false, double, 0, chunk);
        case ASCII["-"]:
          return ++this.#cursor === chunk.length ? this.#continueDecodeDoubleExponent.bind(this, true, double, 0) : this.#continueDecodeDoubleExponent(true, double, 0, chunk);
      }
      return this.#continueDecodeDoubleExponent(false, double, 0, chunk);
    }
    #continueDecodeDoubleExponent(isNegative, double, exponent, chunk) {
      let cursor = this.#cursor;
      do {
        const byte = chunk[cursor];
        if (byte === ASCII["\r"]) {
          this.#cursor = cursor + 2;
          return double * 10 ** (isNegative ? -exponent : exponent);
        }
        exponent = exponent * 10 + byte - ASCII["0"];
      } while (++cursor < chunk.length);
      this.#cursor = cursor;
      return this.#continueDecodeDoubleExponent.bind(this, isNegative, double, exponent);
    }
    #findCRLF(chunk, cursor) {
      while (chunk[cursor] !== ASCII["\r"]) {
        if (++cursor === chunk.length) {
          this.#cursor = chunk.length;
          return -1;
        }
      }
      this.#cursor = cursor + 2;
      return cursor;
    }
    #decodeSimpleString(type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        return this.#continueDecodeSimpleString.bind(this, [chunk.subarray(start)], type);
      }
      const slice = chunk.subarray(start, crlfIndex);
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeSimpleString(chunks, type, chunk) {
      const start = this.#cursor, crlfIndex = this.#findCRLF(chunk, start);
      if (crlfIndex === -1) {
        chunks.push(chunk.subarray(start));
        return this.#continueDecodeSimpleString.bind(this, chunks, type);
      }
      chunks.push(chunk.subarray(start, crlfIndex));
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobString(type, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #continueDecodeBlobStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      if (typeof length === "function") {
        return this.#continueDecodeBlobStringLength.bind(this, length, type);
      } else if (this.#cursor >= chunk.length) {
        return this.#decodeBlobStringWithLength.bind(this, length, type);
      }
      return this.#decodeBlobStringWithLength(length, type, chunk);
    }
    #decodeStringWithLength(length, skip, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice2 = chunk.subarray(this.#cursor);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice2.length, [slice2], skip, type);
      }
      const slice = chunk.subarray(this.#cursor, end);
      this.#cursor = end + skip;
      return type === Buffer ? slice : slice.toString();
    }
    #continueDecodeStringWithLength(length, chunks, skip, type, chunk) {
      const end = this.#cursor + length;
      if (end >= chunk.length) {
        const slice = chunk.subarray(this.#cursor);
        chunks.push(slice);
        this.#cursor = chunk.length;
        return this.#continueDecodeStringWithLength.bind(this, length - slice.length, chunks, skip, type);
      }
      chunks.push(chunk.subarray(this.#cursor, end));
      this.#cursor = end + skip;
      return type === Buffer ? Buffer.concat(chunks) : chunks.join("");
    }
    #decodeBlobStringWithLength(length, type, chunk) {
      return this.#decodeStringWithLength(length, 2, type, chunk);
    }
    #decodeVerbatimString(type, chunk) {
      return this.#continueDecodeVerbatimStringLength(this.#decodeUnsingedNumber.bind(this, 0), type, chunk);
    }
    #continueDecodeVerbatimStringLength(lengthCb, type, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeVerbatimStringLength.bind(this, length, type) : this.#decodeVerbatimStringWithLength(length, type, chunk);
    }
    #decodeVerbatimStringWithLength(length, type, chunk) {
      const stringLength = length - 4;
      if (type === verbatim_string_1.VerbatimString) {
        return this.#decodeVerbatimStringFormat(stringLength, chunk);
      }
      this.#cursor += 4;
      return this.#cursor >= chunk.length ? this.#decodeBlobStringWithLength.bind(this, stringLength, type) : this.#decodeBlobStringWithLength(stringLength, type, chunk);
    }
    #decodeVerbatimStringFormat(stringLength, chunk) {
      const formatCb = this.#decodeStringWithLength.bind(this, 3, 1, String);
      return this.#cursor >= chunk.length ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, formatCb) : this.#continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk);
    }
    #continueDecodeVerbatimStringFormat(stringLength, formatCb, chunk) {
      const format = formatCb(chunk);
      return typeof format === "function" ? this.#continueDecodeVerbatimStringFormat.bind(this, stringLength, format) : this.#decodeVerbatimStringWithFormat(stringLength, format, chunk);
    }
    #decodeVerbatimStringWithFormat(stringLength, format, chunk) {
      return this.#continueDecodeVerbatimStringWithFormat(format, this.#decodeBlobStringWithLength.bind(this, stringLength, String), chunk);
    }
    #continueDecodeVerbatimStringWithFormat(format, stringCb, chunk) {
      const string4 = stringCb(chunk);
      return typeof string4 === "function" ? this.#continueDecodeVerbatimStringWithFormat.bind(this, format, string4) : new verbatim_string_1.VerbatimString(format, string4);
    }
    #decodeSimpleError(chunk) {
      const string4 = this.#decodeSimpleString(String, chunk);
      return typeof string4 === "function" ? this.#continueDecodeSimpleError.bind(this, string4) : new errors_1.SimpleError(string4);
    }
    #continueDecodeSimpleError(stringCb, chunk) {
      const string4 = stringCb(chunk);
      return typeof string4 === "function" ? this.#continueDecodeSimpleError.bind(this, string4) : new errors_1.SimpleError(string4);
    }
    #decodeBlobError(chunk) {
      const string4 = this.#decodeBlobString(String, chunk);
      return typeof string4 === "function" ? this.#continueDecodeBlobError.bind(this, string4) : new errors_1.BlobError(string4);
    }
    #continueDecodeBlobError(stringCb, chunk) {
      const string4 = stringCb(chunk);
      return typeof string4 === "function" ? this.#continueDecodeBlobError.bind(this, string4) : new errors_1.BlobError(string4);
    }
    #decodeNestedType(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeNestedTypeValue.bind(this, type, typeMapping) : this.#decodeNestedTypeValue(type, typeMapping, chunk);
    }
    #decodeNestedTypeValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.NULL:
          return this.#decodeNull();
        case exports.RESP_TYPES.BOOLEAN:
          return this.#decodeBoolean(chunk);
        case exports.RESP_TYPES.NUMBER:
          return this.#decodeNumber(typeMapping[exports.RESP_TYPES.NUMBER], chunk);
        case exports.RESP_TYPES.BIG_NUMBER:
          return this.#decodeBigNumber(typeMapping[exports.RESP_TYPES.BIG_NUMBER], chunk);
        case exports.RESP_TYPES.DOUBLE:
          return this.#decodeDouble(typeMapping[exports.RESP_TYPES.DOUBLE], chunk);
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(typeMapping[exports.RESP_TYPES.SIMPLE_STRING], chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(typeMapping[exports.RESP_TYPES.BLOB_STRING], chunk);
        case exports.RESP_TYPES.VERBATIM_STRING:
          return this.#decodeVerbatimString(typeMapping[exports.RESP_TYPES.VERBATIM_STRING], chunk);
        case exports.RESP_TYPES.SIMPLE_ERROR:
          return this.#decodeSimpleError(chunk);
        case exports.RESP_TYPES.BLOB_ERROR:
          return this.#decodeBlobError(chunk);
        case exports.RESP_TYPES.ARRAY:
          return this.#decodeArray(typeMapping, chunk);
        case exports.RESP_TYPES.SET:
          return this.#decodeSet(typeMapping, chunk);
        case exports.RESP_TYPES.MAP:
          return this.#decodeMap(typeMapping, chunk);
        default:
          throw new Error(`Unknown RESP type ${type} "${String.fromCharCode(type)}"`);
      }
    }
    #decodeArray(typeMapping, chunk) {
      if (chunk[this.#cursor] === ASCII["-"]) {
        this.#cursor += 4;
        return null;
      }
      return this.#decodeArrayWithLength(this.#decodeUnsingedNumber(0, chunk), typeMapping, chunk);
    }
    #decodeArrayWithLength(length, typeMapping, chunk) {
      return typeof length === "function" ? this.#continueDecodeArrayLength.bind(this, length, typeMapping) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #continueDecodeArrayLength(lengthCb, typeMapping, chunk) {
      return this.#decodeArrayWithLength(lengthCb(chunk), typeMapping, chunk);
    }
    #decodeArrayItems(array2, filled, typeMapping, chunk) {
      for (let i = filled;i < array2.length; i++) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeArrayItems.bind(this, array2, i, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeArrayItems.bind(this, array2, i, item, typeMapping);
        }
        array2[i] = item;
      }
      return array2;
    }
    #continueDecodeArrayItems(array2, filled, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeArrayItems.bind(this, array2, filled, item, typeMapping);
      }
      array2[filled++] = item;
      return this.#decodeArrayItems(array2, filled, typeMapping, chunk);
    }
    #decodeSet(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeSetLength.bind(this, length, typeMapping);
      }
      return this.#decodeSetItems(length, typeMapping, chunk);
    }
    #continueDecodeSetLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeSetLength.bind(this, length, typeMapping) : this.#decodeSetItems(length, typeMapping, chunk);
    }
    #decodeSetItems(length, typeMapping, chunk) {
      return typeMapping[exports.RESP_TYPES.SET] === Set ? this.#decodeSetAsSet(new Set, length, typeMapping, chunk) : this.#decodeArrayItems(new Array(length), 0, typeMapping, chunk);
    }
    #decodeSetAsSet(set2, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeSetAsSet.bind(this, set2, remaining, typeMapping);
        }
        const item = this.#decodeNestedType(typeMapping, chunk);
        if (typeof item === "function") {
          return this.#continueDecodeSetAsSet.bind(this, set2, remaining, item, typeMapping);
        }
        set2.add(item);
        --remaining;
      }
      return set2;
    }
    #continueDecodeSetAsSet(set2, remaining, itemCb, typeMapping, chunk) {
      const item = itemCb(chunk);
      if (typeof item === "function") {
        return this.#continueDecodeSetAsSet.bind(this, set2, remaining, item, typeMapping);
      }
      set2.add(item);
      return this.#decodeSetAsSet(set2, remaining - 1, typeMapping, chunk);
    }
    #decodeMap(typeMapping, chunk) {
      const length = this.#decodeUnsingedNumber(0, chunk);
      if (typeof length === "function") {
        return this.#continueDecodeMapLength.bind(this, length, typeMapping);
      }
      return this.#decodeMapItems(length, typeMapping, chunk);
    }
    #continueDecodeMapLength(lengthCb, typeMapping, chunk) {
      const length = lengthCb(chunk);
      return typeof length === "function" ? this.#continueDecodeMapLength.bind(this, length, typeMapping) : this.#decodeMapItems(length, typeMapping, chunk);
    }
    #decodeMapItems(length, typeMapping, chunk) {
      switch (typeMapping[exports.RESP_TYPES.MAP]) {
        case Map:
          return this.#decodeMapAsMap(new Map, length, typeMapping, chunk);
        case Array:
          return this.#decodeArrayItems(new Array(length * 2), 0, typeMapping, chunk);
        default:
          return this.#decodeMapAsObject(Object.create(null), length, typeMapping, chunk);
      }
    }
    #decodeMapAsMap(map2, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsMap.bind(this, map2, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapKey.bind(this, map2, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapValue.bind(this, map2, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapValue.bind(this, map2, remaining, key, value, typeMapping);
        }
        map2.set(key, value);
        --remaining;
      }
      return map2;
    }
    #decodeMapKey(typeMapping, chunk) {
      const type = chunk[this.#cursor];
      return ++this.#cursor === chunk.length ? this.#decodeMapKeyValue.bind(this, type, typeMapping) : this.#decodeMapKeyValue(type, typeMapping, chunk);
    }
    #decodeMapKeyValue(type, typeMapping, chunk) {
      switch (type) {
        case exports.RESP_TYPES.SIMPLE_STRING:
          return this.#decodeSimpleString(String, chunk);
        case exports.RESP_TYPES.BLOB_STRING:
          return this.#decodeBlobString(String, chunk);
        default:
          return this.#decodeNestedTypeValue(type, typeMapping, chunk);
      }
    }
    #continueDecodeMapKey(map2, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapKey.bind(this, map2, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapValue.bind(this, map2, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map2, remaining, key, value, typeMapping);
      }
      map2.set(key, value);
      return this.#decodeMapAsMap(map2, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapValue(map2, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapValue.bind(this, map2, remaining, key, value, typeMapping);
      }
      map2.set(key, value);
      return this.#decodeMapAsMap(map2, remaining - 1, typeMapping, chunk);
    }
    #decodeMapAsObject(object2, remaining, typeMapping, chunk) {
      while (remaining > 0) {
        if (this.#cursor >= chunk.length) {
          return this.#decodeMapAsObject.bind(this, object2, remaining, typeMapping);
        }
        const key = this.#decodeMapKey(typeMapping, chunk);
        if (typeof key === "function") {
          return this.#continueDecodeMapAsObjectKey.bind(this, object2, remaining, key, typeMapping);
        }
        if (this.#cursor >= chunk.length) {
          return this.#continueDecodeMapAsObjectValue.bind(this, object2, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
        }
        const value = this.#decodeNestedType(typeMapping, chunk);
        if (typeof value === "function") {
          return this.#continueDecodeMapAsObjectValue.bind(this, object2, remaining, key, value, typeMapping);
        }
        object2[key] = value;
        --remaining;
      }
      return object2;
    }
    #continueDecodeMapAsObjectKey(object2, remaining, keyCb, typeMapping, chunk) {
      const key = keyCb(chunk);
      if (typeof key === "function") {
        return this.#continueDecodeMapAsObjectKey.bind(this, object2, remaining, key, typeMapping);
      }
      if (this.#cursor >= chunk.length) {
        return this.#continueDecodeMapAsObjectValue.bind(this, object2, remaining, key, this.#decodeNestedType.bind(this, typeMapping), typeMapping);
      }
      const value = this.#decodeNestedType(typeMapping, chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object2, remaining, key, value, typeMapping);
      }
      object2[key] = value;
      return this.#decodeMapAsObject(object2, remaining - 1, typeMapping, chunk);
    }
    #continueDecodeMapAsObjectValue(object2, remaining, key, valueCb, typeMapping, chunk) {
      const value = valueCb(chunk);
      if (typeof value === "function") {
        return this.#continueDecodeMapAsObjectValue.bind(this, object2, remaining, key, value, typeMapping);
      }
      object2[key] = value;
      return this.#decodeMapAsObject(object2, remaining - 1, typeMapping, chunk);
    }
  }
  exports.Decoder = Decoder;
  _a = Decoder;
});

// node_modules/@redis/client/dist/lib/lua-script.js
var require_lua_script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptSha1 = exports.defineScript = undefined;
  var node_crypto_1 = __require("crypto");
  function defineScript(script) {
    return {
      ...script,
      SHA1: scriptSha1(script.SCRIPT)
    };
  }
  exports.defineScript = defineScript;
  function scriptSha1(script) {
    return (0, node_crypto_1.createHash)("sha1").update(script).digest("hex");
  }
  exports.scriptSha1 = scriptSha1;
});

// node_modules/@redis/client/dist/lib/commands/ACL_CAT.js
var require_ACL_CAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, categoryName) {
      parser.push("ACL", "CAT");
      if (categoryName) {
        parser.push(categoryName);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_DELUSER.js
var require_ACL_DELUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "DELUSER");
      parser.pushVariadic(username);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_DRYRUN.js
var require_ACL_DRYRUN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, command) {
      parser.push("ACL", "DRYRUN", username, ...command);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_GENPASS.js
var require_ACL_GENPASS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, bits) {
      parser.push("ACL", "GENPASS");
      if (bits) {
        parser.push(bits.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_GETUSER.js
var require_ACL_GETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username) {
      parser.push("ACL", "GETUSER", username);
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        passwords: reply[3],
        commands: reply[5],
        keys: reply[7],
        channels: reply[9],
        selectors: reply[11]?.map((selector) => {
          const inferred = selector;
          return {
            commands: inferred[1],
            keys: inferred[3],
            channels: inferred[5]
          };
        })
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LIST.js
var require_ACL_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LIST");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOAD.js
var require_ACL_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "LOAD");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/client/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicCommandParser = undefined;

  class BasicCommandParser {
    #redisArgs = [];
    #keys = [];
    preserve;
    get redisArgs() {
      return this.#redisArgs;
    }
    get keys() {
      return this.#keys;
    }
    get firstKey() {
      return this.#keys[0];
    }
    get cacheKey() {
      const tmp = new Array(this.#redisArgs.length * 2);
      for (let i = 0;i < this.#redisArgs.length; i++) {
        tmp[i] = this.#redisArgs[i].length;
        tmp[i + this.#redisArgs.length] = this.#redisArgs[i];
      }
      return tmp.join("_");
    }
    push(...arg) {
      this.#redisArgs.push(...arg);
    }
    pushVariadic(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val);
        }
      } else {
        this.push(vals);
      }
    }
    pushVariadicWithLength(vals) {
      if (Array.isArray(vals)) {
        this.#redisArgs.push(vals.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushVariadic(vals);
    }
    pushVariadicNumber(vals) {
      if (Array.isArray(vals)) {
        for (const val of vals) {
          this.push(val.toString());
        }
      } else {
        this.push(vals.toString());
      }
    }
    pushKey(key) {
      this.#keys.push(key);
      this.#redisArgs.push(key);
    }
    pushKeysLength(keys) {
      if (Array.isArray(keys)) {
        this.#redisArgs.push(keys.length.toString());
      } else {
        this.#redisArgs.push("1");
      }
      this.pushKeys(keys);
    }
    pushKeys(keys) {
      if (Array.isArray(keys)) {
        this.#keys.push(...keys);
        this.#redisArgs.push(...keys);
      } else {
        this.#keys.push(keys);
        this.#redisArgs.push(keys);
      }
    }
  }
  exports.BasicCommandParser = BasicCommandParser;
});

// node_modules/@redis/client/dist/lib/commands/generic-transformers.js
var require_generic_transformers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = exports.transformStreamsMessagesReplyResp3 = exports.transformStreamsMessagesReplyResp2 = exports.transformStreamMessagesReply = exports.transformStreamMessageNullReply = exports.transformStreamMessageReply = exports.parseArgs = exports.parseZKeysArguments = exports.transformRangeReply = exports.parseSlotRangesArguments = exports.transformFunctionListItemReply = exports.RedisFunctionFlags = exports.transformCommandReply = exports.CommandCategories = exports.CommandFlags = exports.parseOptionalVariadicArgument = exports.pushVariadicArgument = exports.pushVariadicNumberArguments = exports.pushVariadicArguments = exports.pushEvalArguments = exports.evalFirstKeyIndex = exports.transformPXAT = exports.transformEXAT = exports.transformSortedSetReply = exports.transformTuplesReply = exports.createTransformTuplesReplyFunc = exports.transformTuplesToMap = exports.transformNullableDoubleReply = exports.createTransformNullableDoubleReplyResp2Func = exports.transformDoubleArrayReply = exports.createTransformDoubleReplyResp2Func = exports.transformDoubleReply = exports.transformStringDoubleArgument = exports.transformDoubleArgument = exports.transformBooleanArrayReply = exports.transformBooleanReply = exports.isArrayReply = exports.isNullReply = undefined;
  var parser_1 = require_parser();
  var decoder_1 = require_decoder9();
  function isNullReply(reply) {
    return reply === null;
  }
  exports.isNullReply = isNullReply;
  function isArrayReply(reply) {
    return Array.isArray(reply);
  }
  exports.isArrayReply = isArrayReply;
  exports.transformBooleanReply = {
    2: (reply) => reply === 1,
    3: undefined
  };
  exports.transformBooleanArrayReply = {
    2: (reply) => {
      return reply.map(exports.transformBooleanReply[2]);
    },
    3: undefined
  };
  function transformDoubleArgument(num) {
    switch (num) {
      case Infinity:
        return "+inf";
      case -Infinity:
        return "-inf";
      default:
        return num.toString();
    }
  }
  exports.transformDoubleArgument = transformDoubleArgument;
  function transformStringDoubleArgument(num) {
    if (typeof num !== "number")
      return num;
    return transformDoubleArgument(num);
  }
  exports.transformStringDoubleArgument = transformStringDoubleArgument;
  exports.transformDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      const double = typeMapping ? typeMapping[decoder_1.RESP_TYPES.DOUBLE] : undefined;
      switch (double) {
        case String: {
          return reply;
        }
        default: {
          let ret;
          switch (reply.toString()) {
            case "inf":
            case "+inf":
              ret = Infinity;
            case "-inf":
              ret = -Infinity;
            case "nan":
              ret = NaN;
            default:
              ret = Number(reply);
          }
          return ret;
        }
      }
    },
    3: undefined
  };
  function createTransformDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformDoubleReplyResp2Func = createTransformDoubleReplyResp2Func;
  exports.transformDoubleArrayReply = {
    2: (reply, preserve, typeMapping) => {
      return reply.map(createTransformDoubleReplyResp2Func(preserve, typeMapping));
    },
    3: undefined
  };
  function createTransformNullableDoubleReplyResp2Func(preserve, typeMapping) {
    return (reply) => {
      return exports.transformNullableDoubleReply[2](reply, preserve, typeMapping);
    };
  }
  exports.createTransformNullableDoubleReplyResp2Func = createTransformNullableDoubleReplyResp2Func;
  exports.transformNullableDoubleReply = {
    2: (reply, preserve, typeMapping) => {
      if (reply === null)
        return null;
      return exports.transformDoubleReply[2](reply, preserve, typeMapping);
    },
    3: undefined
  };
  function transformTuplesToMap(reply, func) {
    const message = Object.create(null);
    for (let i = 0;i < reply.length; i += 2) {
      message[reply[i].toString()] = func(reply[i + 1]);
    }
    return message;
  }
  exports.transformTuplesToMap = transformTuplesToMap;
  function createTransformTuplesReplyFunc(preserve, typeMapping) {
    return (reply) => {
      return transformTuplesReply(reply, preserve, typeMapping);
    };
  }
  exports.createTransformTuplesReplyFunc = createTransformTuplesReplyFunc;
  function transformTuplesReply(reply, preserve, typeMapping) {
    const mapType = typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined;
    const inferred = reply;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < inferred.length; i += 2) {
          ret.set(inferred[i].toString(), inferred[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < inferred.length; i += 2) {
          ret[inferred[i].toString()] = inferred[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformTuplesReply = transformTuplesReply;
  exports.transformSortedSetReply = {
    2: (reply, preserve, typeMapping) => {
      const inferred = reply, members = [];
      for (let i = 0;i < inferred.length; i += 2) {
        members.push({
          value: inferred[i],
          score: exports.transformDoubleReply[2](inferred[i + 1], preserve, typeMapping)
        });
      }
      return members;
    },
    3: (reply) => {
      return reply.map((member) => {
        const [value, score] = member;
        return {
          value,
          score
        };
      });
    }
  };
  function transformEXAT(EXAT) {
    return (typeof EXAT === "number" ? EXAT : Math.floor(EXAT.getTime() / 1000)).toString();
  }
  exports.transformEXAT = transformEXAT;
  function transformPXAT(PXAT) {
    return (typeof PXAT === "number" ? PXAT : PXAT.getTime()).toString();
  }
  exports.transformPXAT = transformPXAT;
  function evalFirstKeyIndex(options) {
    return options?.keys?.[0];
  }
  exports.evalFirstKeyIndex = evalFirstKeyIndex;
  function pushEvalArguments(args, options) {
    if (options?.keys) {
      args.push(options.keys.length.toString(), ...options.keys);
    } else {
      args.push("0");
    }
    if (options?.arguments) {
      args.push(...options.arguments);
    }
    return args;
  }
  exports.pushEvalArguments = pushEvalArguments;
  function pushVariadicArguments(args, value) {
    if (Array.isArray(value)) {
      args = args.concat(value);
    } else {
      args.push(value);
    }
    return args;
  }
  exports.pushVariadicArguments = pushVariadicArguments;
  function pushVariadicNumberArguments(args, value) {
    if (Array.isArray(value)) {
      for (const item of value) {
        args.push(item.toString());
      }
    } else {
      args.push(value.toString());
    }
    return args;
  }
  exports.pushVariadicNumberArguments = pushVariadicNumberArguments;
  function pushVariadicArgument(args, value) {
    if (Array.isArray(value)) {
      args.push(value.length.toString(), ...value);
    } else {
      args.push("1", value);
    }
    return args;
  }
  exports.pushVariadicArgument = pushVariadicArgument;
  function parseOptionalVariadicArgument(parser, name, value) {
    if (value === undefined)
      return;
    parser.push(name);
    parser.pushVariadicWithLength(value);
  }
  exports.parseOptionalVariadicArgument = parseOptionalVariadicArgument;
  var CommandFlags;
  (function(CommandFlags2) {
    CommandFlags2["WRITE"] = "write";
    CommandFlags2["READONLY"] = "readonly";
    CommandFlags2["DENYOOM"] = "denyoom";
    CommandFlags2["ADMIN"] = "admin";
    CommandFlags2["PUBSUB"] = "pubsub";
    CommandFlags2["NOSCRIPT"] = "noscript";
    CommandFlags2["RANDOM"] = "random";
    CommandFlags2["SORT_FOR_SCRIPT"] = "sort_for_script";
    CommandFlags2["LOADING"] = "loading";
    CommandFlags2["STALE"] = "stale";
    CommandFlags2["SKIP_MONITOR"] = "skip_monitor";
    CommandFlags2["ASKING"] = "asking";
    CommandFlags2["FAST"] = "fast";
    CommandFlags2["MOVABLEKEYS"] = "movablekeys";
  })(CommandFlags || (exports.CommandFlags = CommandFlags = {}));
  var CommandCategories;
  (function(CommandCategories2) {
    CommandCategories2["KEYSPACE"] = "@keyspace";
    CommandCategories2["READ"] = "@read";
    CommandCategories2["WRITE"] = "@write";
    CommandCategories2["SET"] = "@set";
    CommandCategories2["SORTEDSET"] = "@sortedset";
    CommandCategories2["LIST"] = "@list";
    CommandCategories2["HASH"] = "@hash";
    CommandCategories2["STRING"] = "@string";
    CommandCategories2["BITMAP"] = "@bitmap";
    CommandCategories2["HYPERLOGLOG"] = "@hyperloglog";
    CommandCategories2["GEO"] = "@geo";
    CommandCategories2["STREAM"] = "@stream";
    CommandCategories2["PUBSUB"] = "@pubsub";
    CommandCategories2["ADMIN"] = "@admin";
    CommandCategories2["FAST"] = "@fast";
    CommandCategories2["SLOW"] = "@slow";
    CommandCategories2["BLOCKING"] = "@blocking";
    CommandCategories2["DANGEROUS"] = "@dangerous";
    CommandCategories2["CONNECTION"] = "@connection";
    CommandCategories2["TRANSACTION"] = "@transaction";
    CommandCategories2["SCRIPTING"] = "@scripting";
  })(CommandCategories || (exports.CommandCategories = CommandCategories = {}));
  function transformCommandReply([name, arity, flags, firstKeyIndex, lastKeyIndex, step, categories]) {
    return {
      name,
      arity,
      flags: new Set(flags),
      firstKeyIndex,
      lastKeyIndex,
      step,
      categories: new Set(categories)
    };
  }
  exports.transformCommandReply = transformCommandReply;
  var RedisFunctionFlags;
  (function(RedisFunctionFlags2) {
    RedisFunctionFlags2["NO_WRITES"] = "no-writes";
    RedisFunctionFlags2["ALLOW_OOM"] = "allow-oom";
    RedisFunctionFlags2["ALLOW_STALE"] = "allow-stale";
    RedisFunctionFlags2["NO_CLUSTER"] = "no-cluster";
  })(RedisFunctionFlags || (exports.RedisFunctionFlags = RedisFunctionFlags = {}));
  function transformFunctionListItemReply(reply) {
    return {
      libraryName: reply[1],
      engine: reply[3],
      functions: reply[5].map((fn) => ({
        name: fn[1],
        description: fn[3],
        flags: fn[5]
      }))
    };
  }
  exports.transformFunctionListItemReply = transformFunctionListItemReply;
  function parseSlotRangeArguments(parser, range) {
    parser.push(range.start.toString(), range.end.toString());
  }
  function parseSlotRangesArguments(parser, ranges) {
    if (Array.isArray(ranges)) {
      for (const range of ranges) {
        parseSlotRangeArguments(parser, range);
      }
    } else {
      parseSlotRangeArguments(parser, ranges);
    }
  }
  exports.parseSlotRangesArguments = parseSlotRangesArguments;
  function transformRangeReply([start, end]) {
    return {
      start,
      end
    };
  }
  exports.transformRangeReply = transformRangeReply;
  function parseZKeysArguments(parser, keys) {
    if (Array.isArray(keys)) {
      parser.push(keys.length.toString());
      if (keys.length) {
        if (isPlainKeys(keys)) {
          parser.pushKeys(keys);
        } else {
          for (let i = 0;i < keys.length; i++) {
            parser.pushKey(keys[i].key);
          }
          parser.push("WEIGHTS");
          for (let i = 0;i < keys.length; i++) {
            parser.push(transformDoubleArgument(keys[i].weight));
          }
        }
      }
    } else {
      parser.push("1");
      if (isPlainKey(keys)) {
        parser.pushKey(keys);
      } else {
        parser.pushKey(keys.key);
        parser.push("WEIGHTS", transformDoubleArgument(keys.weight));
      }
    }
  }
  exports.parseZKeysArguments = parseZKeysArguments;
  function isPlainKey(key) {
    return typeof key === "string" || key instanceof Buffer;
  }
  function isPlainKeys(keys) {
    return isPlainKey(keys[0]);
  }
  function parseArgs(command, ...args) {
    const parser = new parser_1.BasicCommandParser;
    command.parseCommand(parser, ...args);
    const redisArgs = parser.redisArgs;
    if (parser.preserve) {
      redisArgs.preserve = parser.preserve;
    }
    return redisArgs;
  }
  exports.parseArgs = parseArgs;
  function transformStreamMessageReply(typeMapping, reply) {
    const [id, message] = reply;
    return {
      id,
      message: transformTuplesReply(message, undefined, typeMapping)
    };
  }
  exports.transformStreamMessageReply = transformStreamMessageReply;
  function transformStreamMessageNullReply(typeMapping, reply) {
    return isNullReply(reply) ? reply : transformStreamMessageReply(typeMapping, reply);
  }
  exports.transformStreamMessageNullReply = transformStreamMessageNullReply;
  function transformStreamMessagesReply(r, typeMapping) {
    const reply = r;
    return reply.map(transformStreamMessageReply.bind(undefined, typeMapping));
  }
  exports.transformStreamMessagesReply = transformStreamMessagesReply;
  function transformStreamsMessagesReplyResp2(reply, preserve, typeMapping) {
    if (reply === null)
      return null;
    switch (typeMapping ? typeMapping[decoder_1.RESP_TYPES.MAP] : undefined) {
      default: {
        const ret = [];
        for (let i = 0;i < reply.length; i++) {
          const stream = reply[i];
          ret.push({
            name: stream[0],
            messages: transformStreamMessagesReply(stream[1])
          });
        }
        return ret;
      }
    }
  }
  exports.transformStreamsMessagesReplyResp2 = transformStreamsMessagesReplyResp2;
  function transformStreamsMessagesReplyResp3(reply) {
    if (reply === null)
      return null;
    if (reply instanceof Map) {
      const ret = new Map;
      for (const [n, rawMessages] of reply) {
        const name = n;
        ret.set(name.toString(), transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else if (reply instanceof Array) {
      const ret = [];
      for (let i = 0;i < reply.length; i += 2) {
        const name = reply[i];
        const rawMessages = reply[i + 1];
        ret.push(name);
        ret.push(transformStreamMessagesReply(rawMessages));
      }
      return ret;
    } else {
      const ret = Object.create(null);
      for (const [name, rawMessages] of Object.entries(reply)) {
        ret[name] = transformStreamMessagesReply(rawMessages);
      }
      return ret;
    }
  }
  exports.transformStreamsMessagesReplyResp3 = transformStreamsMessagesReplyResp3;
  function transformRedisJsonArgument(json2) {
    return JSON.stringify(json2);
  }
  exports.transformRedisJsonArgument = transformRedisJsonArgument;
  function transformRedisJsonReply(json2) {
    const res = JSON.parse(json2.toString());
    return res;
  }
  exports.transformRedisJsonReply = transformRedisJsonReply;
  function transformRedisJsonNullReply(json2) {
    return isNullReply(json2) ? json2 : transformRedisJsonReply(json2);
  }
  exports.transformRedisJsonNullReply = transformRedisJsonNullReply;
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG.js
var require_ACL_LOG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, count) {
      parser.push("ACL", "LOG");
      if (count != null) {
        parser.push(count.toString());
      }
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((item) => {
          const inferred = item;
          return {
            count: inferred[1],
            reason: inferred[3],
            context: inferred[5],
            object: inferred[7],
            username: inferred[9],
            "age-seconds": generic_transformers_1.transformDoubleReply[2](inferred[11], preserve, typeMapping),
            "client-info": inferred[13],
            "entry-id": inferred[15],
            "timestamp-created": inferred[17],
            "timestamp-last-updated": inferred[19]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_LOG_RESET.js
var require_ACL_LOG_RESET = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: ACL_LOG_1.default.IS_READ_ONLY,
    parseCommand(parser) {
      parser.push("ACL", "LOG", "RESET");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_SAVE.js
var require_ACL_SAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "SAVE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_SETUSER.js
var require_ACL_SETUSER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, username, rule) {
      parser.push("ACL", "SETUSER", username);
      parser.pushVariadic(rule);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_USERS.js
var require_ACL_USERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "USERS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ACL_WHOAMI.js
var require_ACL_WHOAMI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ACL", "WHOAMI");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/APPEND.js
var require_APPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, value) {
      parser.push("APPEND", key, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ASKING.js
var require_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ASKING_CMD = undefined;
  exports.ASKING_CMD = "ASKING";
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push(exports.ASKING_CMD);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/AUTH.js
var require_AUTH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, { username, password }) {
      parser.push("AUTH");
      if (username !== undefined) {
        parser.push(username);
      }
      parser.push(password);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BGREWRITEAOF.js
var require_BGREWRITEAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("BGREWRITEAOF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BGSAVE.js
var require_BGSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("BGSAVE");
      if (options?.SCHEDULE) {
        parser.push("SCHEDULE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITCOUNT.js
var require_BITCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, range) {
      parser.push("BITCOUNT");
      parser.pushKey(key);
      if (range) {
        parser.push(range.start.toString());
        parser.push(range.end.toString());
        if (range.mode) {
          parser.push(range.mode);
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD_RO.js
var require_BITFIELD_RO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD_RO");
      parser.pushKey(key);
      for (const operation of operations) {
        parser.push("GET");
        parser.push(operation.encoding);
        parser.push(operation.offset.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITFIELD.js
var require_BITFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, operations) {
      parser.push("BITFIELD");
      parser.pushKey(key);
      for (const options of operations) {
        switch (options.operation) {
          case "GET":
            parser.push("GET", options.encoding, options.offset.toString());
            break;
          case "SET":
            parser.push("SET", options.encoding, options.offset.toString(), options.value.toString());
            break;
          case "INCRBY":
            parser.push("INCRBY", options.encoding, options.offset.toString(), options.increment.toString());
            break;
          case "OVERFLOW":
            parser.push("OVERFLOW", options.behavior);
            break;
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITOP.js
var require_BITOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, operation, destKey, key) {
      parser.push("BITOP", operation);
      parser.pushKey(destKey);
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BITPOS.js
var require_BITPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, bit, start, end, mode) {
      parser.push("BITPOS");
      parser.pushKey(key);
      parser.push(bit.toString());
      if (start !== undefined) {
        parser.push(start.toString());
      }
      if (end !== undefined) {
        parser.push(end.toString());
      }
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BLMOVE.js
var require_BLMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide, timeout) {
      parser.push("BLMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide, timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LMPOP.js
var require_LMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseLMPopArguments = undefined;
  function parseLMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseLMPopArguments = parseLMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, ...args) {
      parser.push("LMPOP");
      parseLMPopArguments(parser, ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/BLMPOP.js
var require_BLMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LMPOP_1 = __importStar(require_LMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BLMPOP", timeout.toString());
      (0, LMPOP_1.parseLMPopArguments)(parser, ...args);
    },
    transformReply: LMPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BLPOP.js
var require_BLPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BLPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply(reply) {
      if (reply === null)
        return null;
      return {
        key: reply[0],
        element: reply[1]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BRPOP.js
var require_BRPOP = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BLPOP_1 = __importDefault(require_BLPOP());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timeout) {
      parser.push("BRPOP");
      parser.pushKeys(key);
      parser.push(timeout.toString());
    },
    transformReply: BLPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BRPOPLPUSH.js
var require_BRPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, timeout) {
      parser.push("BRPOPLPUSH");
      parser.pushKeys([source, destination]);
      parser.push(timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZMPOP.js
var require_ZMPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZMPopArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZMPopArguments(parser, keys, side, options) {
    parser.pushKeysLength(keys);
    parser.push(side);
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseZMPopArguments = parseZMPopArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, side, options) {
      parser.push("ZMPOP");
      parseZMPopArguments(parser, keys, side, options);
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          members: reply[1].map((member) => {
            const [value, score] = member;
            return {
              value,
              score: generic_transformers_1.transformDoubleReply[2](score, preserve, typeMapping)
            };
          })
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          members: generic_transformers_1.transformSortedSetReply[3](reply[1])
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BZMPOP.js
var require_BZMPOP = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZMPOP_1 = __importStar(require_ZMPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, timeout, ...args) {
      parser.push("BZMPOP", timeout.toString());
      (0, ZMPOP_1.parseZMPopArguments)(parser, ...args);
    },
    transformReply: ZMPOP_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMAX.js
var require_BZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMAX");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: {
      2(reply, preserve, typeMapping) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: generic_transformers_1.transformDoubleReply[2](reply[2], preserve, typeMapping)
        };
      },
      3(reply) {
        return reply === null ? null : {
          key: reply[0],
          value: reply[1],
          score: reply[2]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/BZPOPMIN.js
var require_BZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  exports.default = {
    IS_READ_ONLY: BZPOPMAX_1.default.IS_READ_ONLY,
    parseCommand(parser, keys, timeout) {
      parser.push("BZPOPMIN");
      parser.pushKeys(keys);
      parser.push(timeout.toString());
    },
    transformReply: BZPOPMAX_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_CACHING.js
var require_CLIENT_CACHING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "CACHING", value ? "YES" : "NO");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETNAME.js
var require_CLIENT_GETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETNAME");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_GETREDIR.js
var require_CLIENT_GETREDIR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "GETREDIR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_ID.js
var require_CLIENT_ID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "ID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_INFO.js
var require_CLIENT_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_REGEX = /([^\s=]+)=([^\s]*)/g;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "INFO");
    },
    transformReply(rawReply) {
      const map2 = {};
      for (const item of rawReply.toString().matchAll(CLIENT_INFO_REGEX)) {
        map2[item[1]] = item[2];
      }
      const reply = {
        id: Number(map2.id),
        addr: map2.addr,
        fd: Number(map2.fd),
        name: map2.name,
        age: Number(map2.age),
        idle: Number(map2.idle),
        flags: map2.flags,
        db: Number(map2.db),
        sub: Number(map2.sub),
        psub: Number(map2.psub),
        multi: Number(map2.multi),
        qbuf: Number(map2.qbuf),
        qbufFree: Number(map2["qbuf-free"]),
        argvMem: Number(map2["argv-mem"]),
        obl: Number(map2.obl),
        oll: Number(map2.oll),
        omem: Number(map2.omem),
        totMem: Number(map2["tot-mem"]),
        events: map2.events,
        cmd: map2.cmd,
        user: map2.user,
        libName: map2["lib-name"],
        libVer: map2["lib-ver"]
      };
      if (map2.laddr !== undefined) {
        reply.laddr = map2.laddr;
      }
      if (map2.redir !== undefined) {
        reply.redir = Number(map2.redir);
      }
      if (map2.ssub !== undefined) {
        reply.ssub = Number(map2.ssub);
      }
      if (map2["multi-mem"] !== undefined) {
        reply.multiMem = Number(map2["multi-mem"]);
      }
      if (map2.resp !== undefined) {
        reply.resp = Number(map2.resp);
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_KILL.js
var require_CLIENT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLIENT_KILL_FILTERS = undefined;
  exports.CLIENT_KILL_FILTERS = {
    ADDRESS: "ADDR",
    LOCAL_ADDRESS: "LADDR",
    ID: "ID",
    TYPE: "TYPE",
    USER: "USER",
    SKIP_ME: "SKIPME",
    MAXAGE: "MAXAGE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filters) {
      parser.push("CLIENT", "KILL");
      if (Array.isArray(filters)) {
        for (const filter of filters) {
          pushFilter(parser, filter);
        }
      } else {
        pushFilter(parser, filters);
      }
    },
    transformReply: undefined
  };
  function pushFilter(parser, filter) {
    if (filter === exports.CLIENT_KILL_FILTERS.SKIP_ME) {
      parser.push("SKIPME");
      return;
    }
    parser.push(filter.filter);
    switch (filter.filter) {
      case exports.CLIENT_KILL_FILTERS.ADDRESS:
        parser.push(filter.address);
        break;
      case exports.CLIENT_KILL_FILTERS.LOCAL_ADDRESS:
        parser.push(filter.localAddress);
        break;
      case exports.CLIENT_KILL_FILTERS.ID:
        parser.push(typeof filter.id === "number" ? filter.id.toString() : filter.id);
        break;
      case exports.CLIENT_KILL_FILTERS.TYPE:
        parser.push(filter.type);
        break;
      case exports.CLIENT_KILL_FILTERS.USER:
        parser.push(filter.username);
        break;
      case exports.CLIENT_KILL_FILTERS.SKIP_ME:
        parser.push(filter.skipMe ? "yes" : "no");
        break;
      case exports.CLIENT_KILL_FILTERS.MAXAGE:
        parser.push(filter.maxAge.toString());
        break;
    }
  }
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_LIST.js
var require_CLIENT_LIST = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter) {
      parser.push("CLIENT", "LIST");
      if (filter) {
        if (filter.TYPE !== undefined) {
          parser.push("TYPE", filter.TYPE);
        } else {
          parser.push("ID");
          parser.pushVariadic(filter.ID);
        }
      }
    },
    transformReply(rawReply) {
      const split = rawReply.toString().split(`
`), length = split.length - 1, reply = [];
      for (let i = 0;i < length; i++) {
        reply.push(CLIENT_INFO_1.default.transformReply(split[i]));
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-EVICT.js
var require_CLIENT_NO_EVICT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-EVICT", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_NO-TOUCH.js
var require_CLIENT_NO_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, value) {
      parser.push("CLIENT", "NO-TOUCH", value ? "ON" : "OFF");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_PAUSE.js
var require_CLIENT_PAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, timeout, mode) {
      parser.push("CLIENT", "PAUSE", timeout.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_SETNAME.js
var require_CLIENT_SETNAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("CLIENT", "SETNAME", name);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKING.js
var require_CLIENT_TRACKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode, options) {
      parser.push("CLIENT", "TRACKING", mode ? "ON" : "OFF");
      if (mode) {
        if (options?.REDIRECT) {
          parser.push("REDIRECT", options.REDIRECT.toString());
        }
        if (isBroadcast(options)) {
          parser.push("BCAST");
          if (options?.PREFIX) {
            if (Array.isArray(options.PREFIX)) {
              for (const prefix of options.PREFIX) {
                parser.push("PREFIX", prefix);
              }
            } else {
              parser.push("PREFIX", options.PREFIX);
            }
          }
        } else if (isOptIn(options)) {
          parser.push("OPTIN");
        } else if (isOptOut(options)) {
          parser.push("OPTOUT");
        }
        if (options?.NOLOOP) {
          parser.push("NOLOOP");
        }
      }
    },
    transformReply: undefined
  };
  function isBroadcast(options) {
    return options?.BCAST === true;
  }
  function isOptIn(options) {
    return options?.OPTIN === true;
  }
  function isOptOut(options) {
    return options?.OPTOUT === true;
  }
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_TRACKINGINFO.js
var require_CLIENT_TRACKINGINFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "TRACKINGINFO");
    },
    transformReply: {
      2: (reply) => ({
        flags: reply[1],
        redirect: reply[3],
        prefixes: reply[5]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLIENT_UNPAUSE.js
var require_CLIENT_UNPAUSE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLIENT", "UNPAUSE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTS.js
var require_CLUSTER_ADDSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "ADDSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_ADDSLOTSRANGE.js
var require_CLUSTER_ADDSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "ADDSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_BUMPEPOCH.js
var require_CLUSTER_BUMPEPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "BUMPEPOCH");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNT-FAILURE-REPORTS.js
var require_CLUSTER_COUNT_FAILURE_REPORTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "COUNT-FAILURE-REPORTS", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_COUNTKEYSINSLOT.js
var require_CLUSTER_COUNTKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot) {
      parser.push("CLUSTER", "COUNTKEYSINSLOT", slot.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTS.js
var require_CLUSTER_DELSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slots) {
      parser.push("CLUSTER", "DELSLOTS");
      parser.pushVariadicNumber(slots);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_DELSLOTSRANGE.js
var require_CLUSTER_DELSLOTSRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ranges) {
      parser.push("CLUSTER", "DELSLOTSRANGE");
      (0, generic_transformers_1.parseSlotRangesArguments)(parser, ranges);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FAILOVER.js
var require_CLUSTER_FAILOVER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FAILOVER_MODES = undefined;
  exports.FAILOVER_MODES = {
    FORCE: "FORCE",
    TAKEOVER: "TAKEOVER"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "FAILOVER");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FLUSHSLOTS.js
var require_CLUSTER_FLUSHSLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "FLUSHSLOTS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_FORGET.js
var require_CLUSTER_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "FORGET", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_GETKEYSINSLOT.js
var require_CLUSTER_GETKEYSINSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, count) {
      parser.push("CLUSTER", "GETKEYSINSLOT", slot.toString(), count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_INFO.js
var require_CLUSTER_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "INFO");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_KEYSLOT.js
var require_CLUSTER_KEYSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CLUSTER", "KEYSLOT", key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_LINKS.js
var require_CLUSTER_LINKS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "LINKS");
    },
    transformReply: {
      2: (reply) => reply.map((link) => {
        const unwrapped = link;
        return {
          direction: unwrapped[1],
          node: unwrapped[3],
          "create-time": unwrapped[5],
          events: unwrapped[7],
          "send-buffer-allocated": unwrapped[9],
          "send-buffer-used": unwrapped[11]
        };
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MEET.js
var require_CLUSTER_MEET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("CLUSTER", "MEET", host, port.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYID.js
var require_CLUSTER_MYID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_MYSHARDID.js
var require_CLUSTER_MYSHARDID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "MYSHARDID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_NODES.js
var require_CLUSTER_NODES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "NODES");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICAS.js
var require_CLUSTER_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICAS", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_REPLICATE.js
var require_CLUSTER_REPLICATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, nodeId) {
      parser.push("CLUSTER", "REPLICATE", nodeId);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_RESET.js
var require_CLUSTER_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("CLUSTER", "RESET");
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SAVECONFIG.js
var require_CLUSTER_SAVECONFIG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SAVECONFIG");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SET-CONFIG-EPOCH.js
var require_CLUSTER_SET_CONFIG_EPOCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, configEpoch) {
      parser.push("CLUSTER", "SET-CONFIG-EPOCH", configEpoch.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SETSLOT.js
var require_CLUSTER_SETSLOT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CLUSTER_SLOT_STATES = undefined;
  exports.CLUSTER_SLOT_STATES = {
    IMPORTING: "IMPORTING",
    MIGRATING: "MIGRATING",
    STABLE: "STABLE",
    NODE: "NODE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, slot, state, nodeId) {
      parser.push("CLUSTER", "SETSLOT", slot.toString(), state);
      if (nodeId) {
        parser.push(nodeId);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CLUSTER_SLOTS.js
var require_CLUSTER_SLOTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CLUSTER", "SLOTS");
    },
    transformReply(reply) {
      return reply.map(([from, to, master, ...replicas]) => ({
        from,
        to,
        master: transformNode(master),
        replicas: replicas.map(transformNode)
      }));
    }
  };
  function transformNode(node) {
    const [host, port, id] = node;
    return {
      host,
      port,
      id
    };
  }
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_COUNT.js
var require_COMMAND_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND", "COUNT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYS.js
var require_COMMAND_GETKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYS");
      parser.push(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_GETKEYSANDFLAGS.js
var require_COMMAND_GETKEYSANDFLAGS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, args) {
      parser.push("COMMAND", "GETKEYSANDFLAGS");
      parser.push(...args);
    },
    transformReply(reply) {
      return reply.map((entry) => {
        const [key, flags] = entry;
        return {
          key,
          flags
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_INFO.js
var require_COMMAND_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, commands) {
      parser.push("COMMAND", "INFO", ...commands);
    },
    transformReply(reply) {
      return reply.map((command) => command ? (0, generic_transformers_1.transformCommandReply)(command) : null);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND_LIST.js
var require_COMMAND_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.COMMAND_LIST_FILTER_BY = undefined;
  exports.COMMAND_LIST_FILTER_BY = {
    MODULE: "MODULE",
    ACLCAT: "ACLCAT",
    PATTERN: "PATTERN"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, options) {
      parser.push("COMMAND", "LIST");
      if (options?.FILTERBY) {
        parser.push("FILTERBY", options.FILTERBY.type, options.FILTERBY.value);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COMMAND.js
var require_COMMAND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("COMMAND");
    },
    transformReply(reply) {
      return reply.map(generic_transformers_1.transformCommandReply);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, parameters) {
      parser.push("CONFIG", "GET");
      parser.pushVariadic(parameters);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_RESETSTAT.js
var require_CONFIG_RESETSTAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "RESETSTAT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_REWRITE.js
var require_CONFIG_REWRITE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("CONFIG", "REWRITE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, ...[parameterOrConfig, value]) {
      parser.push("CONFIG", "SET");
      if (typeof parameterOrConfig === "string" || parameterOrConfig instanceof Buffer) {
        parser.push(parameterOrConfig, value);
      } else {
        for (const [key, value2] of Object.entries(parameterOrConfig)) {
          parser.push(key, value2);
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/COPY.js
var require_COPY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      parser.push("COPY");
      parser.pushKeys([source, destination]);
      if (options?.DB) {
        parser.push("DB", options.DB.toString());
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DBSIZE.js
var require_DBSIZE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("DBSIZE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DECR.js
var require_DECR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("DECR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DECRBY.js
var require_DECRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, decrement) {
      parser.push("DECRBY");
      parser.pushKey(key);
      parser.push(decrement.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DEL.js
var require_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("DEL");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/DUMP.js
var require_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("DUMP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ECHO.js
var require_ECHO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("ECHO", message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EVAL.js
var require_EVAL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseEvalArguments = undefined;
  function parseEvalArguments(parser, script, options) {
    parser.push(script);
    if (options?.keys) {
      parser.pushKeysLength(options.keys);
    } else {
      parser.push("0");
    }
    if (options?.arguments) {
      parser.push(...options.arguments);
    }
  }
  exports.parseEvalArguments = parseEvalArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVAL");
      parseEvalArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EVAL_RO.js
var require_EVAL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVAL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA_RO.js
var require_EVALSHA_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("EVALSHA_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/EVALSHA.js
var require_EVALSHA = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("EVALSHA");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOADD.js
var require_GEOADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, toAdd, options) {
      parser.push("GEOADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      if (Array.isArray(toAdd)) {
        for (const member of toAdd) {
          pushMember(parser, member);
        }
      } else {
        pushMember(parser, toAdd);
      }
    },
    transformReply: undefined
  };
  function pushMember(parser, { longitude, latitude, member }) {
    parser.push(longitude.toString(), latitude.toString(), member);
  }
});

// node_modules/@redis/client/dist/lib/commands/GEODIST.js
var require_GEODIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member1, member2, unit) {
      parser.push("GEODIST");
      parser.pushKey(key);
      parser.push(member1, member2);
      if (unit) {
        parser.push(unit);
      }
    },
    transformReply(reply) {
      return reply === null ? null : Number(reply);
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOHASH.js
var require_GEOHASH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOHASH");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOPOS.js
var require_GEOPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("GEOPOS");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply(reply) {
      return reply.map((item) => {
        const unwrapped = item;
        return unwrapped === null ? null : {
          longitude: unwrapped[0],
          latitude: unwrapped[1]
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH.js
var require_GEOSEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoSearchOptions = exports.parseGeoSearchArguments = undefined;
  function parseGeoSearchArguments(parser, key, from, by, options) {
    parser.pushKey(key);
    if (typeof from === "string" || from instanceof Buffer) {
      parser.push("FROMMEMBER", from);
    } else {
      parser.push("FROMLONLAT", from.longitude.toString(), from.latitude.toString());
    }
    if ("radius" in by) {
      parser.push("BYRADIUS", by.radius.toString(), by.unit);
    } else {
      parser.push("BYBOX", by.width.toString(), by.height.toString(), by.unit);
    }
    parseGeoSearchOptions(parser, options);
  }
  exports.parseGeoSearchArguments = parseGeoSearchArguments;
  function parseGeoSearchOptions(parser, options) {
    if (options?.SORT) {
      parser.push(options.SORT);
    }
    if (options?.COUNT) {
      if (typeof options.COUNT === "number") {
        parser.push("COUNT", options.COUNT.toString());
      } else {
        parser.push("COUNT", options.COUNT.value.toString());
        if (options.COUNT.ANY) {
          parser.push("ANY");
        }
      }
    }
  }
  exports.parseGeoSearchOptions = parseGeoSearchOptions;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, from, by, options) {
      parser.push("GEOSEARCH");
      parseGeoSearchArguments(parser, key, from, by, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS.js
var require_GEORADIUS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from.longitude.toString(), from.latitude.toString(), radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusArguments = parseGeoRadiusArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("GEORADIUS");
      return parseGeoRadiusArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCH_WITH.js
var require_GEOSEARCH_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GEO_REPLY_WITH = undefined;
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  exports.GEO_REPLY_WITH = {
    DISTANCE: "WITHDIST",
    HASH: "WITHHASH",
    COORDINATES: "WITHCOORD"
  };
  exports.default = {
    IS_READ_ONLY: GEOSEARCH_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, by, replyWith, options) {
      GEOSEARCH_1.default.parseCommand(parser, key, from, by, options);
      parser.push(...replyWith);
      parser.preserve = replyWith;
    },
    transformReply(reply, replyWith) {
      const replyWithSet = new Set(replyWith);
      let index = 0;
      const distanceIndex = replyWithSet.has(exports.GEO_REPLY_WITH.DISTANCE) && ++index, hashIndex = replyWithSet.has(exports.GEO_REPLY_WITH.HASH) && ++index, coordinatesIndex = replyWithSet.has(exports.GEO_REPLY_WITH.COORDINATES) && ++index;
      return reply.map((raw2) => {
        const unwrapped = raw2;
        const item = {
          member: unwrapped[0]
        };
        if (distanceIndex) {
          item.distance = unwrapped[distanceIndex];
        }
        if (hashIndex) {
          item.hash = unwrapped[hashIndex];
        }
        if (coordinatesIndex) {
          const [longitude, latitude] = unwrapped[coordinatesIndex];
          item.coordinates = {
            longitude,
            latitude
          };
        }
        return item;
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_WITH.js
var require_GEORADIUS_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusWithArguments = undefined;
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options) {
    (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
    parser.pushVariadic(replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusWithArguments = parseGeoRadiusWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUS");
      parseGeoRadiusWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO_WITH.js
var require_GEORADIUS_RO_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_WITH_1 = require_GEORADIUS_WITH();
  var GEORADIUS_WITH_2 = __importDefault(require_GEORADIUS_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_WITH_1.parseGeoRadiusWithArguments)(...args);
    },
    transformReply: GEORADIUS_WITH_2.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_RO.js
var require_GEORADIUS_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("GEORADIUS_RO");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(...args);
    },
    transformReply: GEORADIUS_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUS_STORE.js
var require_GEORADIUS_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUS_1 = __importStar(require_GEORADIUS());
  exports.default = {
    IS_READ_ONLY: GEORADIUS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUS");
      (0, GEORADIUS_1.parseGeoRadiusArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER.js
var require_GEORADIUSBYMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberArguments = undefined;
  var GEOSEARCH_1 = require_GEOSEARCH();
  function parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
  }
  exports.parseGeoRadiusByMemberArguments = parseGeoRadiusByMemberArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, from, radius, unit, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberArguments(parser, key, from, radius, unit, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_WITH.js
var require_GEORADIUSBYMEMBER_WITH = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseGeoRadiusByMemberWithArguments = undefined;
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_1 = require_GEOSEARCH();
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  function parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options) {
    parser.pushKey(key);
    parser.push(from, radius.toString(), unit);
    (0, GEOSEARCH_1.parseGeoSearchOptions)(parser, options);
    parser.push(...replyWith);
    parser.preserve = replyWith;
  }
  exports.parseGeoRadiusByMemberWithArguments = parseGeoRadiusByMemberWithArguments;
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, replyWith, options) {
      parser.push("GEORADIUSBYMEMBER");
      parseGeoRadiusByMemberWithArguments(parser, key, from, radius, unit, replyWith, options);
    },
    transformReply: GEOSEARCH_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO_WITH.js
var require_GEORADIUSBYMEMBER_RO_WITH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_WITH_1 = __importStar(require_GEORADIUSBYMEMBER_WITH());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_WITH_1.parseGeoRadiusByMemberWithArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_WITH_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_RO.js
var require_GEORADIUSBYMEMBER_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("GEORADIUSBYMEMBER_RO");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(...args);
    },
    transformReply: GEORADIUSBYMEMBER_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/GEORADIUSBYMEMBER_STORE.js
var require_GEORADIUSBYMEMBER_STORE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEORADIUSBYMEMBER_1 = __importStar(require_GEORADIUSBYMEMBER());
  exports.default = {
    IS_READ_ONLY: GEORADIUSBYMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, from, radius, unit, destination, options) {
      parser.push("GEORADIUSBYMEMBER");
      (0, GEORADIUSBYMEMBER_1.parseGeoRadiusByMemberArguments)(parser, key, from, radius, unit, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
        parser.pushKey(destination);
      } else {
        parser.push("STORE");
        parser.pushKey(destination);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GEOSEARCHSTORE.js
var require_GEOSEARCHSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var GEOSEARCH_1 = require_GEOSEARCH();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, from, by, options) {
      parser.push("GEOSEARCHSTORE");
      if (destination !== undefined) {
        parser.pushKey(destination);
      }
      (0, GEOSEARCH_1.parseGeoSearchArguments)(parser, source, from, by, options);
      if (options?.STOREDIST) {
        parser.push("STOREDIST");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GET.js
var require_GET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETBIT.js
var require_GETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, offset) {
      parser.push("GETBIT");
      parser.pushKey(key);
      parser.push(offset.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETDEL.js
var require_GETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("GETDEL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETEX.js
var require_GETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("GETEX");
      parser.pushKey(key);
      if ("type" in options) {
        switch (options.type) {
          case "EX":
          case "PX":
            parser.push(options.type, options.value.toString());
            break;
          case "EXAT":
          case "PXAT":
            parser.push(options.type, (0, generic_transformers_1.transformEXAT)(options.value));
            break;
          case "PERSIST":
            parser.push("PERSIST");
            break;
        }
      } else {
        if ("EX" in options) {
          parser.push("EX", options.EX.toString());
        } else if ("PX" in options) {
          parser.push("PX", options.PX.toString());
        } else if ("EXAT" in options) {
          parser.push("EXAT", (0, generic_transformers_1.transformEXAT)(options.EXAT));
        } else if ("PXAT" in options) {
          parser.push("PXAT", (0, generic_transformers_1.transformPXAT)(options.PXAT));
        } else {
          parser.push("PERSIST");
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETRANGE.js
var require_GETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, end) {
      parser.push("GETRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), end.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/GETSET.js
var require_GETSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, value) {
      parser.push("GETSET");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXISTS.js
var require_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("EXISTS");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIRE.js
var require_EXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, seconds, mode) {
      parser.push("EXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIREAT.js
var require_EXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, timestamp, mode) {
      parser.push("EXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/EXPIRETIME.js
var require_EXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("EXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FLUSHALL.js
var require_FLUSHALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDIS_FLUSH_MODES = undefined;
  exports.REDIS_FLUSH_MODES = {
    ASYNC: "ASYNC",
    SYNC: "SYNC"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHALL");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FLUSHDB.js
var require_FLUSHDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FLUSHDB");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FCALL.js
var require_FCALL = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/FCALL_RO.js
var require_FCALL_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var EVAL_1 = __importStar(require_EVAL());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("FCALL_RO");
      (0, EVAL_1.parseEvalArguments)(...args);
    },
    transformReply: EVAL_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DELETE.js
var require_FUNCTION_DELETE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, library) {
      parser.push("FUNCTION", "DELETE", library);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_DUMP.js
var require_FUNCTION_DUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "DUMP");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_FLUSH.js
var require_FUNCTION_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, mode) {
      parser.push("FUNCTION", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_KILL.js
var require_FUNCTION_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "KILL");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST.js
var require_FUNCTION_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, options) {
      parser.push("FUNCTION", "LIST");
      if (options?.LIBRARYNAME) {
        parser.push("LIBRARYNAME", options.LIBRARYNAME);
      }
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            })
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LIST_WITHCODE.js
var require_FUNCTION_LIST_WITHCODE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  exports.default = {
    NOT_KEYED_COMMAND: FUNCTION_LIST_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: FUNCTION_LIST_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      FUNCTION_LIST_1.default.parseCommand(...args);
      args[0].push("WITHCODE");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((library) => {
          const unwrapped = library;
          return {
            library_name: unwrapped[1],
            engine: unwrapped[3],
            functions: unwrapped[5].map((fn) => {
              const unwrapped2 = fn;
              return {
                name: unwrapped2[1],
                description: unwrapped2[3],
                flags: unwrapped2[5]
              };
            }),
            library_code: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_LOAD.js
var require_FUNCTION_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, code, options) {
      parser.push("FUNCTION", "LOAD");
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      parser.push(code);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_RESTORE.js
var require_FUNCTION_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, dump, options) {
      parser.push("FUNCTION", "RESTORE", dump);
      if (options?.mode) {
        parser.push(options.mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/FUNCTION_STATS.js
var require_FUNCTION_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FUNCTION", "STATS");
    },
    transformReply: {
      2: (reply) => {
        return {
          running_script: transformRunningScript(reply[1]),
          engines: transformEngines(reply[3])
        };
      },
      3: undefined
    }
  };
  function transformRunningScript(reply) {
    if ((0, generic_transformers_1.isNullReply)(reply)) {
      return null;
    }
    const unwraped = reply;
    return {
      name: unwraped[1],
      command: unwraped[3],
      duration_ms: unwraped[5]
    };
  }
  function transformEngines(reply) {
    const unwraped = reply;
    const engines = Object.create(null);
    for (let i = 0;i < unwraped.length; i++) {
      const name = unwraped[i], stats = unwraped[++i], unwrapedStats = stats;
      engines[name.toString()] = {
        libraries_count: unwrapedStats[1],
        functions_count: unwrapedStats[3]
      };
    }
    return engines;
  }
});

// node_modules/@redis/client/dist/lib/commands/HDEL.js
var require_HDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field) {
      parser.push("HDEL");
      parser.pushKey(key);
      parser.pushVariadic(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HELLO.js
var require_HELLO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, protover, options) {
      parser.push("HELLO");
      if (protover) {
        parser.push(protover.toString());
        if (options?.AUTH) {
          parser.push("AUTH", options.AUTH.username, options.AUTH.password);
        }
        if (options?.SETNAME) {
          parser.push("SETNAME", options.SETNAME);
        }
      }
    },
    transformReply: {
      2: (reply) => ({
        server: reply[1],
        version: reply[3],
        proto: reply[5],
        id: reply[7],
        mode: reply[9],
        role: reply[11],
        modules: reply[13]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXISTS.js
var require_HEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HEXISTS");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRE.js
var require_HEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION = undefined;
  exports.HASH_EXPIRATION = {
    FIELD_NOT_EXISTS: -2,
    CONDITION_NOT_MET: 0,
    UPDATED: 1,
    DELETED: 2
  };
  exports.default = {
    parseCommand(parser, key, fields, seconds, mode) {
      parser.push("HEXPIRE");
      parser.pushKey(key);
      parser.push(seconds.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIREAT.js
var require_HEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformEXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HEXPIRETIME.js
var require_HEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HASH_EXPIRATION_TIME = undefined;
  exports.HASH_EXPIRATION_TIME = {
    FIELD_NOT_EXISTS: -2,
    NO_EXPIRATION: -1
  };
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGET.js
var require_HGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HGET");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETALL.js
var require_HGETALL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HGETALL");
      parser.pushKey(key);
    },
    TRANSFORM_LEGACY_REPLY: true,
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETDEL.js
var require_HGETDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HGETDEL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HGETEX.js
var require_HGETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HGETEX");
      parser.pushKey(key);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "PERSIST") {
          parser.push("PERSIST");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HINCRBY.js
var require_HINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBY");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HINCRBYFLOAT.js
var require_HINCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, field, increment) {
      parser.push("HINCRBYFLOAT");
      parser.pushKey(key);
      parser.push(field, increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HKEYS.js
var require_HKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HKEYS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HLEN.js
var require_HLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HMGET.js
var require_HMGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HMGET");
      parser.pushKey(key);
      parser.pushVariadic(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPERSIST.js
var require_HPERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields) {
      parser.push("HPERSIST");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRE.js
var require_HPEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, fields, ms, mode) {
      parser.push("HPEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIREAT.js
var require_HPEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields, timestamp, mode) {
      parser.push("HPEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(timestamp));
      if (mode) {
        parser.push(mode);
      }
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPEXPIRETIME.js
var require_HPEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPEXPIRETIME");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HPTTL.js
var require_HPTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HPTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT_WITHVALUES.js
var require_HRANDFIELD_COUNT_WITHVALUES = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString(), "WITHVALUES");
    },
    transformReply: {
      2: (rawReply) => {
        const reply = [];
        let i = 0;
        while (i < rawReply.length) {
          reply.push({
            field: rawReply[i++],
            value: rawReply[i++]
          });
        }
        return reply;
      },
      3: (reply) => {
        return reply.map((entry) => {
          const [field, value] = entry;
          return {
            field,
            value
          };
        });
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD_COUNT.js
var require_HRANDFIELD_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HRANDFIELD.js
var require_HRANDFIELD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HRANDFIELD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCAN.js
var require_SCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushScanArguments = exports.parseScanArguments = undefined;
  function parseScanArguments(parser, cursor, options) {
    parser.push(cursor);
    if (options?.MATCH) {
      parser.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      parser.push("COUNT", options.COUNT.toString());
    }
  }
  exports.parseScanArguments = parseScanArguments;
  function pushScanArguments(args, cursor, options) {
    args.push(cursor.toString());
    if (options?.MATCH) {
      args.push("MATCH", options.MATCH);
    }
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.pushScanArguments = pushScanArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, cursor, options) {
      parser.push("SCAN");
      parseScanArguments(parser, cursor, options);
      if (options?.TYPE) {
        parser.push("TYPE", options.TYPE);
      }
    },
    transformReply([cursor, keys]) {
      return {
        cursor,
        keys
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSCAN.js
var require_HSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("HSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawEntries]) {
      const entries = [];
      let i = 0;
      while (i < rawEntries.length) {
        entries.push({
          field: rawEntries[i++],
          value: rawEntries[i++]
        });
      }
      return {
        cursor,
        entries
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSCAN_NOVALUES.js
var require_HSCAN_NOVALUES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var HSCAN_1 = __importDefault(require_HSCAN());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      HSCAN_1.default.parseCommand(...args);
      parser.push("NOVALUES");
    },
    transformReply([cursor, fields]) {
      return {
        cursor,
        fields
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/HSET.js
var require_HSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, ...[key, value, fieldValue]) {
      parser.push("HSET");
      parser.pushKey(key);
      if (typeof value === "string" || typeof value === "number" || value instanceof Buffer) {
        parser.push(convertValue(value), convertValue(fieldValue));
      } else if (value instanceof Map) {
        pushMap(parser, value);
      } else if (Array.isArray(value)) {
        pushTuples(parser, value);
      } else {
        pushObject(parser, value);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map2) {
    for (const [key, value] of map2.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    for (const tuple2 of tuples) {
      if (Array.isArray(tuple2)) {
        pushTuples(parser, tuple2);
        continue;
      }
      parser.push(convertValue(tuple2));
    }
  }
  function pushObject(parser, object2) {
    for (const key of Object.keys(object2)) {
      parser.push(convertValue(key), convertValue(object2[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// node_modules/@redis/client/dist/lib/commands/HSETEX.js
var require_HSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var parser_1 = require_parser();
  exports.default = {
    parseCommand(parser, key, fields, options) {
      parser.push("HSETEX");
      parser.pushKey(key);
      if (options?.mode) {
        parser.push(options.mode);
      }
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      }
      parser.push("FIELDS");
      if (fields instanceof Map) {
        pushMap(parser, fields);
      } else if (Array.isArray(fields)) {
        pushTuples(parser, fields);
      } else {
        pushObject(parser, fields);
      }
    },
    transformReply: undefined
  };
  function pushMap(parser, map2) {
    parser.push(map2.size.toString());
    for (const [key, value] of map2.entries()) {
      parser.push(convertValue(key), convertValue(value));
    }
  }
  function pushTuples(parser, tuples) {
    const tmpParser = new parser_1.BasicCommandParser;
    _pushTuples(tmpParser, tuples);
    if (tmpParser.redisArgs.length % 2 != 0) {
      throw Error("invalid number of arguments, expected key value ....[key value] pairs, got key without value");
    }
    parser.push((tmpParser.redisArgs.length / 2).toString());
    parser.push(...tmpParser.redisArgs);
  }
  function _pushTuples(parser, tuples) {
    for (const tuple2 of tuples) {
      if (Array.isArray(tuple2)) {
        _pushTuples(parser, tuple2);
        continue;
      }
      parser.push(convertValue(tuple2));
    }
  }
  function pushObject(parser, object2) {
    const len = Object.keys(object2).length;
    if (len == 0) {
      throw Error("object without keys");
    }
    parser.push(len.toString());
    for (const key of Object.keys(object2)) {
      parser.push(convertValue(key), convertValue(object2[key]));
    }
  }
  function convertValue(value) {
    return typeof value === "number" ? value.toString() : value;
  }
});

// node_modules/@redis/client/dist/lib/commands/HSETNX.js
var require_HSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, field, value) {
      parser.push("HSETNX");
      parser.pushKey(key);
      parser.push(field, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HSTRLEN.js
var require_HSTRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, field) {
      parser.push("HSTRLEN");
      parser.pushKey(key);
      parser.push(field);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HTTL.js
var require_HTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, fields) {
      parser.push("HTTL");
      parser.pushKey(key);
      parser.push("FIELDS");
      parser.pushVariadicWithLength(fields);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/HVALS.js
var require_HVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("HVALS");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCR.js
var require_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("INCR");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCRBY.js
var require_INCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBY");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INCRBYFLOAT.js
var require_INCRBYFLOAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, increment) {
      parser.push("INCRBYFLOAT");
      parser.pushKey(key);
      parser.push(increment.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/INFO.js
var require_INFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, section) {
      parser.push("INFO");
      if (section) {
        parser.push(section);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/KEYS.js
var require_KEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("KEYS", pattern);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LASTSAVE.js
var require_LASTSAVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LASTSAVE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_DOCTOR.js
var require_LATENCY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_GRAPH.js
var require_LATENCY_GRAPH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LATENCY_EVENTS = undefined;
  exports.LATENCY_EVENTS = {
    ACTIVE_DEFRAG_CYCLE: "active-defrag-cycle",
    AOF_FSYNC_ALWAYS: "aof-fsync-always",
    AOF_STAT: "aof-stat",
    AOF_REWRITE_DIFF_WRITE: "aof-rewrite-diff-write",
    AOF_RENAME: "aof-rename",
    AOF_WRITE: "aof-write",
    AOF_WRITE_ACTIVE_CHILD: "aof-write-active-child",
    AOF_WRITE_ALONE: "aof-write-alone",
    AOF_WRITE_PENDING_FSYNC: "aof-write-pending-fsync",
    COMMAND: "command",
    EXPIRE_CYCLE: "expire-cycle",
    EVICTION_CYCLE: "eviction-cycle",
    EVICTION_DEL: "eviction-del",
    FAST_COMMAND: "fast-command",
    FORK: "fork",
    RDB_UNLINK_TEMP_FILE: "rdb-unlink-temp-file"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "GRAPH", event);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_HISTORY.js
var require_LATENCY_HISTORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, event) {
      parser.push("LATENCY", "HISTORY", event);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LATENCY_LATEST.js
var require_LATENCY_LATEST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("LATENCY", "LATEST");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS.js
var require_LCS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key1, key2) {
      parser.push("LCS");
      parser.pushKeys([key1, key2]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX.js
var require_LCS_IDX = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(parser, key1, key2, options) {
      LCS_1.default.parseCommand(parser, key1, key2);
      parser.push("IDX");
      if (options?.MINMATCHLEN) {
        parser.push("MINMATCHLEN", options.MINMATCHLEN.toString());
      }
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_IDX_WITHMATCHLEN.js
var require_LCS_IDX_WITHMATCHLEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  exports.default = {
    IS_READ_ONLY: LCS_IDX_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_IDX_1.default.parseCommand(...args);
      parser.push("WITHMATCHLEN");
    },
    transformReply: {
      2: (reply) => ({
        matches: reply[1],
        len: reply[3]
      }),
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/LCS_LEN.js
var require_LCS_LEN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LCS_1 = __importDefault(require_LCS());
  exports.default = {
    IS_READ_ONLY: LCS_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      LCS_1.default.parseCommand(...args);
      parser.push("LEN");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LINDEX.js
var require_LINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, index) {
      parser.push("LINDEX");
      parser.pushKey(key);
      parser.push(index.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LINSERT.js
var require_LINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, position, pivot, element) {
      parser.push("LINSERT");
      parser.pushKey(key);
      parser.push(position, pivot, element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LLEN.js
var require_LLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("LLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LMOVE.js
var require_LMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, sourceSide, destinationSide) {
      parser.push("LMOVE");
      parser.pushKeys([source, destination]);
      parser.push(sourceSide, destinationSide);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LOLWUT.js
var require_LOLWUT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, version2, ...optionalArguments) {
      parser.push("LOLWUT");
      if (version2) {
        parser.push("VERSION", version2.toString());
        parser.pushVariadic(optionalArguments.map(String));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOP.js
var require_LPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("LPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOP_COUNT.js
var require_LPOP_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOP_1 = __importDefault(require_LPOP());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      LPOP_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOS.js
var require_LPOS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, element, options) {
      parser.push("LPOS");
      parser.pushKey(key);
      parser.push(element);
      if (options?.RANK !== undefined) {
        parser.push("RANK", options.RANK.toString());
      }
      if (options?.MAXLEN !== undefined) {
        parser.push("MAXLEN", options.MAXLEN.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPOS_COUNT.js
var require_LPOS_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var LPOS_1 = __importDefault(require_LPOS());
  exports.default = {
    CACHEABLE: LPOS_1.default.CACHEABLE,
    IS_READ_ONLY: LPOS_1.default.IS_READ_ONLY,
    parseCommand(parser, key, element, count, options) {
      LPOS_1.default.parseCommand(parser, key, element, options);
      parser.push("COUNT", count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPUSH.js
var require_LPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSH");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LPUSHX.js
var require_LPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, elements) {
      parser.push("LPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(elements);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LRANGE.js
var require_LRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, start, stop) {
      parser.push("LRANGE");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LREM.js
var require_LREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count, element) {
      parser.push("LREM");
      parser.pushKey(key);
      parser.push(count.toString());
      parser.push(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LSET.js
var require_LSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, index, element) {
      parser.push("LSET");
      parser.pushKey(key);
      parser.push(index.toString(), element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/LTRIM.js
var require_LTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, start, stop) {
      parser.push("LTRIM");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_DOCTOR.js
var require_MEMORY_DOCTOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "DOCTOR");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_MALLOC-STATS.js
var require_MEMORY_MALLOC_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "MALLOC-STATS");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_PURGE.js
var require_MEMORY_PURGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser) {
      parser.push("MEMORY", "PURGE");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_STATS.js
var require_MEMORY_STATS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MEMORY", "STATS");
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const reply = {};
        let i = 0;
        while (i < rawReply.length) {
          switch (rawReply[i].toString()) {
            case "dataset.percentage":
            case "peak.percentage":
            case "allocator-fragmentation.ratio":
            case "allocator-rss.ratio":
            case "rss-overhead.ratio":
            case "fragmentation":
              reply[rawReply[i++]] = generic_transformers_1.transformDoubleReply[2](rawReply[i++], preserve, typeMapping);
              break;
            default:
              reply[rawReply[i++]] = rawReply[i++];
          }
        }
        return reply;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/MEMORY_USAGE.js
var require_MEMORY_USAGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("MEMORY", "USAGE");
      parser.pushKey(key);
      if (options?.SAMPLES) {
        parser.push("SAMPLES", options.SAMPLES.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MGET.js
var require_MGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("MGET");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MIGRATE.js
var require_MIGRATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, host, port, key, destinationDb, timeout, options) {
      parser.push("MIGRATE", host, port.toString());
      const isKeyArray = Array.isArray(key);
      if (isKeyArray) {
        parser.push("");
      } else {
        parser.push(key);
      }
      parser.push(destinationDb.toString(), timeout.toString());
      if (options?.COPY) {
        parser.push("COPY");
      }
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.AUTH) {
        if (options.AUTH.username) {
          parser.push("AUTH2", options.AUTH.username, options.AUTH.password);
        } else {
          parser.push("AUTH", options.AUTH.password);
        }
      }
      if (isKeyArray) {
        parser.push("KEYS");
        parser.pushVariadic(key);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LIST.js
var require_MODULE_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("MODULE", "LIST");
    },
    transformReply: {
      2: (reply) => {
        return reply.map((module2) => {
          const unwrapped = module2;
          return {
            name: unwrapped[1],
            ver: unwrapped[3]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_LOAD.js
var require_MODULE_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, path, moduleArguments) {
      parser.push("MODULE", "LOAD", path);
      if (moduleArguments) {
        parser.push(...moduleArguments);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MODULE_UNLOAD.js
var require_MODULE_UNLOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, name) {
      parser.push("MODULE", "UNLOAD", name);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MOVE.js
var require_MOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, db) {
      parser.push("MOVE");
      parser.pushKey(key);
      parser.push(db.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MSET.js
var require_MSET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseMSetArguments = undefined;
  function parseMSetArguments(parser, toSet) {
    if (Array.isArray(toSet)) {
      if (toSet.length == 0) {
        throw new Error("empty toSet Argument");
      }
      if (Array.isArray(toSet[0])) {
        for (const tuple2 of toSet) {
          parser.pushKey(tuple2[0]);
          parser.push(tuple2[1]);
        }
      } else {
        const arr = toSet;
        for (let i = 0;i < arr.length; i += 2) {
          parser.pushKey(arr[i]);
          parser.push(arr[i + 1]);
        }
      }
    } else {
      for (const tuple2 of Object.entries(toSet)) {
        parser.pushKey(tuple2[0]);
        parser.push(tuple2[1]);
      }
    }
  }
  exports.parseMSetArguments = parseMSetArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSET");
      return parseMSetArguments(parser, toSet);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/MSETNX.js
var require_MSETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MSET_1 = require_MSET();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, toSet) {
      parser.push("MSETNX");
      return (0, MSET_1.parseMSetArguments)(parser, toSet);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_ENCODING.js
var require_OBJECT_ENCODING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "ENCODING");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_FREQ.js
var require_OBJECT_FREQ = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "FREQ");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_IDLETIME.js
var require_OBJECT_IDLETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "IDLETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/OBJECT_REFCOUNT.js
var require_OBJECT_REFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("OBJECT", "REFCOUNT");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PERSIST.js
var require_PERSIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("PERSIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRE.js
var require_PEXPIRE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, ms, mode) {
      parser.push("PEXPIRE");
      parser.pushKey(key);
      parser.push(ms.toString());
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIREAT.js
var require_PEXPIREAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, msTimestamp, mode) {
      parser.push("PEXPIREAT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformPXAT)(msTimestamp));
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PEXPIRETIME.js
var require_PEXPIRETIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PEXPIRETIME");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFADD.js
var require_PFADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("PFADD");
      parser.pushKey(key);
      if (element) {
        parser.pushVariadic(element);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFCOUNT.js
var require_PFCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("PFCOUNT");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PFMERGE.js
var require_PFMERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, sources) {
      parser.push("PFMERGE");
      parser.pushKey(destination);
      if (sources) {
        parser.pushKeys(sources);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PING.js
var require_PING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, message) {
      parser.push("PING");
      if (message) {
        parser.push(message);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PSETEX.js
var require_PSETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, ms, value) {
      parser.push("PSETEX");
      parser.pushKey(key);
      parser.push(ms.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PTTL.js
var require_PTTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("PTTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBLISH.js
var require_PUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    IS_FORWARD_COMMAND: true,
    parseCommand(parser, channel, message) {
      parser.push("PUBLISH", channel, message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_CHANNELS.js
var require_PUBSUB_CHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "CHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMPAT.js
var require_PUBSUB_NUMPAT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("PUBSUB", "NUMPAT");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_NUMSUB.js
var require_PUBSUB_NUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "NUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(rawReply) {
      const reply = Object.create(null);
      let i = 0;
      while (i < rawReply.length) {
        reply[rawReply[i++].toString()] = rawReply[i++].toString();
      }
      return reply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDNUMSUB.js
var require_PUBSUB_SHARDNUMSUB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channels) {
      parser.push("PUBSUB", "SHARDNUMSUB");
      if (channels) {
        parser.pushVariadic(channels);
      }
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (let i = 0;i < reply.length; i += 2) {
        transformedReply[reply[i].toString()] = reply[i + 1];
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/PUBSUB_SHARDCHANNELS.js
var require_PUBSUB_SHARDCHANNELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, pattern) {
      parser.push("PUBSUB", "SHARDCHANNELS");
      if (pattern) {
        parser.push(pattern);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RANDOMKEY.js
var require_RANDOMKEY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RANDOMKEY");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/READONLY.js
var require_READONLY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("READONLY");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RENAME.js
var require_RENAME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAME");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RENAMENX.js
var require_RENAMENX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, newKey) {
      parser.push("RENAMENX");
      parser.pushKeys([key, newKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/REPLICAOF.js
var require_REPLICAOF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, host, port) {
      parser.push("REPLICAOF", host, port.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RESTORE-ASKING.js
var require_RESTORE_ASKING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("RESTORE-ASKING");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RESTORE.js
var require_RESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, ttl, serializedValue, options) {
      parser.push("RESTORE");
      parser.pushKey(key);
      parser.push(ttl.toString(), serializedValue);
      if (options?.REPLACE) {
        parser.push("REPLACE");
      }
      if (options?.ABSTTL) {
        parser.push("ABSTTL");
      }
      if (options?.IDLETIME) {
        parser.push("IDLETIME", options.IDLETIME.toString());
      }
      if (options?.FREQ) {
        parser.push("FREQ", options.FREQ.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ROLE.js
var require_ROLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("ROLE");
    },
    transformReply(reply) {
      switch (reply[0]) {
        case "master": {
          const [role, replicationOffest, replicas] = reply;
          return {
            role,
            replicationOffest,
            replicas: replicas.map((replica) => {
              const [host, port, replicationOffest2] = replica;
              return {
                host,
                port: Number(port),
                replicationOffest: Number(replicationOffest2)
              };
            })
          };
        }
        case "slave": {
          const [role, masterHost, masterPort, state, dataReceived] = reply;
          return {
            role,
            master: {
              host: masterHost,
              port: masterPort
            },
            state,
            dataReceived
          };
        }
        case "sentinel": {
          const [role, masterNames] = reply;
          return {
            role,
            masterNames
          };
        }
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOP_COUNT.js
var require_RPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, count) {
      parser.push("RPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOP.js
var require_RPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key) {
      parser.push("RPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPOPLPUSH.js
var require_RPOPLPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, source, destination) {
      parser.push("RPOPLPUSH");
      parser.pushKeys([source, destination]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPUSH.js
var require_RPUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSH");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/RPUSHX.js
var require_RPUSHX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("RPUSHX");
      parser.pushKey(key);
      parser.pushVariadic(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SADD.js
var require_SADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, members) {
      parser.push("SADD");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCARD.js
var require_SCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_DEBUG.js
var require_SCRIPT_DEBUG = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "DEBUG", mode);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_EXISTS.js
var require_SCRIPT_EXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, sha1) {
      parser.push("SCRIPT", "EXISTS");
      parser.pushVariadic(sha1);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_FLUSH.js
var require_SCRIPT_FLUSH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, mode) {
      parser.push("SCRIPT", "FLUSH");
      if (mode) {
        parser.push(mode);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_KILL.js
var require_SCRIPT_KILL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("SCRIPT", "KILL");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SCRIPT_LOAD.js
var require_SCRIPT_LOAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, script) {
      parser.push("SCRIPT", "LOAD", script);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SDIFF.js
var require_SDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SDIFF");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SDIFFSTORE.js
var require_SDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, destination, keys) {
      parser.push("SDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SET.js
var require_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value, options) {
      parser.push("SET");
      parser.pushKey(key);
      parser.push(typeof value === "number" ? value.toString() : value);
      if (options?.expiration) {
        if (typeof options.expiration === "string") {
          parser.push(options.expiration);
        } else if (options.expiration.type === "KEEPTTL") {
          parser.push("KEEPTTL");
        } else {
          parser.push(options.expiration.type, options.expiration.value.toString());
        }
      } else if (options?.EX !== undefined) {
        parser.push("EX", options.EX.toString());
      } else if (options?.PX !== undefined) {
        parser.push("PX", options.PX.toString());
      } else if (options?.EXAT !== undefined) {
        parser.push("EXAT", options.EXAT.toString());
      } else if (options?.PXAT !== undefined) {
        parser.push("PXAT", options.PXAT.toString());
      } else if (options?.KEEPTTL) {
        parser.push("KEEPTTL");
      }
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.GET) {
        parser.push("GET");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETBIT.js
var require_SETBIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, offset, value) {
      parser.push("SETBIT");
      parser.pushKey(key);
      parser.push(offset.toString(), value.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETEX.js
var require_SETEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, seconds, value) {
      parser.push("SETEX");
      parser.pushKey(key);
      parser.push(seconds.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETNX.js
var require_SETNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, value) {
      parser.push("SETNX");
      parser.pushKey(key);
      parser.push(value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SETRANGE.js
var require_SETRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, key, offset, value) {
      parser.push("SETRANGE");
      parser.pushKey(key);
      parser.push(offset.toString(), value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTER.js
var require_SINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SINTER");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTERCARD.js
var require_SINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("SINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT !== undefined) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SINTERSTORE.js
var require_SINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SINTERSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SISMEMBER.js
var require_SISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("SISMEMBER");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SMEMBERS.js
var require_SMEMBERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SMEMBERS");
      parser.pushKey(key);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/SMISMEMBER.js
var require_SMISMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, members) {
      parser.push("SMISMEMBER");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SMOVE.js
var require_SMOVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, member) {
      parser.push("SMOVE");
      parser.pushKeys([source, destination]);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT.js
var require_SORT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSortArguments = undefined;
  function parseSortArguments(parser, key, options) {
    parser.pushKey(key);
    if (options?.BY) {
      parser.push("BY", options.BY);
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    if (options?.GET) {
      if (Array.isArray(options.GET)) {
        for (const pattern of options.GET) {
          parser.push("GET", pattern);
        }
      } else {
        parser.push("GET", options.GET);
      }
    }
    if (options?.DIRECTION) {
      parser.push(options.DIRECTION);
    }
    if (options?.ALPHA) {
      parser.push("ALPHA");
    }
  }
  exports.parseSortArguments = parseSortArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("SORT");
      parseSortArguments(parser, key, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT_RO.js
var require_SORT_RO = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importStar(require_SORT());
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("SORT_RO");
      (0, SORT_1.parseSortArguments)(...args);
    },
    transformReply: SORT_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/SORT_STORE.js
var require_SORT_STORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SORT_1 = __importDefault(require_SORT());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, source, destination, options) {
      SORT_1.default.parseCommand(parser, source, options);
      parser.push("STORE", destination);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPOP_COUNT.js
var require_SPOP_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("SPOP");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPOP.js
var require_SPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("SPOP");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SPUBLISH.js
var require_SPUBLISH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, channel, message) {
      parser.push("SPUBLISH");
      parser.pushKey(channel);
      parser.push(message);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER.js
var require_SRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("SRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SRANDMEMBER_COUNT.js
var require_SRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: SRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      SRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SREM.js
var require_SREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, members) {
      parser.push("SREM");
      parser.pushKey(key);
      parser.pushVariadic(members);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SSCAN.js
var require_SSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("SSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, members]) {
      return {
        cursor,
        members
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/STRLEN.js
var require_STRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("STRLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SUNION.js
var require_SUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("SUNION");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SUNIONSTORE.js
var require_SUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys) {
      parser.push("SUNIONSTORE");
      parser.pushKey(destination);
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/SWAPDB.js
var require_SWAPDB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index1, index2) {
      parser.push("SWAPDB", index1.toString(), index2.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TIME.js
var require_TIME = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("TIME");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TOUCH.js
var require_TOUCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TOUCH");
      parser.pushKeys(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TTL.js
var require_TTL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TTL");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/TYPE.js
var require_TYPE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TYPE");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/UNLINK.js
var require_UNLINK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, keys) {
      parser.push("UNLINK");
      parser.pushKeys(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/WAIT.js
var require_WAIT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, numberOfReplicas, timeout) {
      parser.push("WAIT", numberOfReplicas.toString(), timeout.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XACK.js
var require_XACK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id) {
      parser.push("XACK");
      parser.pushKey(key);
      parser.push(group);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XADD.js
var require_XADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseXAddArguments = undefined;
  function parseXAddArguments(optional2, parser, key, id, message, options) {
    parser.push("XADD");
    parser.pushKey(key);
    if (optional2) {
      parser.push(optional2);
    }
    if (options?.TRIM) {
      if (options.TRIM.strategy) {
        parser.push(options.TRIM.strategy);
      }
      if (options.TRIM.strategyModifier) {
        parser.push(options.TRIM.strategyModifier);
      }
      parser.push(options.TRIM.threshold.toString());
      if (options.TRIM.limit) {
        parser.push("LIMIT", options.TRIM.limit.toString());
      }
    }
    parser.push(id);
    for (const [key2, value] of Object.entries(message)) {
      parser.push(key2, value);
    }
  }
  exports.parseXAddArguments = parseXAddArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return parseXAddArguments(undefined, ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XADD_NOMKSTREAM.js
var require_XADD_NOMKSTREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XADD_1 = require_XADD();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      return (0, XADD_1.parseXAddArguments)("NOMKSTREAM", ...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM.js
var require_XAUTOCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, start, options) {
      parser.push("XAUTOCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString(), start);
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return {
        nextId: reply[0],
        messages: reply[1].map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping)),
        deletedMessages: reply[2]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XAUTOCLAIM_JUSTID.js
var require_XAUTOCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  exports.default = {
    IS_READ_ONLY: XAUTOCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XAUTOCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply(reply) {
      return {
        nextId: reply[0],
        messages: reply[1],
        deletedMessages: reply[2]
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM.js
var require_XCLAIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer, minIdleTime, id, options) {
      parser.push("XCLAIM");
      parser.pushKey(key);
      parser.push(group, consumer, minIdleTime.toString());
      parser.pushVariadic(id);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      if (options?.TIME !== undefined) {
        parser.push("TIME", (options.TIME instanceof Date ? options.TIME.getTime() : options.TIME).toString());
      }
      if (options?.RETRYCOUNT !== undefined) {
        parser.push("RETRYCOUNT", options.RETRYCOUNT.toString());
      }
      if (options?.FORCE) {
        parser.push("FORCE");
      }
      if (options?.LASTID !== undefined) {
        parser.push("LASTID", options.LASTID);
      }
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageNullReply.bind(undefined, typeMapping));
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XCLAIM_JUSTID.js
var require_XCLAIM_JUSTID = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  exports.default = {
    IS_READ_ONLY: XCLAIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      XCLAIM_1.default.parseCommand(...args);
      parser.push("JUSTID");
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XDEL.js
var require_XDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, id) {
      parser.push("XDEL");
      parser.pushKey(key);
      parser.pushVariadic(id);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATE.js
var require_XGROUP_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "CREATE");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.MKSTREAM) {
        parser.push("MKSTREAM");
      }
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_CREATECONSUMER.js
var require_XGROUP_CREATECONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "CREATECONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DELCONSUMER.js
var require_XGROUP_DELCONSUMER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, consumer) {
      parser.push("XGROUP", "DELCONSUMER");
      parser.pushKey(key);
      parser.push(group, consumer);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_DESTROY.js
var require_XGROUP_DESTROY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group) {
      parser.push("XGROUP", "DESTROY");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XGROUP_SETID.js
var require_XGROUP_SETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, group, id, options) {
      parser.push("XGROUP", "SETID");
      parser.pushKey(key);
      parser.push(group, id);
      if (options?.ENTRIESREAD) {
        parser.push("ENTRIESREAD", options.ENTRIESREAD.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_CONSUMERS.js
var require_XINFO_CONSUMERS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XINFO", "CONSUMERS");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((consumer) => {
          const unwrapped = consumer;
          return {
            name: unwrapped[1],
            pending: unwrapped[3],
            idle: unwrapped[5],
            inactive: unwrapped[7]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_GROUPS.js
var require_XINFO_GROUPS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "GROUPS");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply) => {
        return reply.map((group) => {
          const unwrapped = group;
          return {
            name: unwrapped[1],
            consumers: unwrapped[3],
            pending: unwrapped[5],
            "last-delivered-id": unwrapped[7],
            "entries-read": unwrapped[9],
            lag: unwrapped[11]
          };
        });
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XINFO_STREAM.js
var require_XINFO_STREAM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XINFO", "STREAM");
      parser.pushKey(key);
    },
    transformReply: {
      2(reply) {
        const parsedReply = {};
        for (let i = 0;i < reply.length; i += 2) {
          switch (reply[i]) {
            case "first-entry":
            case "last-entry":
              parsedReply[reply[i]] = transformEntry(reply[i + 1]);
              break;
            default:
              parsedReply[reply[i]] = reply[i + 1];
              break;
          }
        }
        return parsedReply;
      },
      3(reply) {
        if (reply instanceof Map) {
          reply.set("first-entry", transformEntry(reply.get("first-entry")));
          reply.set("last-entry", transformEntry(reply.get("last-entry")));
        } else if (reply instanceof Array) {
          reply[17] = transformEntry(reply[17]);
          reply[19] = transformEntry(reply[19]);
        } else {
          reply["first-entry"] = transformEntry(reply["first-entry"]);
          reply["last-entry"] = transformEntry(reply["last-entry"]);
        }
        return reply;
      }
    }
  };
  function transformEntry(entry) {
    if ((0, generic_transformers_1.isNullReply)(entry))
      return entry;
    const [id, message] = entry;
    return {
      id,
      message: (0, generic_transformers_1.transformTuplesReply)(message)
    };
  }
});

// node_modules/@redis/client/dist/lib/commands/XLEN.js
var require_XLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("XLEN");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XPENDING_RANGE.js
var require_XPENDING_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group, start, end, count, options) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
      if (options?.IDLE !== undefined) {
        parser.push("IDLE", options.IDLE.toString());
      }
      parser.push(start, end, count.toString());
      if (options?.consumer) {
        parser.push(options.consumer);
      }
    },
    transformReply(reply) {
      return reply.map((pending) => {
        const unwrapped = pending;
        return {
          id: unwrapped[0],
          consumer: unwrapped[1],
          millisecondsSinceLastDelivery: unwrapped[2],
          deliveriesCounter: unwrapped[3]
        };
      });
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XPENDING.js
var require_XPENDING = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, group) {
      parser.push("XPENDING");
      parser.pushKey(key);
      parser.push(group);
    },
    transformReply(reply) {
      const consumers = reply[3];
      return {
        pending: reply[0],
        firstId: reply[1],
        lastId: reply[2],
        consumers: consumers === null ? null : consumers.map((consumer) => {
          const [name, deliveriesCounter] = consumer;
          return {
            name,
            deliveriesCounter: Number(deliveriesCounter)
          };
        })
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XRANGE.js
var require_XRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.xRangeArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function xRangeArguments(start, end, options) {
    const args = [start, end];
    if (options?.COUNT) {
      args.push("COUNT", options.COUNT.toString());
    }
    return args;
  }
  exports.xRangeArguments = xRangeArguments;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, ...args) {
      parser.push("XRANGE");
      parser.pushKey(key);
      parser.pushVariadic(xRangeArguments(args[0], args[1], args[2]));
    },
    transformReply(reply, preserve, typeMapping) {
      return reply.map(generic_transformers_1.transformStreamMessageReply.bind(undefined, typeMapping));
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/XREAD.js
var require_XREAD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushXReadStreams = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function pushXReadStreams(parser, streams) {
    parser.push("STREAMS");
    if (Array.isArray(streams)) {
      for (let i = 0;i < streams.length; i++) {
        parser.pushKey(streams[i].key);
      }
      for (let i = 0;i < streams.length; i++) {
        parser.push(streams[i].id);
      }
    } else {
      parser.pushKey(streams.key);
      parser.push(streams.id);
    }
  }
  exports.pushXReadStreams = pushXReadStreams;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, streams, options) {
      parser.push("XREAD");
      if (options?.COUNT) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      pushXReadStreams(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/client/dist/lib/commands/XREADGROUP.js
var require_XREADGROUP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var XREAD_1 = require_XREAD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, group, consumer, streams, options) {
      parser.push("XREADGROUP", "GROUP", group, consumer);
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.BLOCK !== undefined) {
        parser.push("BLOCK", options.BLOCK.toString());
      }
      if (options?.NOACK) {
        parser.push("NOACK");
      }
      (0, XREAD_1.pushXReadStreams)(parser, streams);
    },
    transformReply: {
      2: generic_transformers_1.transformStreamsMessagesReplyResp2,
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/client/dist/lib/commands/XREVRANGE.js
var require_XREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var XRANGE_1 = __importStar(require_XRANGE());
  exports.default = {
    CACHEABLE: XRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: XRANGE_1.default.IS_READ_ONLY,
    parseCommand(parser, key, ...args) {
      parser.push("XREVRANGE");
      parser.pushKey(key);
      parser.pushVariadic((0, XRANGE_1.xRangeArguments)(args[0], args[1], args[2]));
    },
    transformReply: XRANGE_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/XSETID.js
var require_XSETID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, lastId, options) {
      parser.push("XSETID");
      parser.pushKey(key);
      parser.push(lastId);
      if (options?.ENTRIESADDED) {
        parser.push("ENTRIESADDED", options.ENTRIESADDED.toString());
      }
      if (options?.MAXDELETEDID) {
        parser.push("MAXDELETEDID", options.MAXDELETEDID);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/XTRIM.js
var require_XTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, strategy, threshold, options) {
      parser.push("XTRIM");
      parser.pushKey(key);
      parser.push(strategy);
      if (options?.strategyModifier) {
        parser.push(options.strategyModifier);
      }
      parser.push(threshold.toString());
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZADD.js
var require_ZADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pushMembers = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      } else if (options?.LT) {
        parser.push("LT");
      } else if (options?.GT) {
        parser.push("GT");
      }
      if (options?.CH) {
        parser.push("CH");
      }
      pushMembers(parser, members);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
  function pushMembers(parser, members) {
    if (Array.isArray(members)) {
      for (const member of members) {
        pushMember(parser, member);
      }
    } else {
      pushMember(parser, members);
    }
  }
  exports.pushMembers = pushMembers;
  function pushMember(parser, member) {
    parser.push((0, generic_transformers_1.transformDoubleArgument)(member.score), member.value);
  }
});

// node_modules/@redis/client/dist/lib/commands/ZADD_INCR.js
var require_ZADD_INCR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZADD_1 = require_ZADD();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, members, options) {
      parser.push("ZADD");
      parser.pushKey(key);
      if (options?.condition) {
        parser.push(options.condition);
      }
      if (options?.comparison) {
        parser.push(options.comparison);
      }
      if (options?.CH) {
        parser.push("CH");
      }
      parser.push("INCR");
      (0, ZADD_1.pushMembers)(parser, members);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZCARD.js
var require_ZCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZCOUNT.js
var require_ZCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZCOUNT");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF.js
var require_ZDIFF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys) {
      parser.push("ZDIFF");
      parser.pushKeysLength(keys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFF_WITHSCORES.js
var require_ZDIFF_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  exports.default = {
    IS_READ_ONLY: ZDIFF_1.default.IS_READ_ONLY,
    parseCommand(parser, keys) {
      ZDIFF_1.default.parseCommand(parser, keys);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZDIFFSTORE.js
var require_ZDIFFSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, destination, inputKeys) {
      parser.push("ZDIFFSTORE");
      parser.pushKey(destination);
      parser.pushKeysLength(inputKeys);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINCRBY.js
var require_ZINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, increment, member) {
      parser.push("ZINCRBY");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformDoubleArgument)(increment), member);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTER.js
var require_ZINTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseZInterArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseZInterArguments(parser, keys, options) {
    (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
    if (options?.AGGREGATE) {
      parser.push("AGGREGATE", options.AGGREGATE);
    }
  }
  exports.parseZInterArguments = parseZInterArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTER");
      parseZInterArguments(parser, keys, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTER_WITHSCORES.js
var require_ZINTER_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZINTER_1 = __importDefault(require_ZINTER());
  exports.default = {
    IS_READ_ONLY: ZINTER_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      ZINTER_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTERCARD.js
var require_ZINTERCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZINTERCARD");
      parser.pushKeysLength(keys);
      if (typeof options === "number") {
        parser.push("LIMIT", options.toString());
      } else if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZINTERSTORE.js
var require_ZINTERSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZINTER_1 = require_ZINTER();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZINTERSTORE");
      parser.pushKey(destination);
      (0, ZINTER_1.parseZInterArguments)(parser, keys, options);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZLEXCOUNT.js
var require_ZLEXCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max) {
      parser.push("ZLEXCOUNT");
      parser.pushKey(key);
      parser.push(min);
      parser.push(max);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZMSCORE.js
var require_ZMSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZMSCORE");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        return reply.map((0, generic_transformers_1.createTransformNullableDoubleReplyResp2Func)(preserve, typeMapping));
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX_COUNT.js
var require_ZPOPMAX_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMAX.js
var require_ZPOPMAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMAX");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: generic_transformers_1.transformDoubleReply[2](reply[1], preserve, typeMapping)
        };
      },
      3: (reply) => {
        if (reply.length === 0)
          return null;
        return {
          value: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN_COUNT.js
var require_ZPOPMIN_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, count) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
      parser.push(count.toString());
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZPOPMIN.js
var require_ZPOPMIN = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("ZPOPMIN");
      parser.pushKey(key);
    },
    transformReply: ZPOPMAX_1.default.transformReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER.js
var require_ZRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("ZRANDMEMBER");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT.js
var require_ZRANDMEMBER_COUNT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_1.default.parseCommand(parser, key);
      parser.push(count.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANDMEMBER_COUNT_WITHSCORES.js
var require_ZRANDMEMBER_COUNT_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  exports.default = {
    IS_READ_ONLY: ZRANDMEMBER_COUNT_1.default.IS_READ_ONLY,
    parseCommand(parser, key, count) {
      ZRANDMEMBER_COUNT_1.default.parseCommand(parser, key, count);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE.js
var require_ZRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zRangeArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function zRangeArgument(min, max, options) {
    const args = [
      (0, generic_transformers_1.transformStringDoubleArgument)(min),
      (0, generic_transformers_1.transformStringDoubleArgument)(max)
    ];
    switch (options?.BY) {
      case "SCORE":
        args.push("BYSCORE");
        break;
      case "LEX":
        args.push("BYLEX");
        break;
    }
    if (options?.REV) {
      args.push("REV");
    }
    if (options?.LIMIT) {
      args.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
    }
    return args;
  }
  exports.zRangeArgument = zRangeArgument;
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGE");
      parser.pushKey(key);
      parser.pushVariadic(zRangeArgument(min, max, options));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGE_WITHSCORES.js
var require_ZRANGE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  exports.default = {
    CACHEABLE: ZRANGE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYLEX.js
var require_ZRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE.js
var require_ZRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, min, max, options) {
      parser.push("ZRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGEBYSCORE_WITHSCORES.js
var require_ZRANGEBYSCORE_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  exports.default = {
    CACHEABLE: ZRANGEBYSCORE_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANGEBYSCORE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANGEBYSCORE_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANGESTORE.js
var require_ZRANGESTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, min, max, options) {
      parser.push("ZRANGESTORE");
      parser.pushKey(destination);
      parser.pushKey(source);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
      switch (options?.BY) {
        case "SCORE":
          parser.push("BYSCORE");
          break;
        case "LEX":
          parser.push("BYLEX");
          break;
      }
      if (options?.REV) {
        parser.push("REV");
      }
      if (options?.LIMIT) {
        parser.push("LIMIT", options.LIMIT.offset.toString(), options.LIMIT.count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYSCORE.js
var require_ZREMRANGEBYSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYSCORE");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANK.js
var require_ZRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZRANK_WITHSCORE.js
var require_ZRANK_WITHSCORE = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ZRANK_1 = __importDefault(require_ZRANK());
  exports.default = {
    CACHEABLE: ZRANK_1.default.CACHEABLE,
    IS_READ_ONLY: ZRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZRANK_1.default.parseCommand(...args);
      parser.push("WITHSCORE");
    },
    transformReply: {
      2: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: Number(reply[1])
        };
      },
      3: (reply) => {
        if (reply === null)
          return null;
        return {
          rank: reply[0],
          score: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREM.js
var require_ZREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, member) {
      parser.push("ZREM");
      parser.pushKey(key);
      parser.pushVariadic(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYLEX.js
var require_ZREMRANGEBYLEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, min, max) {
      parser.push("ZREMRANGEBYLEX");
      parser.pushKey(key);
      parser.push((0, generic_transformers_1.transformStringDoubleArgument)(min), (0, generic_transformers_1.transformStringDoubleArgument)(max));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREMRANGEBYRANK.js
var require_ZREMRANGEBYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, start, stop) {
      parser.push("ZREMRANGEBYRANK");
      parser.pushKey(key);
      parser.push(start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZREVRANK.js
var require_ZREVRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZREVRANK");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZSCAN.js
var require_ZSCAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SCAN_1 = require_SCAN();
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, cursor, options) {
      parser.push("ZSCAN");
      parser.pushKey(key);
      (0, SCAN_1.parseScanArguments)(parser, cursor, options);
    },
    transformReply([cursor, rawMembers]) {
      return {
        cursor,
        members: generic_transformers_1.transformSortedSetReply[2](rawMembers)
      };
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/ZSCORE.js
var require_ZSCORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    CACHEABLE: true,
    IS_READ_ONLY: true,
    parseCommand(parser, key, member) {
      parser.push("ZSCORE");
      parser.pushKey(key);
      parser.push(member);
    },
    transformReply: generic_transformers_1.transformNullableDoubleReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNION.js
var require_ZUNION = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, options) {
      parser.push("ZUNION");
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNION_WITHSCORES.js
var require_ZUNION_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var ZUNION_1 = __importDefault(require_ZUNION());
  exports.default = {
    IS_READ_ONLY: ZUNION_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      ZUNION_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: generic_transformers_1.transformSortedSetReply
  };
});

// node_modules/@redis/client/dist/lib/commands/ZUNIONSTORE.js
var require_ZUNIONSTORE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, keys, options) {
      parser.push("ZUNIONSTORE");
      parser.pushKey(destination);
      (0, generic_transformers_1.parseZKeysArguments)(parser, keys);
      if (options?.AGGREGATE) {
        parser.push("AGGREGATE", options.AGGREGATE);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VADD.js
var require_VADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, vector, element, options) {
      parser.push("VADD");
      parser.pushKey(key);
      if (options?.REDUCE !== undefined) {
        parser.push("REDUCE", options.REDUCE.toString());
      }
      parser.push("VALUES", vector.length.toString());
      for (const value of vector) {
        parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
      }
      parser.push(element);
      if (options?.CAS) {
        parser.push("CAS");
      }
      options?.QUANT && parser.push(options.QUANT);
      if (options?.EF !== undefined) {
        parser.push("EF", options.EF.toString());
      }
      if (options?.SETATTR) {
        parser.push("SETATTR", JSON.stringify(options.SETATTR));
      }
      if (options?.M !== undefined) {
        parser.push("M", options.M.toString());
      }
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VCARD.js
var require_VCARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VCARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VDIM.js
var require_VDIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VDIM");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VEMB.js
var require_VEMB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VEMB");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VEMB_RAW.js
var require_VEMB_RAW = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VEMB_1 = __importDefault(require_VEMB());
  var transformRawVembReply = {
    2: (reply) => {
      return {
        quantization: reply[0],
        raw: reply[1],
        l2Norm: generic_transformers_1.transformDoubleReply[2](reply[2]),
        ...reply[3] !== undefined && { quantizationRange: generic_transformers_1.transformDoubleReply[2](reply[3]) }
      };
    },
    3: (reply) => {
      return {
        quantization: reply[0],
        raw: reply[1],
        l2Norm: reply[2],
        quantizationRange: reply[3]
      };
    }
  };
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      VEMB_1.default.parseCommand(parser, key, element);
      parser.push("RAW");
    },
    transformReply: transformRawVembReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VGETATTR.js
var require_VGETATTR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VGETATTR");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformRedisJsonNullReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VINFO.js
var require_VINFO = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("VINFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply) => {
        const ret = Object.create(null);
        for (let i = 0;i < reply.length; i += 2) {
          ret[reply[i].toString()] = reply[i + 1];
        }
        return ret;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/VLINKS.js
var require_VLINKS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, element) {
      parser.push("VLINKS");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VLINKS_WITHSCORES.js
var require_VLINKS_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VLINKS_1 = __importDefault(require_VLINKS());
  function transformVLinksWithScoresReply(reply) {
    const layers = [];
    for (const layer of reply) {
      const obj = Object.create(null);
      for (let i = 0;i < layer.length; i += 2) {
        const element = layer[i];
        const score = generic_transformers_1.transformDoubleReply[2](layer[i + 1]);
        obj[element.toString()] = score;
      }
      layers.push(obj);
    }
    return layers;
  }
  exports.default = {
    IS_READ_ONLY: VLINKS_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      VLINKS_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: {
      2: transformVLinksWithScoresReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/VRANDMEMBER.js
var require_VRANDMEMBER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, count) {
      parser.push("VRANDMEMBER");
      parser.pushKey(key);
      if (count !== undefined) {
        parser.push(count.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VREM.js
var require_VREM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, element) {
      parser.push("VREM");
      parser.pushKey(key);
      parser.push(element);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VSETATTR.js
var require_VSETATTR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, key, element, attributes) {
      parser.push("VSETATTR");
      parser.pushKey(key);
      parser.push(element);
      if (typeof attributes === "object" && attributes !== null) {
        parser.push(JSON.stringify(attributes));
      } else {
        parser.push(attributes);
      }
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/client/dist/lib/commands/VSIM.js
var require_VSIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, query, options) {
      parser.push("VSIM");
      parser.pushKey(key);
      if (Array.isArray(query)) {
        parser.push("VALUES", query.length.toString());
        for (const value of query) {
          parser.push((0, generic_transformers_1.transformDoubleArgument)(value));
        }
      } else {
        parser.push("ELE", query);
      }
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.EF !== undefined) {
        parser.push("EF", options.EF.toString());
      }
      if (options?.FILTER) {
        parser.push("FILTER", options.FILTER);
      }
      if (options?.["FILTER-EF"] !== undefined) {
        parser.push("FILTER-EF", options["FILTER-EF"].toString());
      }
      if (options?.TRUTH) {
        parser.push("TRUTH");
      }
      if (options?.NOTHREAD) {
        parser.push("NOTHREAD");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/commands/VSIM_WITHSCORES.js
var require_VSIM_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var VSIM_1 = __importDefault(require_VSIM());
  exports.default = {
    IS_READ_ONLY: VSIM_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      VSIM_1.default.parseCommand(...args);
      parser.push("WITHSCORES");
    },
    transformReply: {
      2: (reply) => {
        const inferred = reply;
        const members = {};
        for (let i = 0;i < inferred.length; i += 2) {
          members[inferred[i].toString()] = generic_transformers_1.transformDoubleReply[2](inferred[i + 1]);
        }
        return members;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/commands/index.js
var require_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ACL_CAT_1 = __importDefault(require_ACL_CAT());
  var ACL_DELUSER_1 = __importDefault(require_ACL_DELUSER());
  var ACL_DRYRUN_1 = __importDefault(require_ACL_DRYRUN());
  var ACL_GENPASS_1 = __importDefault(require_ACL_GENPASS());
  var ACL_GETUSER_1 = __importDefault(require_ACL_GETUSER());
  var ACL_LIST_1 = __importDefault(require_ACL_LIST());
  var ACL_LOAD_1 = __importDefault(require_ACL_LOAD());
  var ACL_LOG_RESET_1 = __importDefault(require_ACL_LOG_RESET());
  var ACL_LOG_1 = __importDefault(require_ACL_LOG());
  var ACL_SAVE_1 = __importDefault(require_ACL_SAVE());
  var ACL_SETUSER_1 = __importDefault(require_ACL_SETUSER());
  var ACL_USERS_1 = __importDefault(require_ACL_USERS());
  var ACL_WHOAMI_1 = __importDefault(require_ACL_WHOAMI());
  var APPEND_1 = __importDefault(require_APPEND());
  var ASKING_1 = __importDefault(require_ASKING());
  var AUTH_1 = __importDefault(require_AUTH());
  var BGREWRITEAOF_1 = __importDefault(require_BGREWRITEAOF());
  var BGSAVE_1 = __importDefault(require_BGSAVE());
  var BITCOUNT_1 = __importDefault(require_BITCOUNT());
  var BITFIELD_RO_1 = __importDefault(require_BITFIELD_RO());
  var BITFIELD_1 = __importDefault(require_BITFIELD());
  var BITOP_1 = __importDefault(require_BITOP());
  var BITPOS_1 = __importDefault(require_BITPOS());
  var BLMOVE_1 = __importDefault(require_BLMOVE());
  var BLMPOP_1 = __importDefault(require_BLMPOP());
  var BLPOP_1 = __importDefault(require_BLPOP());
  var BRPOP_1 = __importDefault(require_BRPOP());
  var BRPOPLPUSH_1 = __importDefault(require_BRPOPLPUSH());
  var BZMPOP_1 = __importDefault(require_BZMPOP());
  var BZPOPMAX_1 = __importDefault(require_BZPOPMAX());
  var BZPOPMIN_1 = __importDefault(require_BZPOPMIN());
  var CLIENT_CACHING_1 = __importDefault(require_CLIENT_CACHING());
  var CLIENT_GETNAME_1 = __importDefault(require_CLIENT_GETNAME());
  var CLIENT_GETREDIR_1 = __importDefault(require_CLIENT_GETREDIR());
  var CLIENT_ID_1 = __importDefault(require_CLIENT_ID());
  var CLIENT_INFO_1 = __importDefault(require_CLIENT_INFO());
  var CLIENT_KILL_1 = __importDefault(require_CLIENT_KILL());
  var CLIENT_LIST_1 = __importDefault(require_CLIENT_LIST());
  var CLIENT_NO_EVICT_1 = __importDefault(require_CLIENT_NO_EVICT());
  var CLIENT_NO_TOUCH_1 = __importDefault(require_CLIENT_NO_TOUCH());
  var CLIENT_PAUSE_1 = __importDefault(require_CLIENT_PAUSE());
  var CLIENT_SETNAME_1 = __importDefault(require_CLIENT_SETNAME());
  var CLIENT_TRACKING_1 = __importDefault(require_CLIENT_TRACKING());
  var CLIENT_TRACKINGINFO_1 = __importDefault(require_CLIENT_TRACKINGINFO());
  var CLIENT_UNPAUSE_1 = __importDefault(require_CLIENT_UNPAUSE());
  var CLUSTER_ADDSLOTS_1 = __importDefault(require_CLUSTER_ADDSLOTS());
  var CLUSTER_ADDSLOTSRANGE_1 = __importDefault(require_CLUSTER_ADDSLOTSRANGE());
  var CLUSTER_BUMPEPOCH_1 = __importDefault(require_CLUSTER_BUMPEPOCH());
  var CLUSTER_COUNT_FAILURE_REPORTS_1 = __importDefault(require_CLUSTER_COUNT_FAILURE_REPORTS());
  var CLUSTER_COUNTKEYSINSLOT_1 = __importDefault(require_CLUSTER_COUNTKEYSINSLOT());
  var CLUSTER_DELSLOTS_1 = __importDefault(require_CLUSTER_DELSLOTS());
  var CLUSTER_DELSLOTSRANGE_1 = __importDefault(require_CLUSTER_DELSLOTSRANGE());
  var CLUSTER_FAILOVER_1 = __importDefault(require_CLUSTER_FAILOVER());
  var CLUSTER_FLUSHSLOTS_1 = __importDefault(require_CLUSTER_FLUSHSLOTS());
  var CLUSTER_FORGET_1 = __importDefault(require_CLUSTER_FORGET());
  var CLUSTER_GETKEYSINSLOT_1 = __importDefault(require_CLUSTER_GETKEYSINSLOT());
  var CLUSTER_INFO_1 = __importDefault(require_CLUSTER_INFO());
  var CLUSTER_KEYSLOT_1 = __importDefault(require_CLUSTER_KEYSLOT());
  var CLUSTER_LINKS_1 = __importDefault(require_CLUSTER_LINKS());
  var CLUSTER_MEET_1 = __importDefault(require_CLUSTER_MEET());
  var CLUSTER_MYID_1 = __importDefault(require_CLUSTER_MYID());
  var CLUSTER_MYSHARDID_1 = __importDefault(require_CLUSTER_MYSHARDID());
  var CLUSTER_NODES_1 = __importDefault(require_CLUSTER_NODES());
  var CLUSTER_REPLICAS_1 = __importDefault(require_CLUSTER_REPLICAS());
  var CLUSTER_REPLICATE_1 = __importDefault(require_CLUSTER_REPLICATE());
  var CLUSTER_RESET_1 = __importDefault(require_CLUSTER_RESET());
  var CLUSTER_SAVECONFIG_1 = __importDefault(require_CLUSTER_SAVECONFIG());
  var CLUSTER_SET_CONFIG_EPOCH_1 = __importDefault(require_CLUSTER_SET_CONFIG_EPOCH());
  var CLUSTER_SETSLOT_1 = __importDefault(require_CLUSTER_SETSLOT());
  var CLUSTER_SLOTS_1 = __importDefault(require_CLUSTER_SLOTS());
  var COMMAND_COUNT_1 = __importDefault(require_COMMAND_COUNT());
  var COMMAND_GETKEYS_1 = __importDefault(require_COMMAND_GETKEYS());
  var COMMAND_GETKEYSANDFLAGS_1 = __importDefault(require_COMMAND_GETKEYSANDFLAGS());
  var COMMAND_INFO_1 = __importDefault(require_COMMAND_INFO());
  var COMMAND_LIST_1 = __importDefault(require_COMMAND_LIST());
  var COMMAND_1 = __importDefault(require_COMMAND());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET());
  var CONFIG_RESETSTAT_1 = __importDefault(require_CONFIG_RESETSTAT());
  var CONFIG_REWRITE_1 = __importDefault(require_CONFIG_REWRITE());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET());
  var COPY_1 = __importDefault(require_COPY());
  var DBSIZE_1 = __importDefault(require_DBSIZE());
  var DECR_1 = __importDefault(require_DECR());
  var DECRBY_1 = __importDefault(require_DECRBY());
  var DEL_1 = __importDefault(require_DEL());
  var DUMP_1 = __importDefault(require_DUMP());
  var ECHO_1 = __importDefault(require_ECHO());
  var EVAL_RO_1 = __importDefault(require_EVAL_RO());
  var EVAL_1 = __importDefault(require_EVAL());
  var EVALSHA_RO_1 = __importDefault(require_EVALSHA_RO());
  var EVALSHA_1 = __importDefault(require_EVALSHA());
  var GEOADD_1 = __importDefault(require_GEOADD());
  var GEODIST_1 = __importDefault(require_GEODIST());
  var GEOHASH_1 = __importDefault(require_GEOHASH());
  var GEOPOS_1 = __importDefault(require_GEOPOS());
  var GEORADIUS_RO_WITH_1 = __importDefault(require_GEORADIUS_RO_WITH());
  var GEORADIUS_RO_1 = __importDefault(require_GEORADIUS_RO());
  var GEORADIUS_STORE_1 = __importDefault(require_GEORADIUS_STORE());
  var GEORADIUS_WITH_1 = __importDefault(require_GEORADIUS_WITH());
  var GEORADIUS_1 = __importDefault(require_GEORADIUS());
  var GEORADIUSBYMEMBER_RO_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_RO_WITH());
  var GEORADIUSBYMEMBER_RO_1 = __importDefault(require_GEORADIUSBYMEMBER_RO());
  var GEORADIUSBYMEMBER_STORE_1 = __importDefault(require_GEORADIUSBYMEMBER_STORE());
  var GEORADIUSBYMEMBER_WITH_1 = __importDefault(require_GEORADIUSBYMEMBER_WITH());
  var GEORADIUSBYMEMBER_1 = __importDefault(require_GEORADIUSBYMEMBER());
  var GEOSEARCH_WITH_1 = __importDefault(require_GEOSEARCH_WITH());
  var GEOSEARCH_1 = __importDefault(require_GEOSEARCH());
  var GEOSEARCHSTORE_1 = __importDefault(require_GEOSEARCHSTORE());
  var GET_1 = __importDefault(require_GET());
  var GETBIT_1 = __importDefault(require_GETBIT());
  var GETDEL_1 = __importDefault(require_GETDEL());
  var GETEX_1 = __importDefault(require_GETEX());
  var GETRANGE_1 = __importDefault(require_GETRANGE());
  var GETSET_1 = __importDefault(require_GETSET());
  var EXISTS_1 = __importDefault(require_EXISTS());
  var EXPIRE_1 = __importDefault(require_EXPIRE());
  var EXPIREAT_1 = __importDefault(require_EXPIREAT());
  var EXPIRETIME_1 = __importDefault(require_EXPIRETIME());
  var FLUSHALL_1 = __importDefault(require_FLUSHALL());
  var FLUSHDB_1 = __importDefault(require_FLUSHDB());
  var FCALL_1 = __importDefault(require_FCALL());
  var FCALL_RO_1 = __importDefault(require_FCALL_RO());
  var FUNCTION_DELETE_1 = __importDefault(require_FUNCTION_DELETE());
  var FUNCTION_DUMP_1 = __importDefault(require_FUNCTION_DUMP());
  var FUNCTION_FLUSH_1 = __importDefault(require_FUNCTION_FLUSH());
  var FUNCTION_KILL_1 = __importDefault(require_FUNCTION_KILL());
  var FUNCTION_LIST_WITHCODE_1 = __importDefault(require_FUNCTION_LIST_WITHCODE());
  var FUNCTION_LIST_1 = __importDefault(require_FUNCTION_LIST());
  var FUNCTION_LOAD_1 = __importDefault(require_FUNCTION_LOAD());
  var FUNCTION_RESTORE_1 = __importDefault(require_FUNCTION_RESTORE());
  var FUNCTION_STATS_1 = __importDefault(require_FUNCTION_STATS());
  var HDEL_1 = __importDefault(require_HDEL());
  var HELLO_1 = __importDefault(require_HELLO());
  var HEXISTS_1 = __importDefault(require_HEXISTS());
  var HEXPIRE_1 = __importDefault(require_HEXPIRE());
  var HEXPIREAT_1 = __importDefault(require_HEXPIREAT());
  var HEXPIRETIME_1 = __importDefault(require_HEXPIRETIME());
  var HGET_1 = __importDefault(require_HGET());
  var HGETALL_1 = __importDefault(require_HGETALL());
  var HGETDEL_1 = __importDefault(require_HGETDEL());
  var HGETEX_1 = __importDefault(require_HGETEX());
  var HINCRBY_1 = __importDefault(require_HINCRBY());
  var HINCRBYFLOAT_1 = __importDefault(require_HINCRBYFLOAT());
  var HKEYS_1 = __importDefault(require_HKEYS());
  var HLEN_1 = __importDefault(require_HLEN());
  var HMGET_1 = __importDefault(require_HMGET());
  var HPERSIST_1 = __importDefault(require_HPERSIST());
  var HPEXPIRE_1 = __importDefault(require_HPEXPIRE());
  var HPEXPIREAT_1 = __importDefault(require_HPEXPIREAT());
  var HPEXPIRETIME_1 = __importDefault(require_HPEXPIRETIME());
  var HPTTL_1 = __importDefault(require_HPTTL());
  var HRANDFIELD_COUNT_WITHVALUES_1 = __importDefault(require_HRANDFIELD_COUNT_WITHVALUES());
  var HRANDFIELD_COUNT_1 = __importDefault(require_HRANDFIELD_COUNT());
  var HRANDFIELD_1 = __importDefault(require_HRANDFIELD());
  var HSCAN_1 = __importDefault(require_HSCAN());
  var HSCAN_NOVALUES_1 = __importDefault(require_HSCAN_NOVALUES());
  var HSET_1 = __importDefault(require_HSET());
  var HSETEX_1 = __importDefault(require_HSETEX());
  var HSETNX_1 = __importDefault(require_HSETNX());
  var HSTRLEN_1 = __importDefault(require_HSTRLEN());
  var HTTL_1 = __importDefault(require_HTTL());
  var HVALS_1 = __importDefault(require_HVALS());
  var INCR_1 = __importDefault(require_INCR());
  var INCRBY_1 = __importDefault(require_INCRBY());
  var INCRBYFLOAT_1 = __importDefault(require_INCRBYFLOAT());
  var INFO_1 = __importDefault(require_INFO());
  var KEYS_1 = __importDefault(require_KEYS());
  var LASTSAVE_1 = __importDefault(require_LASTSAVE());
  var LATENCY_DOCTOR_1 = __importDefault(require_LATENCY_DOCTOR());
  var LATENCY_GRAPH_1 = __importDefault(require_LATENCY_GRAPH());
  var LATENCY_HISTORY_1 = __importDefault(require_LATENCY_HISTORY());
  var LATENCY_LATEST_1 = __importDefault(require_LATENCY_LATEST());
  var LCS_IDX_WITHMATCHLEN_1 = __importDefault(require_LCS_IDX_WITHMATCHLEN());
  var LCS_IDX_1 = __importDefault(require_LCS_IDX());
  var LCS_LEN_1 = __importDefault(require_LCS_LEN());
  var LCS_1 = __importDefault(require_LCS());
  var LINDEX_1 = __importDefault(require_LINDEX());
  var LINSERT_1 = __importDefault(require_LINSERT());
  var LLEN_1 = __importDefault(require_LLEN());
  var LMOVE_1 = __importDefault(require_LMOVE());
  var LMPOP_1 = __importDefault(require_LMPOP());
  var LOLWUT_1 = __importDefault(require_LOLWUT());
  var LPOP_COUNT_1 = __importDefault(require_LPOP_COUNT());
  var LPOP_1 = __importDefault(require_LPOP());
  var LPOS_COUNT_1 = __importDefault(require_LPOS_COUNT());
  var LPOS_1 = __importDefault(require_LPOS());
  var LPUSH_1 = __importDefault(require_LPUSH());
  var LPUSHX_1 = __importDefault(require_LPUSHX());
  var LRANGE_1 = __importDefault(require_LRANGE());
  var LREM_1 = __importDefault(require_LREM());
  var LSET_1 = __importDefault(require_LSET());
  var LTRIM_1 = __importDefault(require_LTRIM());
  var MEMORY_DOCTOR_1 = __importDefault(require_MEMORY_DOCTOR());
  var MEMORY_MALLOC_STATS_1 = __importDefault(require_MEMORY_MALLOC_STATS());
  var MEMORY_PURGE_1 = __importDefault(require_MEMORY_PURGE());
  var MEMORY_STATS_1 = __importDefault(require_MEMORY_STATS());
  var MEMORY_USAGE_1 = __importDefault(require_MEMORY_USAGE());
  var MGET_1 = __importDefault(require_MGET());
  var MIGRATE_1 = __importDefault(require_MIGRATE());
  var MODULE_LIST_1 = __importDefault(require_MODULE_LIST());
  var MODULE_LOAD_1 = __importDefault(require_MODULE_LOAD());
  var MODULE_UNLOAD_1 = __importDefault(require_MODULE_UNLOAD());
  var MOVE_1 = __importDefault(require_MOVE());
  var MSET_1 = __importDefault(require_MSET());
  var MSETNX_1 = __importDefault(require_MSETNX());
  var OBJECT_ENCODING_1 = __importDefault(require_OBJECT_ENCODING());
  var OBJECT_FREQ_1 = __importDefault(require_OBJECT_FREQ());
  var OBJECT_IDLETIME_1 = __importDefault(require_OBJECT_IDLETIME());
  var OBJECT_REFCOUNT_1 = __importDefault(require_OBJECT_REFCOUNT());
  var PERSIST_1 = __importDefault(require_PERSIST());
  var PEXPIRE_1 = __importDefault(require_PEXPIRE());
  var PEXPIREAT_1 = __importDefault(require_PEXPIREAT());
  var PEXPIRETIME_1 = __importDefault(require_PEXPIRETIME());
  var PFADD_1 = __importDefault(require_PFADD());
  var PFCOUNT_1 = __importDefault(require_PFCOUNT());
  var PFMERGE_1 = __importDefault(require_PFMERGE());
  var PING_1 = __importDefault(require_PING());
  var PSETEX_1 = __importDefault(require_PSETEX());
  var PTTL_1 = __importDefault(require_PTTL());
  var PUBLISH_1 = __importDefault(require_PUBLISH());
  var PUBSUB_CHANNELS_1 = __importDefault(require_PUBSUB_CHANNELS());
  var PUBSUB_NUMPAT_1 = __importDefault(require_PUBSUB_NUMPAT());
  var PUBSUB_NUMSUB_1 = __importDefault(require_PUBSUB_NUMSUB());
  var PUBSUB_SHARDNUMSUB_1 = __importDefault(require_PUBSUB_SHARDNUMSUB());
  var PUBSUB_SHARDCHANNELS_1 = __importDefault(require_PUBSUB_SHARDCHANNELS());
  var RANDOMKEY_1 = __importDefault(require_RANDOMKEY());
  var READONLY_1 = __importDefault(require_READONLY());
  var RENAME_1 = __importDefault(require_RENAME());
  var RENAMENX_1 = __importDefault(require_RENAMENX());
  var REPLICAOF_1 = __importDefault(require_REPLICAOF());
  var RESTORE_ASKING_1 = __importDefault(require_RESTORE_ASKING());
  var RESTORE_1 = __importDefault(require_RESTORE());
  var ROLE_1 = __importDefault(require_ROLE());
  var RPOP_COUNT_1 = __importDefault(require_RPOP_COUNT());
  var RPOP_1 = __importDefault(require_RPOP());
  var RPOPLPUSH_1 = __importDefault(require_RPOPLPUSH());
  var RPUSH_1 = __importDefault(require_RPUSH());
  var RPUSHX_1 = __importDefault(require_RPUSHX());
  var SADD_1 = __importDefault(require_SADD());
  var SCAN_1 = __importDefault(require_SCAN());
  var SCARD_1 = __importDefault(require_SCARD());
  var SCRIPT_DEBUG_1 = __importDefault(require_SCRIPT_DEBUG());
  var SCRIPT_EXISTS_1 = __importDefault(require_SCRIPT_EXISTS());
  var SCRIPT_FLUSH_1 = __importDefault(require_SCRIPT_FLUSH());
  var SCRIPT_KILL_1 = __importDefault(require_SCRIPT_KILL());
  var SCRIPT_LOAD_1 = __importDefault(require_SCRIPT_LOAD());
  var SDIFF_1 = __importDefault(require_SDIFF());
  var SDIFFSTORE_1 = __importDefault(require_SDIFFSTORE());
  var SET_1 = __importDefault(require_SET());
  var SETBIT_1 = __importDefault(require_SETBIT());
  var SETEX_1 = __importDefault(require_SETEX());
  var SETNX_1 = __importDefault(require_SETNX());
  var SETRANGE_1 = __importDefault(require_SETRANGE());
  var SINTER_1 = __importDefault(require_SINTER());
  var SINTERCARD_1 = __importDefault(require_SINTERCARD());
  var SINTERSTORE_1 = __importDefault(require_SINTERSTORE());
  var SISMEMBER_1 = __importDefault(require_SISMEMBER());
  var SMEMBERS_1 = __importDefault(require_SMEMBERS());
  var SMISMEMBER_1 = __importDefault(require_SMISMEMBER());
  var SMOVE_1 = __importDefault(require_SMOVE());
  var SORT_RO_1 = __importDefault(require_SORT_RO());
  var SORT_STORE_1 = __importDefault(require_SORT_STORE());
  var SORT_1 = __importDefault(require_SORT());
  var SPOP_COUNT_1 = __importDefault(require_SPOP_COUNT());
  var SPOP_1 = __importDefault(require_SPOP());
  var SPUBLISH_1 = __importDefault(require_SPUBLISH());
  var SRANDMEMBER_COUNT_1 = __importDefault(require_SRANDMEMBER_COUNT());
  var SRANDMEMBER_1 = __importDefault(require_SRANDMEMBER());
  var SREM_1 = __importDefault(require_SREM());
  var SSCAN_1 = __importDefault(require_SSCAN());
  var STRLEN_1 = __importDefault(require_STRLEN());
  var SUNION_1 = __importDefault(require_SUNION());
  var SUNIONSTORE_1 = __importDefault(require_SUNIONSTORE());
  var SWAPDB_1 = __importDefault(require_SWAPDB());
  var TIME_1 = __importDefault(require_TIME());
  var TOUCH_1 = __importDefault(require_TOUCH());
  var TTL_1 = __importDefault(require_TTL());
  var TYPE_1 = __importDefault(require_TYPE());
  var UNLINK_1 = __importDefault(require_UNLINK());
  var WAIT_1 = __importDefault(require_WAIT());
  var XACK_1 = __importDefault(require_XACK());
  var XADD_NOMKSTREAM_1 = __importDefault(require_XADD_NOMKSTREAM());
  var XADD_1 = __importDefault(require_XADD());
  var XAUTOCLAIM_JUSTID_1 = __importDefault(require_XAUTOCLAIM_JUSTID());
  var XAUTOCLAIM_1 = __importDefault(require_XAUTOCLAIM());
  var XCLAIM_JUSTID_1 = __importDefault(require_XCLAIM_JUSTID());
  var XCLAIM_1 = __importDefault(require_XCLAIM());
  var XDEL_1 = __importDefault(require_XDEL());
  var XGROUP_CREATE_1 = __importDefault(require_XGROUP_CREATE());
  var XGROUP_CREATECONSUMER_1 = __importDefault(require_XGROUP_CREATECONSUMER());
  var XGROUP_DELCONSUMER_1 = __importDefault(require_XGROUP_DELCONSUMER());
  var XGROUP_DESTROY_1 = __importDefault(require_XGROUP_DESTROY());
  var XGROUP_SETID_1 = __importDefault(require_XGROUP_SETID());
  var XINFO_CONSUMERS_1 = __importDefault(require_XINFO_CONSUMERS());
  var XINFO_GROUPS_1 = __importDefault(require_XINFO_GROUPS());
  var XINFO_STREAM_1 = __importDefault(require_XINFO_STREAM());
  var XLEN_1 = __importDefault(require_XLEN());
  var XPENDING_RANGE_1 = __importDefault(require_XPENDING_RANGE());
  var XPENDING_1 = __importDefault(require_XPENDING());
  var XRANGE_1 = __importDefault(require_XRANGE());
  var XREAD_1 = __importDefault(require_XREAD());
  var XREADGROUP_1 = __importDefault(require_XREADGROUP());
  var XREVRANGE_1 = __importDefault(require_XREVRANGE());
  var XSETID_1 = __importDefault(require_XSETID());
  var XTRIM_1 = __importDefault(require_XTRIM());
  var ZADD_INCR_1 = __importDefault(require_ZADD_INCR());
  var ZADD_1 = __importDefault(require_ZADD());
  var ZCARD_1 = __importDefault(require_ZCARD());
  var ZCOUNT_1 = __importDefault(require_ZCOUNT());
  var ZDIFF_WITHSCORES_1 = __importDefault(require_ZDIFF_WITHSCORES());
  var ZDIFF_1 = __importDefault(require_ZDIFF());
  var ZDIFFSTORE_1 = __importDefault(require_ZDIFFSTORE());
  var ZINCRBY_1 = __importDefault(require_ZINCRBY());
  var ZINTER_WITHSCORES_1 = __importDefault(require_ZINTER_WITHSCORES());
  var ZINTER_1 = __importDefault(require_ZINTER());
  var ZINTERCARD_1 = __importDefault(require_ZINTERCARD());
  var ZINTERSTORE_1 = __importDefault(require_ZINTERSTORE());
  var ZLEXCOUNT_1 = __importDefault(require_ZLEXCOUNT());
  var ZMPOP_1 = __importDefault(require_ZMPOP());
  var ZMSCORE_1 = __importDefault(require_ZMSCORE());
  var ZPOPMAX_COUNT_1 = __importDefault(require_ZPOPMAX_COUNT());
  var ZPOPMAX_1 = __importDefault(require_ZPOPMAX());
  var ZPOPMIN_COUNT_1 = __importDefault(require_ZPOPMIN_COUNT());
  var ZPOPMIN_1 = __importDefault(require_ZPOPMIN());
  var ZRANDMEMBER_COUNT_WITHSCORES_1 = __importDefault(require_ZRANDMEMBER_COUNT_WITHSCORES());
  var ZRANDMEMBER_COUNT_1 = __importDefault(require_ZRANDMEMBER_COUNT());
  var ZRANDMEMBER_1 = __importDefault(require_ZRANDMEMBER());
  var ZRANGE_WITHSCORES_1 = __importDefault(require_ZRANGE_WITHSCORES());
  var ZRANGE_1 = __importDefault(require_ZRANGE());
  var ZRANGEBYLEX_1 = __importDefault(require_ZRANGEBYLEX());
  var ZRANGEBYSCORE_WITHSCORES_1 = __importDefault(require_ZRANGEBYSCORE_WITHSCORES());
  var ZRANGEBYSCORE_1 = __importDefault(require_ZRANGEBYSCORE());
  var ZRANGESTORE_1 = __importDefault(require_ZRANGESTORE());
  var ZREMRANGEBYSCORE_1 = __importDefault(require_ZREMRANGEBYSCORE());
  var ZRANK_WITHSCORE_1 = __importDefault(require_ZRANK_WITHSCORE());
  var ZRANK_1 = __importDefault(require_ZRANK());
  var ZREM_1 = __importDefault(require_ZREM());
  var ZREMRANGEBYLEX_1 = __importDefault(require_ZREMRANGEBYLEX());
  var ZREMRANGEBYRANK_1 = __importDefault(require_ZREMRANGEBYRANK());
  var ZREVRANK_1 = __importDefault(require_ZREVRANK());
  var ZSCAN_1 = __importDefault(require_ZSCAN());
  var ZSCORE_1 = __importDefault(require_ZSCORE());
  var ZUNION_WITHSCORES_1 = __importDefault(require_ZUNION_WITHSCORES());
  var ZUNION_1 = __importDefault(require_ZUNION());
  var ZUNIONSTORE_1 = __importDefault(require_ZUNIONSTORE());
  var VADD_1 = __importDefault(require_VADD());
  var VCARD_1 = __importDefault(require_VCARD());
  var VDIM_1 = __importDefault(require_VDIM());
  var VEMB_1 = __importDefault(require_VEMB());
  var VEMB_RAW_1 = __importDefault(require_VEMB_RAW());
  var VGETATTR_1 = __importDefault(require_VGETATTR());
  var VINFO_1 = __importDefault(require_VINFO());
  var VLINKS_1 = __importDefault(require_VLINKS());
  var VLINKS_WITHSCORES_1 = __importDefault(require_VLINKS_WITHSCORES());
  var VRANDMEMBER_1 = __importDefault(require_VRANDMEMBER());
  var VREM_1 = __importDefault(require_VREM());
  var VSETATTR_1 = __importDefault(require_VSETATTR());
  var VSIM_1 = __importDefault(require_VSIM());
  var VSIM_WITHSCORES_1 = __importDefault(require_VSIM_WITHSCORES());
  exports.default = {
    ACL_CAT: ACL_CAT_1.default,
    aclCat: ACL_CAT_1.default,
    ACL_DELUSER: ACL_DELUSER_1.default,
    aclDelUser: ACL_DELUSER_1.default,
    ACL_DRYRUN: ACL_DRYRUN_1.default,
    aclDryRun: ACL_DRYRUN_1.default,
    ACL_GENPASS: ACL_GENPASS_1.default,
    aclGenPass: ACL_GENPASS_1.default,
    ACL_GETUSER: ACL_GETUSER_1.default,
    aclGetUser: ACL_GETUSER_1.default,
    ACL_LIST: ACL_LIST_1.default,
    aclList: ACL_LIST_1.default,
    ACL_LOAD: ACL_LOAD_1.default,
    aclLoad: ACL_LOAD_1.default,
    ACL_LOG_RESET: ACL_LOG_RESET_1.default,
    aclLogReset: ACL_LOG_RESET_1.default,
    ACL_LOG: ACL_LOG_1.default,
    aclLog: ACL_LOG_1.default,
    ACL_SAVE: ACL_SAVE_1.default,
    aclSave: ACL_SAVE_1.default,
    ACL_SETUSER: ACL_SETUSER_1.default,
    aclSetUser: ACL_SETUSER_1.default,
    ACL_USERS: ACL_USERS_1.default,
    aclUsers: ACL_USERS_1.default,
    ACL_WHOAMI: ACL_WHOAMI_1.default,
    aclWhoAmI: ACL_WHOAMI_1.default,
    APPEND: APPEND_1.default,
    append: APPEND_1.default,
    ASKING: ASKING_1.default,
    asking: ASKING_1.default,
    AUTH: AUTH_1.default,
    auth: AUTH_1.default,
    BGREWRITEAOF: BGREWRITEAOF_1.default,
    bgRewriteAof: BGREWRITEAOF_1.default,
    BGSAVE: BGSAVE_1.default,
    bgSave: BGSAVE_1.default,
    BITCOUNT: BITCOUNT_1.default,
    bitCount: BITCOUNT_1.default,
    BITFIELD_RO: BITFIELD_RO_1.default,
    bitFieldRo: BITFIELD_RO_1.default,
    BITFIELD: BITFIELD_1.default,
    bitField: BITFIELD_1.default,
    BITOP: BITOP_1.default,
    bitOp: BITOP_1.default,
    BITPOS: BITPOS_1.default,
    bitPos: BITPOS_1.default,
    BLMOVE: BLMOVE_1.default,
    blMove: BLMOVE_1.default,
    BLMPOP: BLMPOP_1.default,
    blmPop: BLMPOP_1.default,
    BLPOP: BLPOP_1.default,
    blPop: BLPOP_1.default,
    BRPOP: BRPOP_1.default,
    brPop: BRPOP_1.default,
    BRPOPLPUSH: BRPOPLPUSH_1.default,
    brPopLPush: BRPOPLPUSH_1.default,
    BZMPOP: BZMPOP_1.default,
    bzmPop: BZMPOP_1.default,
    BZPOPMAX: BZPOPMAX_1.default,
    bzPopMax: BZPOPMAX_1.default,
    BZPOPMIN: BZPOPMIN_1.default,
    bzPopMin: BZPOPMIN_1.default,
    CLIENT_CACHING: CLIENT_CACHING_1.default,
    clientCaching: CLIENT_CACHING_1.default,
    CLIENT_GETNAME: CLIENT_GETNAME_1.default,
    clientGetName: CLIENT_GETNAME_1.default,
    CLIENT_GETREDIR: CLIENT_GETREDIR_1.default,
    clientGetRedir: CLIENT_GETREDIR_1.default,
    CLIENT_ID: CLIENT_ID_1.default,
    clientId: CLIENT_ID_1.default,
    CLIENT_INFO: CLIENT_INFO_1.default,
    clientInfo: CLIENT_INFO_1.default,
    CLIENT_KILL: CLIENT_KILL_1.default,
    clientKill: CLIENT_KILL_1.default,
    CLIENT_LIST: CLIENT_LIST_1.default,
    clientList: CLIENT_LIST_1.default,
    "CLIENT_NO-EVICT": CLIENT_NO_EVICT_1.default,
    clientNoEvict: CLIENT_NO_EVICT_1.default,
    "CLIENT_NO-TOUCH": CLIENT_NO_TOUCH_1.default,
    clientNoTouch: CLIENT_NO_TOUCH_1.default,
    CLIENT_PAUSE: CLIENT_PAUSE_1.default,
    clientPause: CLIENT_PAUSE_1.default,
    CLIENT_SETNAME: CLIENT_SETNAME_1.default,
    clientSetName: CLIENT_SETNAME_1.default,
    CLIENT_TRACKING: CLIENT_TRACKING_1.default,
    clientTracking: CLIENT_TRACKING_1.default,
    CLIENT_TRACKINGINFO: CLIENT_TRACKINGINFO_1.default,
    clientTrackingInfo: CLIENT_TRACKINGINFO_1.default,
    CLIENT_UNPAUSE: CLIENT_UNPAUSE_1.default,
    clientUnpause: CLIENT_UNPAUSE_1.default,
    CLUSTER_ADDSLOTS: CLUSTER_ADDSLOTS_1.default,
    clusterAddSlots: CLUSTER_ADDSLOTS_1.default,
    CLUSTER_ADDSLOTSRANGE: CLUSTER_ADDSLOTSRANGE_1.default,
    clusterAddSlotsRange: CLUSTER_ADDSLOTSRANGE_1.default,
    CLUSTER_BUMPEPOCH: CLUSTER_BUMPEPOCH_1.default,
    clusterBumpEpoch: CLUSTER_BUMPEPOCH_1.default,
    "CLUSTER_COUNT-FAILURE-REPORTS": CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    clusterCountFailureReports: CLUSTER_COUNT_FAILURE_REPORTS_1.default,
    CLUSTER_COUNTKEYSINSLOT: CLUSTER_COUNTKEYSINSLOT_1.default,
    clusterCountKeysInSlot: CLUSTER_COUNTKEYSINSLOT_1.default,
    CLUSTER_DELSLOTS: CLUSTER_DELSLOTS_1.default,
    clusterDelSlots: CLUSTER_DELSLOTS_1.default,
    CLUSTER_DELSLOTSRANGE: CLUSTER_DELSLOTSRANGE_1.default,
    clusterDelSlotsRange: CLUSTER_DELSLOTSRANGE_1.default,
    CLUSTER_FAILOVER: CLUSTER_FAILOVER_1.default,
    clusterFailover: CLUSTER_FAILOVER_1.default,
    CLUSTER_FLUSHSLOTS: CLUSTER_FLUSHSLOTS_1.default,
    clusterFlushSlots: CLUSTER_FLUSHSLOTS_1.default,
    CLUSTER_FORGET: CLUSTER_FORGET_1.default,
    clusterForget: CLUSTER_FORGET_1.default,
    CLUSTER_GETKEYSINSLOT: CLUSTER_GETKEYSINSLOT_1.default,
    clusterGetKeysInSlot: CLUSTER_GETKEYSINSLOT_1.default,
    CLUSTER_INFO: CLUSTER_INFO_1.default,
    clusterInfo: CLUSTER_INFO_1.default,
    CLUSTER_KEYSLOT: CLUSTER_KEYSLOT_1.default,
    clusterKeySlot: CLUSTER_KEYSLOT_1.default,
    CLUSTER_LINKS: CLUSTER_LINKS_1.default,
    clusterLinks: CLUSTER_LINKS_1.default,
    CLUSTER_MEET: CLUSTER_MEET_1.default,
    clusterMeet: CLUSTER_MEET_1.default,
    CLUSTER_MYID: CLUSTER_MYID_1.default,
    clusterMyId: CLUSTER_MYID_1.default,
    CLUSTER_MYSHARDID: CLUSTER_MYSHARDID_1.default,
    clusterMyShardId: CLUSTER_MYSHARDID_1.default,
    CLUSTER_NODES: CLUSTER_NODES_1.default,
    clusterNodes: CLUSTER_NODES_1.default,
    CLUSTER_REPLICAS: CLUSTER_REPLICAS_1.default,
    clusterReplicas: CLUSTER_REPLICAS_1.default,
    CLUSTER_REPLICATE: CLUSTER_REPLICATE_1.default,
    clusterReplicate: CLUSTER_REPLICATE_1.default,
    CLUSTER_RESET: CLUSTER_RESET_1.default,
    clusterReset: CLUSTER_RESET_1.default,
    CLUSTER_SAVECONFIG: CLUSTER_SAVECONFIG_1.default,
    clusterSaveConfig: CLUSTER_SAVECONFIG_1.default,
    "CLUSTER_SET-CONFIG-EPOCH": CLUSTER_SET_CONFIG_EPOCH_1.default,
    clusterSetConfigEpoch: CLUSTER_SET_CONFIG_EPOCH_1.default,
    CLUSTER_SETSLOT: CLUSTER_SETSLOT_1.default,
    clusterSetSlot: CLUSTER_SETSLOT_1.default,
    CLUSTER_SLOTS: CLUSTER_SLOTS_1.default,
    clusterSlots: CLUSTER_SLOTS_1.default,
    COMMAND_COUNT: COMMAND_COUNT_1.default,
    commandCount: COMMAND_COUNT_1.default,
    COMMAND_GETKEYS: COMMAND_GETKEYS_1.default,
    commandGetKeys: COMMAND_GETKEYS_1.default,
    COMMAND_GETKEYSANDFLAGS: COMMAND_GETKEYSANDFLAGS_1.default,
    commandGetKeysAndFlags: COMMAND_GETKEYSANDFLAGS_1.default,
    COMMAND_INFO: COMMAND_INFO_1.default,
    commandInfo: COMMAND_INFO_1.default,
    COMMAND_LIST: COMMAND_LIST_1.default,
    commandList: COMMAND_LIST_1.default,
    COMMAND: COMMAND_1.default,
    command: COMMAND_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_RESETASTAT: CONFIG_RESETSTAT_1.default,
    configResetStat: CONFIG_RESETSTAT_1.default,
    CONFIG_REWRITE: CONFIG_REWRITE_1.default,
    configRewrite: CONFIG_REWRITE_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    COPY: COPY_1.default,
    copy: COPY_1.default,
    DBSIZE: DBSIZE_1.default,
    dbSize: DBSIZE_1.default,
    DECR: DECR_1.default,
    decr: DECR_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DUMP: DUMP_1.default,
    dump: DUMP_1.default,
    ECHO: ECHO_1.default,
    echo: ECHO_1.default,
    EVAL_RO: EVAL_RO_1.default,
    evalRo: EVAL_RO_1.default,
    EVAL: EVAL_1.default,
    eval: EVAL_1.default,
    EVALSHA_RO: EVALSHA_RO_1.default,
    evalShaRo: EVALSHA_RO_1.default,
    EVALSHA: EVALSHA_1.default,
    evalSha: EVALSHA_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    EXPIRE: EXPIRE_1.default,
    expire: EXPIRE_1.default,
    EXPIREAT: EXPIREAT_1.default,
    expireAt: EXPIREAT_1.default,
    EXPIRETIME: EXPIRETIME_1.default,
    expireTime: EXPIRETIME_1.default,
    FLUSHALL: FLUSHALL_1.default,
    flushAll: FLUSHALL_1.default,
    FLUSHDB: FLUSHDB_1.default,
    flushDb: FLUSHDB_1.default,
    FCALL: FCALL_1.default,
    fCall: FCALL_1.default,
    FCALL_RO: FCALL_RO_1.default,
    fCallRo: FCALL_RO_1.default,
    FUNCTION_DELETE: FUNCTION_DELETE_1.default,
    functionDelete: FUNCTION_DELETE_1.default,
    FUNCTION_DUMP: FUNCTION_DUMP_1.default,
    functionDump: FUNCTION_DUMP_1.default,
    FUNCTION_FLUSH: FUNCTION_FLUSH_1.default,
    functionFlush: FUNCTION_FLUSH_1.default,
    FUNCTION_KILL: FUNCTION_KILL_1.default,
    functionKill: FUNCTION_KILL_1.default,
    FUNCTION_LIST_WITHCODE: FUNCTION_LIST_WITHCODE_1.default,
    functionListWithCode: FUNCTION_LIST_WITHCODE_1.default,
    FUNCTION_LIST: FUNCTION_LIST_1.default,
    functionList: FUNCTION_LIST_1.default,
    FUNCTION_LOAD: FUNCTION_LOAD_1.default,
    functionLoad: FUNCTION_LOAD_1.default,
    FUNCTION_RESTORE: FUNCTION_RESTORE_1.default,
    functionRestore: FUNCTION_RESTORE_1.default,
    FUNCTION_STATS: FUNCTION_STATS_1.default,
    functionStats: FUNCTION_STATS_1.default,
    GEOADD: GEOADD_1.default,
    geoAdd: GEOADD_1.default,
    GEODIST: GEODIST_1.default,
    geoDist: GEODIST_1.default,
    GEOHASH: GEOHASH_1.default,
    geoHash: GEOHASH_1.default,
    GEOPOS: GEOPOS_1.default,
    geoPos: GEOPOS_1.default,
    GEORADIUS_RO_WITH: GEORADIUS_RO_WITH_1.default,
    geoRadiusRoWith: GEORADIUS_RO_WITH_1.default,
    GEORADIUS_RO: GEORADIUS_RO_1.default,
    geoRadiusRo: GEORADIUS_RO_1.default,
    GEORADIUS_STORE: GEORADIUS_STORE_1.default,
    geoRadiusStore: GEORADIUS_STORE_1.default,
    GEORADIUS_WITH: GEORADIUS_WITH_1.default,
    geoRadiusWith: GEORADIUS_WITH_1.default,
    GEORADIUS: GEORADIUS_1.default,
    geoRadius: GEORADIUS_1.default,
    GEORADIUSBYMEMBER_RO_WITH: GEORADIUSBYMEMBER_RO_WITH_1.default,
    geoRadiusByMemberRoWith: GEORADIUSBYMEMBER_RO_WITH_1.default,
    GEORADIUSBYMEMBER_RO: GEORADIUSBYMEMBER_RO_1.default,
    geoRadiusByMemberRo: GEORADIUSBYMEMBER_RO_1.default,
    GEORADIUSBYMEMBER_STORE: GEORADIUSBYMEMBER_STORE_1.default,
    geoRadiusByMemberStore: GEORADIUSBYMEMBER_STORE_1.default,
    GEORADIUSBYMEMBER_WITH: GEORADIUSBYMEMBER_WITH_1.default,
    geoRadiusByMemberWith: GEORADIUSBYMEMBER_WITH_1.default,
    GEORADIUSBYMEMBER: GEORADIUSBYMEMBER_1.default,
    geoRadiusByMember: GEORADIUSBYMEMBER_1.default,
    GEOSEARCH_WITH: GEOSEARCH_WITH_1.default,
    geoSearchWith: GEOSEARCH_WITH_1.default,
    GEOSEARCH: GEOSEARCH_1.default,
    geoSearch: GEOSEARCH_1.default,
    GEOSEARCHSTORE: GEOSEARCHSTORE_1.default,
    geoSearchStore: GEOSEARCHSTORE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    GETBIT: GETBIT_1.default,
    getBit: GETBIT_1.default,
    GETDEL: GETDEL_1.default,
    getDel: GETDEL_1.default,
    GETEX: GETEX_1.default,
    getEx: GETEX_1.default,
    GETRANGE: GETRANGE_1.default,
    getRange: GETRANGE_1.default,
    GETSET: GETSET_1.default,
    getSet: GETSET_1.default,
    HDEL: HDEL_1.default,
    hDel: HDEL_1.default,
    HELLO: HELLO_1.default,
    hello: HELLO_1.default,
    HEXISTS: HEXISTS_1.default,
    hExists: HEXISTS_1.default,
    HEXPIRE: HEXPIRE_1.default,
    hExpire: HEXPIRE_1.default,
    HEXPIREAT: HEXPIREAT_1.default,
    hExpireAt: HEXPIREAT_1.default,
    HEXPIRETIME: HEXPIRETIME_1.default,
    hExpireTime: HEXPIRETIME_1.default,
    HGET: HGET_1.default,
    hGet: HGET_1.default,
    HGETALL: HGETALL_1.default,
    hGetAll: HGETALL_1.default,
    HGETDEL: HGETDEL_1.default,
    hGetDel: HGETDEL_1.default,
    HGETEX: HGETEX_1.default,
    hGetEx: HGETEX_1.default,
    HINCRBY: HINCRBY_1.default,
    hIncrBy: HINCRBY_1.default,
    HINCRBYFLOAT: HINCRBYFLOAT_1.default,
    hIncrByFloat: HINCRBYFLOAT_1.default,
    HKEYS: HKEYS_1.default,
    hKeys: HKEYS_1.default,
    HLEN: HLEN_1.default,
    hLen: HLEN_1.default,
    HMGET: HMGET_1.default,
    hmGet: HMGET_1.default,
    HPERSIST: HPERSIST_1.default,
    hPersist: HPERSIST_1.default,
    HPEXPIRE: HPEXPIRE_1.default,
    hpExpire: HPEXPIRE_1.default,
    HPEXPIREAT: HPEXPIREAT_1.default,
    hpExpireAt: HPEXPIREAT_1.default,
    HPEXPIRETIME: HPEXPIRETIME_1.default,
    hpExpireTime: HPEXPIRETIME_1.default,
    HPTTL: HPTTL_1.default,
    hpTTL: HPTTL_1.default,
    HRANDFIELD_COUNT_WITHVALUES: HRANDFIELD_COUNT_WITHVALUES_1.default,
    hRandFieldCountWithValues: HRANDFIELD_COUNT_WITHVALUES_1.default,
    HRANDFIELD_COUNT: HRANDFIELD_COUNT_1.default,
    hRandFieldCount: HRANDFIELD_COUNT_1.default,
    HRANDFIELD: HRANDFIELD_1.default,
    hRandField: HRANDFIELD_1.default,
    HSCAN: HSCAN_1.default,
    hScan: HSCAN_1.default,
    HSCAN_NOVALUES: HSCAN_NOVALUES_1.default,
    hScanNoValues: HSCAN_NOVALUES_1.default,
    HSET: HSET_1.default,
    hSet: HSET_1.default,
    HSETEX: HSETEX_1.default,
    hSetEx: HSETEX_1.default,
    HSETNX: HSETNX_1.default,
    hSetNX: HSETNX_1.default,
    HSTRLEN: HSTRLEN_1.default,
    hStrLen: HSTRLEN_1.default,
    HTTL: HTTL_1.default,
    hTTL: HTTL_1.default,
    HVALS: HVALS_1.default,
    hVals: HVALS_1.default,
    INCR: INCR_1.default,
    incr: INCR_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INCRBYFLOAT: INCRBYFLOAT_1.default,
    incrByFloat: INCRBYFLOAT_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    KEYS: KEYS_1.default,
    keys: KEYS_1.default,
    LASTSAVE: LASTSAVE_1.default,
    lastSave: LASTSAVE_1.default,
    LATENCY_DOCTOR: LATENCY_DOCTOR_1.default,
    latencyDoctor: LATENCY_DOCTOR_1.default,
    LATENCY_GRAPH: LATENCY_GRAPH_1.default,
    latencyGraph: LATENCY_GRAPH_1.default,
    LATENCY_HISTORY: LATENCY_HISTORY_1.default,
    latencyHistory: LATENCY_HISTORY_1.default,
    LATENCY_LATEST: LATENCY_LATEST_1.default,
    latencyLatest: LATENCY_LATEST_1.default,
    LCS_IDX_WITHMATCHLEN: LCS_IDX_WITHMATCHLEN_1.default,
    lcsIdxWithMatchLen: LCS_IDX_WITHMATCHLEN_1.default,
    LCS_IDX: LCS_IDX_1.default,
    lcsIdx: LCS_IDX_1.default,
    LCS_LEN: LCS_LEN_1.default,
    lcsLen: LCS_LEN_1.default,
    LCS: LCS_1.default,
    lcs: LCS_1.default,
    LINDEX: LINDEX_1.default,
    lIndex: LINDEX_1.default,
    LINSERT: LINSERT_1.default,
    lInsert: LINSERT_1.default,
    LLEN: LLEN_1.default,
    lLen: LLEN_1.default,
    LMOVE: LMOVE_1.default,
    lMove: LMOVE_1.default,
    LMPOP: LMPOP_1.default,
    lmPop: LMPOP_1.default,
    LOLWUT: LOLWUT_1.default,
    LPOP_COUNT: LPOP_COUNT_1.default,
    lPopCount: LPOP_COUNT_1.default,
    LPOP: LPOP_1.default,
    lPop: LPOP_1.default,
    LPOS_COUNT: LPOS_COUNT_1.default,
    lPosCount: LPOS_COUNT_1.default,
    LPOS: LPOS_1.default,
    lPos: LPOS_1.default,
    LPUSH: LPUSH_1.default,
    lPush: LPUSH_1.default,
    LPUSHX: LPUSHX_1.default,
    lPushX: LPUSHX_1.default,
    LRANGE: LRANGE_1.default,
    lRange: LRANGE_1.default,
    LREM: LREM_1.default,
    lRem: LREM_1.default,
    LSET: LSET_1.default,
    lSet: LSET_1.default,
    LTRIM: LTRIM_1.default,
    lTrim: LTRIM_1.default,
    MEMORY_DOCTOR: MEMORY_DOCTOR_1.default,
    memoryDoctor: MEMORY_DOCTOR_1.default,
    "MEMORY_MALLOC-STATS": MEMORY_MALLOC_STATS_1.default,
    memoryMallocStats: MEMORY_MALLOC_STATS_1.default,
    MEMORY_PURGE: MEMORY_PURGE_1.default,
    memoryPurge: MEMORY_PURGE_1.default,
    MEMORY_STATS: MEMORY_STATS_1.default,
    memoryStats: MEMORY_STATS_1.default,
    MEMORY_USAGE: MEMORY_USAGE_1.default,
    memoryUsage: MEMORY_USAGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MIGRATE: MIGRATE_1.default,
    migrate: MIGRATE_1.default,
    MODULE_LIST: MODULE_LIST_1.default,
    moduleList: MODULE_LIST_1.default,
    MODULE_LOAD: MODULE_LOAD_1.default,
    moduleLoad: MODULE_LOAD_1.default,
    MODULE_UNLOAD: MODULE_UNLOAD_1.default,
    moduleUnload: MODULE_UNLOAD_1.default,
    MOVE: MOVE_1.default,
    move: MOVE_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    MSETNX: MSETNX_1.default,
    mSetNX: MSETNX_1.default,
    OBJECT_ENCODING: OBJECT_ENCODING_1.default,
    objectEncoding: OBJECT_ENCODING_1.default,
    OBJECT_FREQ: OBJECT_FREQ_1.default,
    objectFreq: OBJECT_FREQ_1.default,
    OBJECT_IDLETIME: OBJECT_IDLETIME_1.default,
    objectIdleTime: OBJECT_IDLETIME_1.default,
    OBJECT_REFCOUNT: OBJECT_REFCOUNT_1.default,
    objectRefCount: OBJECT_REFCOUNT_1.default,
    PERSIST: PERSIST_1.default,
    persist: PERSIST_1.default,
    PEXPIRE: PEXPIRE_1.default,
    pExpire: PEXPIRE_1.default,
    PEXPIREAT: PEXPIREAT_1.default,
    pExpireAt: PEXPIREAT_1.default,
    PEXPIRETIME: PEXPIRETIME_1.default,
    pExpireTime: PEXPIRETIME_1.default,
    PFADD: PFADD_1.default,
    pfAdd: PFADD_1.default,
    PFCOUNT: PFCOUNT_1.default,
    pfCount: PFCOUNT_1.default,
    PFMERGE: PFMERGE_1.default,
    pfMerge: PFMERGE_1.default,
    PING: PING_1.default,
    ping: PING_1.default,
    PSETEX: PSETEX_1.default,
    pSetEx: PSETEX_1.default,
    PTTL: PTTL_1.default,
    pTTL: PTTL_1.default,
    PUBLISH: PUBLISH_1.default,
    publish: PUBLISH_1.default,
    PUBSUB_CHANNELS: PUBSUB_CHANNELS_1.default,
    pubSubChannels: PUBSUB_CHANNELS_1.default,
    PUBSUB_NUMPAT: PUBSUB_NUMPAT_1.default,
    pubSubNumPat: PUBSUB_NUMPAT_1.default,
    PUBSUB_NUMSUB: PUBSUB_NUMSUB_1.default,
    pubSubNumSub: PUBSUB_NUMSUB_1.default,
    PUBSUB_SHARDNUMSUB: PUBSUB_SHARDNUMSUB_1.default,
    pubSubShardNumSub: PUBSUB_SHARDNUMSUB_1.default,
    PUBSUB_SHARDCHANNELS: PUBSUB_SHARDCHANNELS_1.default,
    pubSubShardChannels: PUBSUB_SHARDCHANNELS_1.default,
    RANDOMKEY: RANDOMKEY_1.default,
    randomKey: RANDOMKEY_1.default,
    READONLY: READONLY_1.default,
    readonly: READONLY_1.default,
    RENAME: RENAME_1.default,
    rename: RENAME_1.default,
    RENAMENX: RENAMENX_1.default,
    renameNX: RENAMENX_1.default,
    REPLICAOF: REPLICAOF_1.default,
    replicaOf: REPLICAOF_1.default,
    "RESTORE-ASKING": RESTORE_ASKING_1.default,
    restoreAsking: RESTORE_ASKING_1.default,
    RESTORE: RESTORE_1.default,
    restore: RESTORE_1.default,
    RPOP_COUNT: RPOP_COUNT_1.default,
    rPopCount: RPOP_COUNT_1.default,
    ROLE: ROLE_1.default,
    role: ROLE_1.default,
    RPOP: RPOP_1.default,
    rPop: RPOP_1.default,
    RPOPLPUSH: RPOPLPUSH_1.default,
    rPopLPush: RPOPLPUSH_1.default,
    RPUSH: RPUSH_1.default,
    rPush: RPUSH_1.default,
    RPUSHX: RPUSHX_1.default,
    rPushX: RPUSHX_1.default,
    SADD: SADD_1.default,
    sAdd: SADD_1.default,
    SCAN: SCAN_1.default,
    scan: SCAN_1.default,
    SCARD: SCARD_1.default,
    sCard: SCARD_1.default,
    SCRIPT_DEBUG: SCRIPT_DEBUG_1.default,
    scriptDebug: SCRIPT_DEBUG_1.default,
    SCRIPT_EXISTS: SCRIPT_EXISTS_1.default,
    scriptExists: SCRIPT_EXISTS_1.default,
    SCRIPT_FLUSH: SCRIPT_FLUSH_1.default,
    scriptFlush: SCRIPT_FLUSH_1.default,
    SCRIPT_KILL: SCRIPT_KILL_1.default,
    scriptKill: SCRIPT_KILL_1.default,
    SCRIPT_LOAD: SCRIPT_LOAD_1.default,
    scriptLoad: SCRIPT_LOAD_1.default,
    SDIFF: SDIFF_1.default,
    sDiff: SDIFF_1.default,
    SDIFFSTORE: SDIFFSTORE_1.default,
    sDiffStore: SDIFFSTORE_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    SETBIT: SETBIT_1.default,
    setBit: SETBIT_1.default,
    SETEX: SETEX_1.default,
    setEx: SETEX_1.default,
    SETNX: SETNX_1.default,
    setNX: SETNX_1.default,
    SETRANGE: SETRANGE_1.default,
    setRange: SETRANGE_1.default,
    SINTER: SINTER_1.default,
    sInter: SINTER_1.default,
    SINTERCARD: SINTERCARD_1.default,
    sInterCard: SINTERCARD_1.default,
    SINTERSTORE: SINTERSTORE_1.default,
    sInterStore: SINTERSTORE_1.default,
    SISMEMBER: SISMEMBER_1.default,
    sIsMember: SISMEMBER_1.default,
    SMEMBERS: SMEMBERS_1.default,
    sMembers: SMEMBERS_1.default,
    SMISMEMBER: SMISMEMBER_1.default,
    smIsMember: SMISMEMBER_1.default,
    SMOVE: SMOVE_1.default,
    sMove: SMOVE_1.default,
    SORT_RO: SORT_RO_1.default,
    sortRo: SORT_RO_1.default,
    SORT_STORE: SORT_STORE_1.default,
    sortStore: SORT_STORE_1.default,
    SORT: SORT_1.default,
    sort: SORT_1.default,
    SPOP_COUNT: SPOP_COUNT_1.default,
    sPopCount: SPOP_COUNT_1.default,
    SPOP: SPOP_1.default,
    sPop: SPOP_1.default,
    SPUBLISH: SPUBLISH_1.default,
    sPublish: SPUBLISH_1.default,
    SRANDMEMBER_COUNT: SRANDMEMBER_COUNT_1.default,
    sRandMemberCount: SRANDMEMBER_COUNT_1.default,
    SRANDMEMBER: SRANDMEMBER_1.default,
    sRandMember: SRANDMEMBER_1.default,
    SREM: SREM_1.default,
    sRem: SREM_1.default,
    SSCAN: SSCAN_1.default,
    sScan: SSCAN_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    SUNION: SUNION_1.default,
    sUnion: SUNION_1.default,
    SUNIONSTORE: SUNIONSTORE_1.default,
    sUnionStore: SUNIONSTORE_1.default,
    SWAPDB: SWAPDB_1.default,
    swapDb: SWAPDB_1.default,
    TIME: TIME_1.default,
    time: TIME_1.default,
    TOUCH: TOUCH_1.default,
    touch: TOUCH_1.default,
    TTL: TTL_1.default,
    ttl: TTL_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default,
    UNLINK: UNLINK_1.default,
    unlink: UNLINK_1.default,
    WAIT: WAIT_1.default,
    wait: WAIT_1.default,
    XACK: XACK_1.default,
    xAck: XACK_1.default,
    XADD_NOMKSTREAM: XADD_NOMKSTREAM_1.default,
    xAddNoMkStream: XADD_NOMKSTREAM_1.default,
    XADD: XADD_1.default,
    xAdd: XADD_1.default,
    XAUTOCLAIM_JUSTID: XAUTOCLAIM_JUSTID_1.default,
    xAutoClaimJustId: XAUTOCLAIM_JUSTID_1.default,
    XAUTOCLAIM: XAUTOCLAIM_1.default,
    xAutoClaim: XAUTOCLAIM_1.default,
    XCLAIM_JUSTID: XCLAIM_JUSTID_1.default,
    xClaimJustId: XCLAIM_JUSTID_1.default,
    XCLAIM: XCLAIM_1.default,
    xClaim: XCLAIM_1.default,
    XDEL: XDEL_1.default,
    xDel: XDEL_1.default,
    XGROUP_CREATE: XGROUP_CREATE_1.default,
    xGroupCreate: XGROUP_CREATE_1.default,
    XGROUP_CREATECONSUMER: XGROUP_CREATECONSUMER_1.default,
    xGroupCreateConsumer: XGROUP_CREATECONSUMER_1.default,
    XGROUP_DELCONSUMER: XGROUP_DELCONSUMER_1.default,
    xGroupDelConsumer: XGROUP_DELCONSUMER_1.default,
    XGROUP_DESTROY: XGROUP_DESTROY_1.default,
    xGroupDestroy: XGROUP_DESTROY_1.default,
    XGROUP_SETID: XGROUP_SETID_1.default,
    xGroupSetId: XGROUP_SETID_1.default,
    XINFO_CONSUMERS: XINFO_CONSUMERS_1.default,
    xInfoConsumers: XINFO_CONSUMERS_1.default,
    XINFO_GROUPS: XINFO_GROUPS_1.default,
    xInfoGroups: XINFO_GROUPS_1.default,
    XINFO_STREAM: XINFO_STREAM_1.default,
    xInfoStream: XINFO_STREAM_1.default,
    XLEN: XLEN_1.default,
    xLen: XLEN_1.default,
    XPENDING_RANGE: XPENDING_RANGE_1.default,
    xPendingRange: XPENDING_RANGE_1.default,
    XPENDING: XPENDING_1.default,
    xPending: XPENDING_1.default,
    XRANGE: XRANGE_1.default,
    xRange: XRANGE_1.default,
    XREAD: XREAD_1.default,
    xRead: XREAD_1.default,
    XREADGROUP: XREADGROUP_1.default,
    xReadGroup: XREADGROUP_1.default,
    XREVRANGE: XREVRANGE_1.default,
    xRevRange: XREVRANGE_1.default,
    XSETID: XSETID_1.default,
    xSetId: XSETID_1.default,
    XTRIM: XTRIM_1.default,
    xTrim: XTRIM_1.default,
    ZADD_INCR: ZADD_INCR_1.default,
    zAddIncr: ZADD_INCR_1.default,
    ZADD: ZADD_1.default,
    zAdd: ZADD_1.default,
    ZCARD: ZCARD_1.default,
    zCard: ZCARD_1.default,
    ZCOUNT: ZCOUNT_1.default,
    zCount: ZCOUNT_1.default,
    ZDIFF_WITHSCORES: ZDIFF_WITHSCORES_1.default,
    zDiffWithScores: ZDIFF_WITHSCORES_1.default,
    ZDIFF: ZDIFF_1.default,
    zDiff: ZDIFF_1.default,
    ZDIFFSTORE: ZDIFFSTORE_1.default,
    zDiffStore: ZDIFFSTORE_1.default,
    ZINCRBY: ZINCRBY_1.default,
    zIncrBy: ZINCRBY_1.default,
    ZINTER_WITHSCORES: ZINTER_WITHSCORES_1.default,
    zInterWithScores: ZINTER_WITHSCORES_1.default,
    ZINTER: ZINTER_1.default,
    zInter: ZINTER_1.default,
    ZINTERCARD: ZINTERCARD_1.default,
    zInterCard: ZINTERCARD_1.default,
    ZINTERSTORE: ZINTERSTORE_1.default,
    zInterStore: ZINTERSTORE_1.default,
    ZLEXCOUNT: ZLEXCOUNT_1.default,
    zLexCount: ZLEXCOUNT_1.default,
    ZMPOP: ZMPOP_1.default,
    zmPop: ZMPOP_1.default,
    ZMSCORE: ZMSCORE_1.default,
    zmScore: ZMSCORE_1.default,
    ZPOPMAX_COUNT: ZPOPMAX_COUNT_1.default,
    zPopMaxCount: ZPOPMAX_COUNT_1.default,
    ZPOPMAX: ZPOPMAX_1.default,
    zPopMax: ZPOPMAX_1.default,
    ZPOPMIN_COUNT: ZPOPMIN_COUNT_1.default,
    zPopMinCount: ZPOPMIN_COUNT_1.default,
    ZPOPMIN: ZPOPMIN_1.default,
    zPopMin: ZPOPMIN_1.default,
    ZRANDMEMBER_COUNT_WITHSCORES: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    zRandMemberCountWithScores: ZRANDMEMBER_COUNT_WITHSCORES_1.default,
    ZRANDMEMBER_COUNT: ZRANDMEMBER_COUNT_1.default,
    zRandMemberCount: ZRANDMEMBER_COUNT_1.default,
    ZRANDMEMBER: ZRANDMEMBER_1.default,
    zRandMember: ZRANDMEMBER_1.default,
    ZRANGE_WITHSCORES: ZRANGE_WITHSCORES_1.default,
    zRangeWithScores: ZRANGE_WITHSCORES_1.default,
    ZRANGE: ZRANGE_1.default,
    zRange: ZRANGE_1.default,
    ZRANGEBYLEX: ZRANGEBYLEX_1.default,
    zRangeByLex: ZRANGEBYLEX_1.default,
    ZRANGEBYSCORE_WITHSCORES: ZRANGEBYSCORE_WITHSCORES_1.default,
    zRangeByScoreWithScores: ZRANGEBYSCORE_WITHSCORES_1.default,
    ZRANGEBYSCORE: ZRANGEBYSCORE_1.default,
    zRangeByScore: ZRANGEBYSCORE_1.default,
    ZRANGESTORE: ZRANGESTORE_1.default,
    zRangeStore: ZRANGESTORE_1.default,
    ZRANK_WITHSCORE: ZRANK_WITHSCORE_1.default,
    zRankWithScore: ZRANK_WITHSCORE_1.default,
    ZRANK: ZRANK_1.default,
    zRank: ZRANK_1.default,
    ZREM: ZREM_1.default,
    zRem: ZREM_1.default,
    ZREMRANGEBYLEX: ZREMRANGEBYLEX_1.default,
    zRemRangeByLex: ZREMRANGEBYLEX_1.default,
    ZREMRANGEBYRANK: ZREMRANGEBYRANK_1.default,
    zRemRangeByRank: ZREMRANGEBYRANK_1.default,
    ZREMRANGEBYSCORE: ZREMRANGEBYSCORE_1.default,
    zRemRangeByScore: ZREMRANGEBYSCORE_1.default,
    ZREVRANK: ZREVRANK_1.default,
    zRevRank: ZREVRANK_1.default,
    ZSCAN: ZSCAN_1.default,
    zScan: ZSCAN_1.default,
    ZSCORE: ZSCORE_1.default,
    zScore: ZSCORE_1.default,
    ZUNION_WITHSCORES: ZUNION_WITHSCORES_1.default,
    zUnionWithScores: ZUNION_WITHSCORES_1.default,
    ZUNION: ZUNION_1.default,
    zUnion: ZUNION_1.default,
    ZUNIONSTORE: ZUNIONSTORE_1.default,
    zUnionStore: ZUNIONSTORE_1.default,
    VADD: VADD_1.default,
    vAdd: VADD_1.default,
    VCARD: VCARD_1.default,
    vCard: VCARD_1.default,
    VDIM: VDIM_1.default,
    vDim: VDIM_1.default,
    VEMB: VEMB_1.default,
    vEmb: VEMB_1.default,
    VEMB_RAW: VEMB_RAW_1.default,
    vEmbRaw: VEMB_RAW_1.default,
    VGETATTR: VGETATTR_1.default,
    vGetAttr: VGETATTR_1.default,
    VINFO: VINFO_1.default,
    vInfo: VINFO_1.default,
    VLINKS: VLINKS_1.default,
    vLinks: VLINKS_1.default,
    VLINKS_WITHSCORES: VLINKS_WITHSCORES_1.default,
    vLinksWithScores: VLINKS_WITHSCORES_1.default,
    VRANDMEMBER: VRANDMEMBER_1.default,
    vRandMember: VRANDMEMBER_1.default,
    VREM: VREM_1.default,
    vRem: VREM_1.default,
    VSETATTR: VSETATTR_1.default,
    vSetAttr: VSETATTR_1.default,
    VSIM: VSIM_1.default,
    vSim: VSIM_1.default,
    VSIM_WITHSCORES: VSIM_WITHSCORES_1.default,
    vSimWithScores: VSIM_WITHSCORES_1.default
  };
});

// node_modules/@redis/client/dist/lib/client/socket.js
var require_socket2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var node_events_1 = __require("events");
  var node_net_1 = __importDefault(__require("net"));
  var node_tls_1 = __importDefault(__require("tls"));
  var errors_1 = require_errors2();
  var promises_1 = __require("timers/promises");

  class RedisSocket extends node_events_1.EventEmitter {
    #initiator;
    #connectTimeout;
    #reconnectStrategy;
    #socketFactory;
    #socketTimeout;
    #socket;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #isSocketUnrefed = false;
    #socketEpoch = 0;
    get socketEpoch() {
      return this.#socketEpoch;
    }
    constructor(initiator, options) {
      super();
      this.#initiator = initiator;
      this.#connectTimeout = options?.connectTimeout ?? 5000;
      this.#reconnectStrategy = this.#createReconnectStrategy(options);
      this.#socketFactory = this.#createSocketFactory(options);
      this.#socketTimeout = options?.socketTimeout;
    }
    #createReconnectStrategy(options) {
      const strategy = options?.reconnectStrategy;
      if (strategy === false || typeof strategy === "number") {
        return () => strategy;
      }
      if (strategy) {
        return (retries, cause) => {
          try {
            const retryIn = strategy(retries, cause);
            if (retryIn !== false && !(retryIn instanceof Error) && typeof retryIn !== "number") {
              throw new TypeError(`Reconnect strategy should return \`false | Error | number\`, got ${retryIn} instead`);
            }
            return retryIn;
          } catch (err) {
            this.emit("error", err);
            return this.defaultReconnectStrategy(retries, err);
          }
        };
      }
      return this.defaultReconnectStrategy;
    }
    #createSocketFactory(options) {
      if (options?.tls === true) {
        const withDefaults2 = {
          ...options,
          port: options?.port ?? 6379,
          noDelay: options?.noDelay ?? true,
          keepAlive: options?.keepAlive ?? true,
          keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_tls_1.default.connect(withDefaults2);
          },
          event: "secureConnect"
        };
      }
      if (options && "path" in options) {
        const withDefaults2 = {
          ...options,
          timeout: undefined,
          onread: undefined,
          readable: true,
          writable: true
        };
        return {
          create() {
            return node_net_1.default.createConnection(withDefaults2);
          },
          event: "connect"
        };
      }
      const withDefaults = {
        ...options,
        port: options?.port ?? 6379,
        noDelay: options?.noDelay ?? true,
        keepAlive: options?.keepAlive ?? true,
        keepAliveInitialDelay: options?.keepAliveInitialDelay ?? 5000,
        timeout: undefined,
        onread: undefined,
        readable: true,
        writable: true
      };
      return {
        create() {
          return node_net_1.default.createConnection(withDefaults);
        },
        event: "connect"
      };
    }
    #shouldReconnect(retries, cause) {
      const retryIn = this.#reconnectStrategy(retries, cause);
      if (retryIn === false) {
        this.#isOpen = false;
        this.emit("error", cause);
        return cause;
      } else if (retryIn instanceof Error) {
        this.#isOpen = false;
        this.emit("error", cause);
        return new errors_1.ReconnectStrategyError(retryIn, cause);
      }
      return retryIn;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Socket already opened");
      }
      this.#isOpen = true;
      return this.#connect();
    }
    async#connect() {
      let retries = 0;
      do {
        try {
          this.#socket = await this.#createSocket();
          this.emit("connect");
          try {
            await this.#initiator();
          } catch (err) {
            this.#socket.destroy();
            this.#socket = undefined;
            throw err;
          }
          this.#isReady = true;
          this.#socketEpoch++;
          this.emit("ready");
        } catch (err) {
          const retryIn = this.#shouldReconnect(retries++, err);
          if (typeof retryIn !== "number") {
            throw retryIn;
          }
          this.emit("error", err);
          await (0, promises_1.setTimeout)(retryIn);
          this.emit("reconnecting");
        }
      } while (this.#isOpen && !this.#isReady);
    }
    async#createSocket() {
      const socket = this.#socketFactory.create();
      let onTimeout;
      if (this.#connectTimeout !== undefined) {
        onTimeout = () => socket.destroy(new errors_1.ConnectionTimeoutError);
        socket.once("timeout", onTimeout);
        socket.setTimeout(this.#connectTimeout);
      }
      if (this.#isSocketUnrefed) {
        socket.unref();
      }
      await (0, node_events_1.once)(socket, this.#socketFactory.event);
      if (onTimeout) {
        socket.removeListener("timeout", onTimeout);
      }
      if (this.#socketTimeout) {
        socket.once("timeout", () => {
          socket.destroy(new errors_1.SocketTimeoutError(this.#socketTimeout));
        });
        socket.setTimeout(this.#socketTimeout);
      }
      socket.once("error", (err) => this.#onSocketError(err)).once("close", (hadError) => {
        if (hadError || !this.#isOpen || this.#socket !== socket)
          return;
        this.#onSocketError(new errors_1.SocketClosedUnexpectedlyError);
      }).on("drain", () => this.emit("drain")).on("data", (data) => this.emit("data", data));
      return socket;
    }
    #onSocketError(err) {
      const wasReady = this.#isReady;
      this.#isReady = false;
      this.emit("error", err);
      if (!wasReady || !this.#isOpen || typeof this.#shouldReconnect(0, err) !== "number")
        return;
      this.emit("reconnecting");
      this.#connect().catch(() => {});
    }
    write(iterable) {
      if (!this.#socket)
        return;
      this.#socket.cork();
      for (const args of iterable) {
        for (const toWrite of args) {
          this.#socket.write(toWrite);
        }
        if (this.#socket.writableNeedDrain)
          break;
      }
      this.#socket.uncork();
    }
    async quit(fn) {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      const reply = await fn();
      this.destroySocket();
      return reply;
    }
    close() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
    }
    destroy() {
      if (!this.#isOpen) {
        throw new errors_1.ClientClosedError;
      }
      this.#isOpen = false;
      this.destroySocket();
    }
    destroySocket() {
      this.#isReady = false;
      if (this.#socket) {
        this.#socket.destroy();
        this.#socket = undefined;
      }
      this.emit("end");
    }
    ref() {
      this.#isSocketUnrefed = false;
      this.#socket?.ref();
    }
    unref() {
      this.#isSocketUnrefed = true;
      this.#socket?.unref();
    }
    defaultReconnectStrategy(retries, cause) {
      if (cause instanceof errors_1.SocketTimeoutError) {
        return false;
      }
      const jitter = Math.floor(Math.random() * 200);
      const delay = Math.min(Math.pow(2, retries) * 50, 2000);
      return delay + jitter;
    }
  }
  exports.default = RedisSocket;
});

// node_modules/@redis/client/dist/lib/authx/token.js
var require_token = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = undefined;

  class Token {
    value;
    expiresAtMs;
    receivedAtMs;
    constructor(value, expiresAtMs, receivedAtMs) {
      this.value = value;
      this.expiresAtMs = expiresAtMs;
      this.receivedAtMs = receivedAtMs;
    }
    getTtlMs(now) {
      if (this.expiresAtMs < now) {
        return 0;
      }
      return this.expiresAtMs - now;
    }
  }
  exports.Token = Token;
});

// node_modules/@redis/client/dist/lib/authx/token-manager.js
var require_token_manager = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TokenManager = exports.IDPError = undefined;
  var token_1 = require_token();

  class IDPError extends Error {
    message;
    isRetryable;
    constructor(message, isRetryable) {
      super(message);
      this.message = message;
      this.isRetryable = isRetryable;
      this.name = "IDPError";
    }
  }
  exports.IDPError = IDPError;

  class TokenManager {
    identityProvider;
    config;
    currentToken = null;
    refreshTimeout = null;
    listener = null;
    retryAttempt = 0;
    constructor(identityProvider, config2) {
      this.identityProvider = identityProvider;
      this.config = config2;
      if (this.config.expirationRefreshRatio > 1) {
        throw new Error("expirationRefreshRatio must be less than or equal to 1");
      }
      if (this.config.expirationRefreshRatio < 0) {
        throw new Error("expirationRefreshRatio must be greater or equal to 0");
      }
    }
    start(listener, initialDelayMs = 0) {
      if (this.listener) {
        this.stop();
      }
      this.listener = listener;
      this.retryAttempt = 0;
      this.scheduleNextRefresh(initialDelayMs);
      return {
        dispose: () => this.stop()
      };
    }
    calculateRetryDelay() {
      if (!this.config.retry)
        return 0;
      const { initialDelayMs, maxDelayMs, backoffMultiplier, jitterPercentage } = this.config.retry;
      let delay = initialDelayMs * Math.pow(backoffMultiplier, this.retryAttempt - 1);
      delay = Math.min(delay, maxDelayMs);
      if (jitterPercentage) {
        const jitterRange = delay * (jitterPercentage / 100);
        const jitterAmount = Math.random() * jitterRange - jitterRange / 2;
        delay += jitterAmount;
      }
      let result = Math.max(0, Math.floor(delay));
      return result;
    }
    shouldRetry(error40) {
      if (!this.config.retry)
        return false;
      const { maxAttempts, isRetryable } = this.config.retry;
      if (this.retryAttempt >= maxAttempts) {
        return false;
      }
      if (isRetryable) {
        return isRetryable(error40, this.retryAttempt);
      }
      return false;
    }
    isRunning() {
      return this.listener !== null;
    }
    async refresh() {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but refresh was called");
      }
      try {
        await this.identityProvider.requestToken().then(this.handleNewToken);
        this.retryAttempt = 0;
      } catch (error40) {
        if (this.shouldRetry(error40)) {
          this.retryAttempt++;
          const retryDelay = this.calculateRetryDelay();
          this.notifyError(`Token refresh failed (attempt ${this.retryAttempt}), retrying in ${retryDelay}ms: ${error40}`, true);
          this.scheduleNextRefresh(retryDelay);
        } else {
          this.notifyError(error40, false);
          this.stop();
        }
      }
    }
    handleNewToken = async ({ token: nativeToken, ttlMs }) => {
      if (!this.listener) {
        throw new Error("TokenManager is not running, but a new token was received");
      }
      const token = this.wrapAndSetCurrentToken(nativeToken, ttlMs);
      this.listener.onNext(token);
      this.scheduleNextRefresh(this.calculateRefreshTime(token));
    };
    wrapAndSetCurrentToken(nativeToken, ttlMs) {
      const now = Date.now();
      const token = new token_1.Token(nativeToken, now + ttlMs, now);
      this.currentToken = token;
      return token;
    }
    scheduleNextRefresh(delayMs) {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      if (delayMs === 0) {
        this.refresh();
      } else {
        this.refreshTimeout = setTimeout(() => this.refresh(), delayMs);
      }
    }
    calculateRefreshTime(token, now = Date.now()) {
      const ttlMs = token.getTtlMs(now);
      return Math.floor(ttlMs * this.config.expirationRefreshRatio);
    }
    stop() {
      if (this.refreshTimeout) {
        clearTimeout(this.refreshTimeout);
        this.refreshTimeout = null;
      }
      this.listener = null;
      this.currentToken = null;
      this.retryAttempt = 0;
    }
    getCurrentToken() {
      return this.currentToken;
    }
    notifyError(error40, isRetryable) {
      const errorMessage = error40 instanceof Error ? error40.message : String(error40);
      if (!this.listener) {
        throw new Error(`TokenManager is not running but received an error: ${errorMessage}`);
      }
      this.listener.onError(new IDPError(errorMessage, isRetryable));
    }
  }
  exports.TokenManager = TokenManager;
});

// node_modules/@redis/client/dist/lib/authx/credentials-provider.js
var require_credentials_provider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnableToObtainNewCredentialsError = exports.CredentialsError = undefined;

  class CredentialsError extends Error {
    constructor(message) {
      super(`Re-authentication with latest credentials failed: ${message}`);
      this.name = "CredentialsError";
    }
  }
  exports.CredentialsError = CredentialsError;

  class UnableToObtainNewCredentialsError extends Error {
    constructor(message) {
      super(`Unable to obtain new credentials : ${message}`);
      this.name = "UnableToObtainNewCredentialsError";
    }
  }
  exports.UnableToObtainNewCredentialsError = UnableToObtainNewCredentialsError;
});

// node_modules/@redis/client/dist/lib/authx/index.js
var require_authx = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Token = exports.CredentialsError = exports.UnableToObtainNewCredentialsError = exports.IDPError = exports.TokenManager = undefined;
  var token_manager_1 = require_token_manager();
  Object.defineProperty(exports, "TokenManager", { enumerable: true, get: function() {
    return token_manager_1.TokenManager;
  } });
  Object.defineProperty(exports, "IDPError", { enumerable: true, get: function() {
    return token_manager_1.IDPError;
  } });
  var credentials_provider_1 = require_credentials_provider();
  Object.defineProperty(exports, "UnableToObtainNewCredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.UnableToObtainNewCredentialsError;
  } });
  Object.defineProperty(exports, "CredentialsError", { enumerable: true, get: function() {
    return credentials_provider_1.CredentialsError;
  } });
  var token_1 = require_token();
  Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
    return token_1.Token;
  } });
});

// node_modules/@redis/client/dist/lib/client/linked-list.js
var require_linked_list = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SinglyLinkedList = exports.DoublyLinkedList = undefined;

  class DoublyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      if (this.#tail === undefined) {
        return this.#tail = this.#head = {
          previous: this.#head,
          next: undefined,
          value
        };
      }
      return this.#tail = this.#tail.next = {
        previous: this.#tail,
        next: undefined,
        value
      };
    }
    unshift(value) {
      ++this.#length;
      if (this.#head === undefined) {
        return this.#head = this.#tail = {
          previous: undefined,
          next: undefined,
          value
        };
      }
      return this.#head = this.#head.previous = {
        previous: undefined,
        next: this.#head,
        value
      };
    }
    add(value, prepend = false) {
      return prepend ? this.unshift(value) : this.push(value);
    }
    shift() {
      if (this.#head === undefined)
        return;
      --this.#length;
      const node = this.#head;
      if (node.next) {
        node.next.previous = node.previous;
        this.#head = node.next;
        node.next = undefined;
      } else {
        this.#head = this.#tail = undefined;
      }
      return node.value;
    }
    remove(node) {
      --this.#length;
      if (this.#tail === node) {
        this.#tail = node.previous;
      }
      if (this.#head === node) {
        this.#head = node.next;
      } else {
        node.previous.next = node.next;
        node.previous = undefined;
      }
      node.next = undefined;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.DoublyLinkedList = DoublyLinkedList;

  class SinglyLinkedList {
    #length = 0;
    get length() {
      return this.#length;
    }
    #head;
    get head() {
      return this.#head;
    }
    #tail;
    get tail() {
      return this.#tail;
    }
    push(value) {
      ++this.#length;
      const node = {
        value,
        next: undefined,
        removed: false
      };
      if (this.#head === undefined) {
        return this.#head = this.#tail = node;
      }
      return this.#tail.next = this.#tail = node;
    }
    remove(node, parent) {
      if (node.removed) {
        throw new Error("node already removed");
      }
      --this.#length;
      if (this.#head === node) {
        if (this.#tail === node) {
          this.#head = this.#tail = undefined;
        } else {
          this.#head = node.next;
        }
      } else if (this.#tail === node) {
        this.#tail = parent;
        parent.next = undefined;
      } else {
        parent.next = node.next;
      }
      node.removed = true;
    }
    shift() {
      if (this.#head === undefined)
        return;
      const node = this.#head;
      if (--this.#length === 0) {
        this.#head = this.#tail = undefined;
      } else {
        this.#head = node.next;
      }
      node.removed = true;
      return node.value;
    }
    reset() {
      this.#length = 0;
      this.#head = this.#tail = undefined;
    }
    *[Symbol.iterator]() {
      let node = this.#head;
      while (node !== undefined) {
        yield node.value;
        node = node.next;
      }
    }
  }
  exports.SinglyLinkedList = SinglyLinkedList;
});

// node_modules/@redis/client/dist/lib/RESP/encoder.js
var require_encoder2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CRLF = `\r
`;
  function encodeCommand(args) {
    const toWrite = [];
    let strings = "*" + args.length + CRLF;
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        strings += "$" + Buffer.byteLength(arg) + CRLF + arg + CRLF;
      } else if (arg instanceof Buffer) {
        toWrite.push(strings + "$" + arg.length.toString() + CRLF, arg);
        strings = CRLF;
      } else {
        throw new TypeError(`"arguments[${i}]" must be of type "string | Buffer", got ${typeof arg} instead.`);
      }
    }
    toWrite.push(strings);
    return toWrite;
  }
  exports.default = encodeCommand;
});

// node_modules/@redis/client/dist/lib/client/pub-sub.js
var require_pub_sub = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSub = exports.PUBSUB_TYPE = undefined;
  exports.PUBSUB_TYPE = {
    CHANNELS: "CHANNELS",
    PATTERNS: "PATTERNS",
    SHARDED: "SHARDED"
  };
  var COMMANDS = {
    [exports.PUBSUB_TYPE.CHANNELS]: {
      subscribe: Buffer.from("subscribe"),
      unsubscribe: Buffer.from("unsubscribe"),
      message: Buffer.from("message")
    },
    [exports.PUBSUB_TYPE.PATTERNS]: {
      subscribe: Buffer.from("psubscribe"),
      unsubscribe: Buffer.from("punsubscribe"),
      message: Buffer.from("pmessage")
    },
    [exports.PUBSUB_TYPE.SHARDED]: {
      subscribe: Buffer.from("ssubscribe"),
      unsubscribe: Buffer.from("sunsubscribe"),
      message: Buffer.from("smessage")
    }
  };

  class PubSub {
    static isStatusReply(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.CHANNELS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.CHANNELS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].subscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.PATTERNS].unsubscribe.equals(reply[0]) || COMMANDS[exports.PUBSUB_TYPE.SHARDED].subscribe.equals(reply[0]);
    }
    static isShardedUnsubscribe(reply) {
      return COMMANDS[exports.PUBSUB_TYPE.SHARDED].unsubscribe.equals(reply[0]);
    }
    static #channelsArray(channels) {
      return Array.isArray(channels) ? channels : [channels];
    }
    static #listenersSet(listeners, returnBuffers) {
      return returnBuffers ? listeners.buffers : listeners.strings;
    }
    #subscribing = 0;
    #isActive = false;
    get isActive() {
      return this.#isActive;
    }
    listeners = {
      [exports.PUBSUB_TYPE.CHANNELS]: new Map,
      [exports.PUBSUB_TYPE.PATTERNS]: new Map,
      [exports.PUBSUB_TYPE.SHARDED]: new Map
    };
    subscribe(type, channels, listener, returnBuffers) {
      const args = [COMMANDS[type].subscribe], channelsArray = PubSub.#channelsArray(channels);
      for (const channel of channelsArray) {
        let channelListeners = this.listeners[type].get(channel);
        if (!channelListeners || channelListeners.unsubscribing) {
          args.push(channel);
        }
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(this.listeners[type].get(channel), returnBuffers).add(listener);
        }
        return;
      }
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => {
          this.#subscribing--;
          for (const channel of channelsArray) {
            let listeners = this.listeners[type].get(channel);
            if (!listeners) {
              listeners = {
                unsubscribing: false,
                buffers: new Set,
                strings: new Set
              };
              this.listeners[type].set(channel, listeners);
            }
            PubSub.#listenersSet(listeners, returnBuffers).add(listener);
          }
        },
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    extendChannelListeners(type, channel, listeners) {
      if (!this.#extendChannelListeners(type, channel, listeners))
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args: [
          COMMANDS[type].subscribe,
          channel
        ],
        channelsCounter: 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    #extendChannelListeners(type, channel, listeners) {
      const existingListeners = this.listeners[type].get(channel);
      if (!existingListeners) {
        this.listeners[type].set(channel, listeners);
        return true;
      }
      for (const listener of listeners.buffers) {
        existingListeners.buffers.add(listener);
      }
      for (const listener of listeners.strings) {
        existingListeners.strings.add(listener);
      }
      return false;
    }
    extendTypeListeners(type, listeners) {
      const args = [COMMANDS[type].subscribe];
      for (const [channel, channelListeners] of listeners) {
        if (this.#extendChannelListeners(type, channel, channelListeners)) {
          args.push(channel);
        }
      }
      if (args.length === 1)
        return;
      this.#isActive = true;
      this.#subscribing++;
      return {
        args,
        channelsCounter: args.length - 1,
        resolve: () => this.#subscribing--,
        reject: () => {
          this.#subscribing--;
          this.#updateIsActive();
        }
      };
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const listeners = this.listeners[type];
      if (!channels) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe], NaN, () => listeners.clear());
      }
      const channelsArray = PubSub.#channelsArray(channels);
      if (!listener) {
        return this.#unsubscribeCommand([COMMANDS[type].unsubscribe, ...channelsArray], channelsArray.length, () => {
          for (const channel of channelsArray) {
            listeners.delete(channel);
          }
        });
      }
      const args = [COMMANDS[type].unsubscribe];
      for (const channel of channelsArray) {
        const sets = listeners.get(channel);
        if (sets) {
          let current, other;
          if (returnBuffers) {
            current = sets.buffers;
            other = sets.strings;
          } else {
            current = sets.strings;
            other = sets.buffers;
          }
          const currentSize = current.has(listener) ? current.size - 1 : current.size;
          if (currentSize !== 0 || other.size !== 0)
            continue;
          sets.unsubscribing = true;
        }
        args.push(channel);
      }
      if (args.length === 1) {
        for (const channel of channelsArray) {
          PubSub.#listenersSet(listeners.get(channel), returnBuffers).delete(listener);
        }
        return;
      }
      return this.#unsubscribeCommand(args, args.length - 1, () => {
        for (const channel of channelsArray) {
          const sets = listeners.get(channel);
          if (!sets)
            continue;
          (returnBuffers ? sets.buffers : sets.strings).delete(listener);
          if (sets.buffers.size === 0 && sets.strings.size === 0) {
            listeners.delete(channel);
          }
        }
      });
    }
    #unsubscribeCommand(args, channelsCounter, removeListeners) {
      return {
        args,
        channelsCounter,
        resolve: () => {
          removeListeners();
          this.#updateIsActive();
        },
        reject: undefined
      };
    }
    #updateIsActive() {
      this.#isActive = this.listeners[exports.PUBSUB_TYPE.CHANNELS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.PATTERNS].size !== 0 || this.listeners[exports.PUBSUB_TYPE.SHARDED].size !== 0 || this.#subscribing !== 0;
    }
    reset() {
      this.#isActive = false;
      this.#subscribing = 0;
    }
    resubscribe() {
      const commands = [];
      for (const [type, listeners] of Object.entries(this.listeners)) {
        if (!listeners.size)
          continue;
        this.#isActive = true;
        this.#subscribing++;
        const callback = () => this.#subscribing--;
        commands.push({
          args: [
            COMMANDS[type].subscribe,
            ...listeners.keys()
          ],
          channelsCounter: listeners.size,
          resolve: callback,
          reject: callback
        });
      }
      return commands;
    }
    handleMessageReply(reply) {
      if (COMMANDS[exports.PUBSUB_TYPE.CHANNELS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.CHANNELS, reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.PATTERNS].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.PATTERNS, reply[3], reply[2], reply[1]);
        return true;
      } else if (COMMANDS[exports.PUBSUB_TYPE.SHARDED].message.equals(reply[0])) {
        this.#emitPubSubMessage(exports.PUBSUB_TYPE.SHARDED, reply[2], reply[1]);
        return true;
      }
      return false;
    }
    removeShardedListeners(channel) {
      const listeners = this.listeners[exports.PUBSUB_TYPE.SHARDED].get(channel);
      this.listeners[exports.PUBSUB_TYPE.SHARDED].delete(channel);
      this.#updateIsActive();
      return listeners;
    }
    #emitPubSubMessage(type, message, channel, pattern) {
      const keyString = (pattern ?? channel).toString(), listeners = this.listeners[type].get(keyString);
      if (!listeners)
        return;
      for (const listener of listeners.buffers) {
        listener(message, channel);
      }
      if (!listeners.strings.size)
        return;
      const channelString = pattern ? channel.toString() : keyString, messageString = channelString === "__redis__:invalidate" ? message === null ? null : message.map((x) => x.toString()) : message.toString();
      for (const listener of listeners.strings) {
        listener(messageString, channelString);
      }
    }
  }
  exports.PubSub = PubSub;
});

// node_modules/@redis/client/dist/lib/client/commands-queue.js
var require_commands_queue = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var linked_list_1 = require_linked_list();
  var encoder_1 = __importDefault(require_encoder2());
  var decoder_1 = require_decoder9();
  var pub_sub_1 = require_pub_sub();
  var errors_1 = require_errors2();
  var PONG = Buffer.from("pong");
  var RESET = Buffer.from("RESET");
  var RESP2_PUSH_TYPE_MAPPING = {
    ...decoder_1.PUSH_TYPE_MAPPING,
    [decoder_1.RESP_TYPES.SIMPLE_STRING]: Buffer
  };

  class RedisCommandsQueue {
    #respVersion;
    #maxLength;
    #toWrite = new linked_list_1.DoublyLinkedList;
    #waitingForReply = new linked_list_1.SinglyLinkedList;
    #onShardedChannelMoved;
    #chainInExecution;
    decoder;
    #pubSub = new pub_sub_1.PubSub;
    get isPubSubActive() {
      return this.#pubSub.isActive;
    }
    #invalidateCallback;
    constructor(respVersion, maxLength, onShardedChannelMoved) {
      this.#respVersion = respVersion;
      this.#maxLength = maxLength;
      this.#onShardedChannelMoved = onShardedChannelMoved;
      this.decoder = this.#initiateDecoder();
    }
    #onReply(reply) {
      this.#waitingForReply.shift().resolve(reply);
    }
    #onErrorReply(err) {
      this.#waitingForReply.shift().reject(err);
    }
    #onPush(push) {
      if (this.#pubSub.handleMessageReply(push))
        return true;
      const isShardedUnsubscribe = pub_sub_1.PubSub.isShardedUnsubscribe(push);
      if (isShardedUnsubscribe && !this.#waitingForReply.length) {
        const channel = push[1].toString();
        this.#onShardedChannelMoved(channel, this.#pubSub.removeShardedListeners(channel));
        return true;
      } else if (isShardedUnsubscribe || pub_sub_1.PubSub.isStatusReply(push)) {
        const head = this.#waitingForReply.head.value;
        if (Number.isNaN(head.channelsCounter) && push[2] === 0 || --head.channelsCounter === 0) {
          this.#waitingForReply.shift().resolve();
        }
        return true;
      }
    }
    #getTypeMapping() {
      return this.#waitingForReply.head.value.typeMapping ?? {};
    }
    #initiateDecoder() {
      return new decoder_1.Decoder({
        onReply: (reply) => this.#onReply(reply),
        onErrorReply: (err) => this.#onErrorReply(err),
        onPush: (push) => {
          if (!this.#onPush(push)) {
            switch (push[0].toString()) {
              case "invalidate": {
                if (this.#invalidateCallback) {
                  if (push[1] !== null) {
                    for (const key of push[1]) {
                      this.#invalidateCallback(key);
                    }
                  } else {
                    this.#invalidateCallback(null);
                  }
                }
                break;
              }
            }
          }
        },
        getTypeMapping: () => this.#getTypeMapping()
      });
    }
    setInvalidateCallback(callback) {
      this.#invalidateCallback = callback;
    }
    addCommand(args, options) {
      if (this.#maxLength && this.#toWrite.length + this.#waitingForReply.length >= this.#maxLength) {
        return Promise.reject(new Error("The queue is full"));
      } else if (options?.abortSignal?.aborted) {
        return Promise.reject(new errors_1.AbortError);
      }
      return new Promise((resolve, reject) => {
        let node;
        const value = {
          args,
          chainId: options?.chainId,
          abort: undefined,
          timeout: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping: options?.typeMapping
        };
        const timeout = options?.timeout;
        if (timeout) {
          const signal2 = AbortSignal.timeout(timeout);
          value.timeout = {
            signal: signal2,
            listener: () => {
              this.#toWrite.remove(node);
              value.reject(new errors_1.TimeoutError);
            }
          };
          signal2.addEventListener("abort", value.timeout.listener, { once: true });
        }
        const signal = options?.abortSignal;
        if (signal) {
          value.abort = {
            signal,
            listener: () => {
              this.#toWrite.remove(node);
              value.reject(new errors_1.AbortError);
            }
          };
          signal.addEventListener("abort", value.abort.listener, { once: true });
        }
        node = this.#toWrite.add(value, options?.asap);
      });
    }
    #addPubSubCommand(command, asap = false, chainId) {
      return new Promise((resolve, reject) => {
        this.#toWrite.add({
          args: command.args,
          chainId,
          abort: undefined,
          timeout: undefined,
          resolve() {
            command.resolve();
            resolve();
          },
          reject(err) {
            command.reject?.();
            reject(err);
          },
          channelsCounter: command.channelsCounter,
          typeMapping: decoder_1.PUSH_TYPE_MAPPING
        }, asap);
      });
    }
    #setupPubSubHandler() {
      if (this.#respVersion !== 2)
        return;
      this.decoder.onReply = (reply) => {
        if (Array.isArray(reply)) {
          if (this.#onPush(reply))
            return;
          if (PONG.equals(reply[0])) {
            const { resolve, typeMapping } = this.#waitingForReply.shift(), buffer = reply[1].length === 0 ? reply[0] : reply[1];
            resolve(typeMapping?.[decoder_1.RESP_TYPES.SIMPLE_STRING] === Buffer ? buffer : buffer.toString());
            return;
          }
        }
        return this.#onReply(reply);
      };
      this.decoder.getTypeMapping = () => RESP2_PUSH_TYPE_MAPPING;
    }
    subscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.subscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    #resetDecoderCallbacks() {
      this.decoder.onReply = (reply) => this.#onReply(reply);
      this.decoder.getTypeMapping = () => this.#getTypeMapping();
    }
    unsubscribe(type, channels, listener, returnBuffers) {
      const command = this.#pubSub.unsubscribe(type, channels, listener, returnBuffers);
      if (!command)
        return;
      if (command && this.#respVersion === 2) {
        const { resolve } = command;
        command.resolve = () => {
          if (!this.#pubSub.isActive) {
            this.#resetDecoderCallbacks();
          }
          resolve();
        };
      }
      return this.#addPubSubCommand(command);
    }
    resubscribe(chainId) {
      const commands = this.#pubSub.resubscribe();
      if (!commands.length)
        return;
      this.#setupPubSubHandler();
      return Promise.all(commands.map((command) => this.#addPubSubCommand(command, true, chainId)));
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      const command = this.#pubSub.extendChannelListeners(type, channel, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    extendPubSubListeners(type, listeners) {
      const command = this.#pubSub.extendTypeListeners(type, listeners);
      if (!command)
        return;
      this.#setupPubSubHandler();
      return this.#addPubSubCommand(command);
    }
    getPubSubListeners(type) {
      return this.#pubSub.listeners[type];
    }
    monitor(callback, options) {
      return new Promise((resolve, reject) => {
        const typeMapping = options?.typeMapping ?? {};
        this.#toWrite.add({
          args: ["MONITOR"],
          chainId: options?.chainId,
          abort: undefined,
          timeout: undefined,
          resolve: () => {
            if (this.#resetFallbackOnReply) {
              this.#resetFallbackOnReply = callback;
            } else {
              this.decoder.onReply = callback;
            }
            this.decoder.getTypeMapping = () => typeMapping;
            resolve();
          },
          reject,
          channelsCounter: undefined,
          typeMapping
        }, options?.asap);
      });
    }
    resetDecoder() {
      this.#resetDecoderCallbacks();
      this.decoder.reset();
    }
    #resetFallbackOnReply;
    async reset(chainId, typeMapping) {
      return new Promise((resolve, reject) => {
        this.#resetFallbackOnReply = this.decoder.onReply;
        this.decoder.onReply = (reply) => {
          if (typeof reply === "string" && reply === "RESET" || reply instanceof Buffer && RESET.equals(reply)) {
            this.#resetDecoderCallbacks();
            this.#resetFallbackOnReply = undefined;
            this.#pubSub.reset();
            this.#waitingForReply.shift().resolve(reply);
            return;
          }
          this.#resetFallbackOnReply(reply);
        };
        this.#toWrite.push({
          args: ["RESET"],
          chainId,
          abort: undefined,
          timeout: undefined,
          resolve,
          reject,
          channelsCounter: undefined,
          typeMapping
        });
      });
    }
    isWaitingToWrite() {
      return this.#toWrite.length > 0;
    }
    *commandsToWrite() {
      let toSend = this.#toWrite.shift();
      while (toSend) {
        let encoded;
        try {
          encoded = (0, encoder_1.default)(toSend.args);
        } catch (err) {
          toSend.reject(err);
          toSend = this.#toWrite.shift();
          continue;
        }
        toSend.args = undefined;
        if (toSend.abort) {
          RedisCommandsQueue.#removeAbortListener(toSend);
          toSend.abort = undefined;
        }
        if (toSend.timeout) {
          RedisCommandsQueue.#removeTimeoutListener(toSend);
          toSend.timeout = undefined;
        }
        this.#chainInExecution = toSend.chainId;
        toSend.chainId = undefined;
        this.#waitingForReply.push(toSend);
        yield encoded;
        toSend = this.#toWrite.shift();
      }
    }
    #flushWaitingForReply(err) {
      for (const node of this.#waitingForReply) {
        node.reject(err);
      }
      this.#waitingForReply.reset();
    }
    static #removeAbortListener(command) {
      command.abort.signal.removeEventListener("abort", command.abort.listener);
    }
    static #removeTimeoutListener(command) {
      command.timeout.signal.removeEventListener("abort", command.timeout.listener);
    }
    static #flushToWrite(toBeSent, err) {
      if (toBeSent.abort) {
        RedisCommandsQueue.#removeAbortListener(toBeSent);
      }
      if (toBeSent.timeout) {
        RedisCommandsQueue.#removeTimeoutListener(toBeSent);
      }
      toBeSent.reject(err);
    }
    flushWaitingForReply(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      if (!this.#chainInExecution)
        return;
      while (this.#toWrite.head?.value.chainId === this.#chainInExecution) {
        RedisCommandsQueue.#flushToWrite(this.#toWrite.shift(), err);
      }
      this.#chainInExecution = undefined;
    }
    flushAll(err) {
      this.resetDecoder();
      this.#pubSub.reset();
      this.#flushWaitingForReply(err);
      for (const node of this.#toWrite) {
        RedisCommandsQueue.#flushToWrite(node, err);
      }
      this.#toWrite.reset();
    }
    isEmpty() {
      return this.#toWrite.length === 0 && this.#waitingForReply.length === 0;
    }
  }
  exports.default = RedisCommandsQueue;
});

// node_modules/@redis/client/dist/lib/commander.js
var require_commander = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scriptArgumentsPrefix = exports.functionArgumentsPrefix = exports.getTransformReply = exports.attachConfig = undefined;
  function throwResp3SearchModuleUnstableError() {
    throw new Error("Some RESP3 results for Redis Query Engine responses may change. Refer to the readme for guidance");
  }
  function attachConfig({ BaseClass, commands, createCommand, createModuleCommand, createFunctionCommand, createScriptCommand, config: config2 }) {
    const RESP = config2?.RESP ?? 2, Class2 = class extends BaseClass {
    };
    for (const [name, command] of Object.entries(commands)) {
      if (config2?.RESP == 3 && command.unstableResp3 && !config2.unstableResp3) {
        Class2.prototype[name] = throwResp3SearchModuleUnstableError;
      } else {
        Class2.prototype[name] = createCommand(command, RESP);
      }
    }
    if (config2?.modules) {
      for (const [moduleName, module2] of Object.entries(config2.modules)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(module2)) {
          if (config2.RESP == 3 && command.unstableResp3 && !config2.unstableResp3) {
            fns[name] = throwResp3SearchModuleUnstableError;
          } else {
            fns[name] = createModuleCommand(command, RESP);
          }
        }
        attachNamespace(Class2.prototype, moduleName, fns);
      }
    }
    if (config2?.functions) {
      for (const [library, commands2] of Object.entries(config2.functions)) {
        const fns = Object.create(null);
        for (const [name, command] of Object.entries(commands2)) {
          fns[name] = createFunctionCommand(name, command, RESP);
        }
        attachNamespace(Class2.prototype, library, fns);
      }
    }
    if (config2?.scripts) {
      for (const [name, script] of Object.entries(config2.scripts)) {
        Class2.prototype[name] = createScriptCommand(script, RESP);
      }
    }
    return Class2;
  }
  exports.attachConfig = attachConfig;
  function attachNamespace(prototype, name, fns) {
    Object.defineProperty(prototype, name, {
      get() {
        const value = Object.create(fns);
        value._self = this;
        Object.defineProperty(this, name, { value });
        return value;
      }
    });
  }
  function getTransformReply(command, resp) {
    switch (typeof command.transformReply) {
      case "function":
        return command.transformReply;
      case "object":
        return command.transformReply[resp];
    }
  }
  exports.getTransformReply = getTransformReply;
  function functionArgumentsPrefix(name, fn) {
    const prefix = [
      fn.IS_READ_ONLY ? "FCALL_RO" : "FCALL",
      name
    ];
    if (fn.NUMBER_OF_KEYS !== undefined) {
      prefix.push(fn.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.functionArgumentsPrefix = functionArgumentsPrefix;
  function scriptArgumentsPrefix(script) {
    const prefix = [
      script.IS_READ_ONLY ? "EVALSHA_RO" : "EVALSHA",
      script.SHA1
    ];
    if (script.NUMBER_OF_KEYS !== undefined) {
      prefix.push(script.NUMBER_OF_KEYS.toString());
    }
    return prefix;
  }
  exports.scriptArgumentsPrefix = scriptArgumentsPrefix;
});

// node_modules/@redis/client/dist/lib/multi-command.js
var require_multi_command = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors2();

  class RedisMultiCommand {
    typeMapping;
    constructor(typeMapping) {
      this.typeMapping = typeMapping;
    }
    queue = [];
    scriptsInUse = new Set;
    addCommand(args, transformReply) {
      this.queue.push({
        args,
        transformReply
      });
    }
    addScript(script, args, transformReply) {
      const redisArgs = [];
      redisArgs.preserve = args.preserve;
      if (this.scriptsInUse.has(script.SHA1)) {
        redisArgs.push("EVALSHA", script.SHA1);
      } else {
        this.scriptsInUse.add(script.SHA1);
        redisArgs.push("EVAL", script.SCRIPT);
      }
      if (script.NUMBER_OF_KEYS !== undefined) {
        redisArgs.push(script.NUMBER_OF_KEYS.toString());
      }
      redisArgs.push(...args);
      this.addCommand(redisArgs, transformReply);
    }
    transformReplies(rawReplies) {
      const errorIndexes = [], replies = rawReplies.map((reply, i) => {
        if (reply instanceof errors_1.ErrorReply) {
          errorIndexes.push(i);
          return reply;
        }
        const { transformReply, args } = this.queue[i];
        return transformReply ? transformReply(reply, args.preserve, this.typeMapping) : reply;
      });
      if (errorIndexes.length)
        throw new errors_1.MultiErrorReply(replies, errorIndexes);
      return replies;
    }
  }
  exports.default = RedisMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/multi-command.js
var require_multi_command2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisClientMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.#addScript(script, redisArgs, transformReply);
      };
    }
    static extend(config2) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClientMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClientMultiCommand.#createCommand,
        createModuleCommand: RedisClientMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClientMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClientMultiCommand.#createScriptCommand,
        config: config2
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #selectedDB;
    constructor(executeMulti, executePipeline, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
    }
    SELECT(db, transformReply) {
      this.#selectedDB = db;
      this.#multi.addCommand(["SELECT", db.toString()], transformReply);
      return this;
    }
    select = this.SELECT;
    addCommand(args, transformReply) {
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(script, args, transformReply) {
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#multi.queue, this.#selectedDB));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#multi.queue, this.#selectedDB));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClientMultiCommand;
});

// node_modules/@redis/client/dist/lib/client/legacy-mode.js
var require_legacy_mode = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisLegacyClient = undefined;
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());

  class RedisLegacyClient {
    static #transformArguments(redisArgs, args) {
      let callback;
      if (typeof args[args.length - 1] === "function") {
        callback = args.pop();
      }
      RedisLegacyClient.pushArguments(redisArgs, args);
      return callback;
    }
    static pushArguments(redisArgs, args) {
      for (let i = 0;i < args.length; ++i) {
        const arg = args[i];
        if (Array.isArray(arg)) {
          RedisLegacyClient.pushArguments(redisArgs, arg);
        } else {
          redisArgs.push(typeof arg === "number" || arg instanceof Date ? arg.toString() : arg);
        }
      }
    }
    static getTransformReply(command, resp) {
      return command.TRANSFORM_LEGACY_REPLY ? (0, commander_1.getTransformReply)(command, resp) : undefined;
    }
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise2 = this.#client.sendCommand(redisArgs);
        if (!callback) {
          promise2.catch((err) => this.#client.emit("error", err));
          return;
        }
        promise2.then((reply) => callback(null, transformReply ? transformReply(reply) : reply)).catch((err) => callback(err));
      };
    }
    #client;
    #Multi;
    constructor(client) {
      this.#client = client;
      const RESP = client.options?.RESP ?? 2;
      for (const [name, command] of Object.entries(commands_1.default)) {
        this[name] = RedisLegacyClient.#createCommand(name, command, RESP);
      }
      this.#Multi = LegacyMultiCommand.factory(RESP);
    }
    sendCommand(...args) {
      const redisArgs = [], callback = RedisLegacyClient.#transformArguments(redisArgs, args), promise2 = this.#client.sendCommand(redisArgs);
      if (!callback) {
        promise2.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise2.then((reply) => callback(null, reply)).catch((err) => callback(err));
    }
    multi() {
      return this.#Multi(this.#client);
    }
  }
  exports.RedisLegacyClient = RedisLegacyClient;

  class LegacyMultiCommand {
    static #createCommand(name, command, resp) {
      const transformReply = RedisLegacyClient.getTransformReply(command, resp);
      return function(...args) {
        const redisArgs = [name];
        RedisLegacyClient.pushArguments(redisArgs, args);
        this.#multi.addCommand(redisArgs, transformReply);
        return this;
      };
    }
    static factory(resp) {
      const Multi = class extends LegacyMultiCommand {
      };
      for (const [name, command] of Object.entries(commands_1.default)) {
        Multi.prototype[name] = LegacyMultiCommand.#createCommand(name, command, resp);
      }
      return (client) => {
        return new Multi(client);
      };
    }
    #multi = new multi_command_1.default;
    #client;
    constructor(client) {
      this.#client = client;
    }
    sendCommand(...args) {
      const redisArgs = [];
      RedisLegacyClient.pushArguments(redisArgs, args);
      this.#multi.addCommand(redisArgs);
      return this;
    }
    exec(cb) {
      const promise2 = this.#client._executeMulti(this.#multi.queue);
      if (!cb) {
        promise2.catch((err) => this.#client.emit("error", err));
        return;
      }
      promise2.then((results) => cb(null, this.#multi.transformReplies(results))).catch((err) => cb?.(err));
    }
  }
});

// node_modules/@redis/client/dist/lib/client/cache.js
var require_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PooledNoRedirectClientSideCache = exports.BasicPooledClientSideCache = exports.PooledClientSideCacheProvider = exports.BasicClientSideCache = exports.ClientSideCacheProvider = exports.CacheStats = undefined;
  var stream_1 = __require("stream");

  class CacheStats {
    hitCount;
    missCount;
    loadSuccessCount;
    loadFailureCount;
    totalLoadTime;
    evictionCount;
    constructor(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount) {
      this.hitCount = hitCount;
      this.missCount = missCount;
      this.loadSuccessCount = loadSuccessCount;
      this.loadFailureCount = loadFailureCount;
      this.totalLoadTime = totalLoadTime;
      this.evictionCount = evictionCount;
      if (hitCount < 0 || missCount < 0 || loadSuccessCount < 0 || loadFailureCount < 0 || totalLoadTime < 0 || evictionCount < 0) {
        throw new Error("All statistics values must be non-negative");
      }
    }
    static of(hitCount = 0, missCount = 0, loadSuccessCount = 0, loadFailureCount = 0, totalLoadTime = 0, evictionCount = 0) {
      return new CacheStats(hitCount, missCount, loadSuccessCount, loadFailureCount, totalLoadTime, evictionCount);
    }
    static empty() {
      return CacheStats.EMPTY_STATS;
    }
    static EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);
    requestCount() {
      return this.hitCount + this.missCount;
    }
    hitRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 1 : this.hitCount / requestCount;
    }
    missRate() {
      const requestCount = this.requestCount();
      return requestCount === 0 ? 0 : this.missCount / requestCount;
    }
    loadCount() {
      return this.loadSuccessCount + this.loadFailureCount;
    }
    loadFailureRate() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.loadFailureCount / loadCount;
    }
    averageLoadPenalty() {
      const loadCount = this.loadCount();
      return loadCount === 0 ? 0 : this.totalLoadTime / loadCount;
    }
    minus(other) {
      return CacheStats.of(Math.max(0, this.hitCount - other.hitCount), Math.max(0, this.missCount - other.missCount), Math.max(0, this.loadSuccessCount - other.loadSuccessCount), Math.max(0, this.loadFailureCount - other.loadFailureCount), Math.max(0, this.totalLoadTime - other.totalLoadTime), Math.max(0, this.evictionCount - other.evictionCount));
    }
    plus(other) {
      return CacheStats.of(this.hitCount + other.hitCount, this.missCount + other.missCount, this.loadSuccessCount + other.loadSuccessCount, this.loadFailureCount + other.loadFailureCount, this.totalLoadTime + other.totalLoadTime, this.evictionCount + other.evictionCount);
    }
  }
  exports.CacheStats = CacheStats;

  class DisabledStatsCounter {
    static INSTANCE = new DisabledStatsCounter;
    constructor() {}
    recordHits(count) {}
    recordMisses(count) {}
    recordLoadSuccess(loadTime) {}
    recordLoadFailure(loadTime) {}
    recordEvictions(count) {}
    snapshot() {
      return CacheStats.empty();
    }
  }
  function disabledStatsCounter() {
    return DisabledStatsCounter.INSTANCE;
  }

  class DefaultStatsCounter {
    #hitCount = 0;
    #missCount = 0;
    #loadSuccessCount = 0;
    #loadFailureCount = 0;
    #totalLoadTime = 0;
    #evictionCount = 0;
    recordHits(count) {
      this.#hitCount += count;
    }
    recordMisses(count) {
      this.#missCount += count;
    }
    recordLoadSuccess(loadTime) {
      this.#loadSuccessCount++;
      this.#totalLoadTime += loadTime;
    }
    recordLoadFailure(loadTime) {
      this.#loadFailureCount++;
      this.#totalLoadTime += loadTime;
    }
    recordEvictions(count) {
      this.#evictionCount += count;
    }
    snapshot() {
      return CacheStats.of(this.#hitCount, this.#missCount, this.#loadSuccessCount, this.#loadFailureCount, this.#totalLoadTime, this.#evictionCount);
    }
    static create() {
      return new DefaultStatsCounter;
    }
  }
  function generateCacheKey(redisArgs) {
    const tmp = new Array(redisArgs.length * 2);
    for (let i = 0;i < redisArgs.length; i++) {
      tmp[i] = redisArgs[i].length;
      tmp[i + redisArgs.length] = redisArgs[i];
    }
    return tmp.join("_");
  }

  class ClientSideCacheEntryBase {
    #invalidated = false;
    #expireTime;
    constructor(ttl) {
      if (ttl == 0) {
        this.#expireTime = 0;
      } else {
        this.#expireTime = Date.now() + ttl;
      }
    }
    invalidate() {
      this.#invalidated = true;
    }
    validate() {
      return !this.#invalidated && (this.#expireTime == 0 || Date.now() < this.#expireTime);
    }
  }

  class ClientSideCacheEntryValue extends ClientSideCacheEntryBase {
    #value;
    get value() {
      return this.#value;
    }
    constructor(ttl, value) {
      super(ttl);
      this.#value = value;
    }
  }

  class ClientSideCacheEntryPromise extends ClientSideCacheEntryBase {
    #sendCommandPromise;
    get promise() {
      return this.#sendCommandPromise;
    }
    constructor(ttl, sendCommandPromise) {
      super(ttl);
      this.#sendCommandPromise = sendCommandPromise;
    }
  }

  class ClientSideCacheProvider extends stream_1.EventEmitter {
  }
  exports.ClientSideCacheProvider = ClientSideCacheProvider;

  class BasicClientSideCache extends ClientSideCacheProvider {
    #cacheKeyToEntryMap;
    #keyToCacheKeySetMap;
    ttl;
    maxEntries;
    lru;
    #statsCounter;
    recordEvictions(count) {
      this.#statsCounter.recordEvictions(count);
    }
    recordHits(count) {
      this.#statsCounter.recordHits(count);
    }
    recordMisses(count) {
      this.#statsCounter.recordMisses(count);
    }
    constructor(config2) {
      super();
      this.#cacheKeyToEntryMap = new Map;
      this.#keyToCacheKeySetMap = new Map;
      this.ttl = config2?.ttl ?? 0;
      this.maxEntries = config2?.maxEntries ?? 0;
      this.lru = config2?.evictPolicy !== "FIFO";
      const recordStats = config2?.recordStats !== false;
      this.#statsCounter = recordStats ? DefaultStatsCounter.create() : disabledStatsCounter();
    }
    async handleCache(client, parser, fn, transformReply, typeMapping) {
      let reply;
      const cacheKey = generateCacheKey(parser.redisArgs);
      let cacheEntry = this.get(cacheKey);
      if (cacheEntry) {
        if (cacheEntry instanceof ClientSideCacheEntryValue) {
          this.#statsCounter.recordHits(1);
          return structuredClone(cacheEntry.value);
        } else if (cacheEntry instanceof ClientSideCacheEntryPromise) {
          this.#statsCounter.recordMisses(1);
          reply = await cacheEntry.promise;
        } else {
          throw new Error("unknown cache entry type");
        }
      } else {
        this.#statsCounter.recordMisses(1);
        const startTime = performance.now();
        const promise2 = fn();
        cacheEntry = this.createPromiseEntry(client, promise2);
        this.set(cacheKey, cacheEntry, parser.keys);
        try {
          reply = await promise2;
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadSuccess(loadTime);
        } catch (err) {
          const loadTime = performance.now() - startTime;
          this.#statsCounter.recordLoadFailure(loadTime);
          if (cacheEntry.validate()) {
            this.delete(cacheKey);
          }
          throw err;
        }
      }
      let val;
      if (transformReply) {
        val = transformReply(reply, parser.preserve, typeMapping);
      } else {
        val = reply;
      }
      if (cacheEntry.validate()) {
        cacheEntry = this.createValueEntry(client, val);
        this.set(cacheKey, cacheEntry, parser.keys);
        this.emit("cached-key", cacheKey);
      } else {}
      return structuredClone(val);
    }
    trackingOn() {
      return ["CLIENT", "TRACKING", "ON"];
    }
    invalidate(key) {
      if (key === null) {
        this.clear(false);
        this.emit("invalidate", key);
        return;
      }
      const keySet = this.#keyToCacheKeySetMap.get(key.toString());
      if (keySet) {
        for (const cacheKey of keySet) {
          const entry = this.#cacheKeyToEntryMap.get(cacheKey);
          if (entry) {
            entry.invalidate();
          }
          this.#cacheKeyToEntryMap.delete(cacheKey);
        }
        this.#keyToCacheKeySetMap.delete(key.toString());
      }
      this.emit("invalidate", key);
    }
    clear(resetStats = true) {
      const oldSize = this.#cacheKeyToEntryMap.size;
      this.#cacheKeyToEntryMap.clear();
      this.#keyToCacheKeySetMap.clear();
      if (resetStats) {
        if (!(this.#statsCounter instanceof DisabledStatsCounter)) {
          this.#statsCounter = DefaultStatsCounter.create();
        }
      } else {
        if (oldSize > 0) {
          this.#statsCounter.recordEvictions(oldSize);
        }
      }
    }
    get(cacheKey) {
      const val = this.#cacheKeyToEntryMap.get(cacheKey);
      if (val && !val.validate()) {
        this.delete(cacheKey);
        this.#statsCounter.recordEvictions(1);
        this.emit("cache-evict", cacheKey);
        return;
      }
      if (val !== undefined && this.lru) {
        this.#cacheKeyToEntryMap.delete(cacheKey);
        this.#cacheKeyToEntryMap.set(cacheKey, val);
      }
      return val;
    }
    delete(cacheKey) {
      const entry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (entry) {
        entry.invalidate();
        this.#cacheKeyToEntryMap.delete(cacheKey);
      }
    }
    has(cacheKey) {
      return this.#cacheKeyToEntryMap.has(cacheKey);
    }
    set(cacheKey, cacheEntry, keys) {
      let count = this.#cacheKeyToEntryMap.size;
      const oldEntry = this.#cacheKeyToEntryMap.get(cacheKey);
      if (oldEntry) {
        count--;
        oldEntry.invalidate();
      }
      if (this.maxEntries > 0 && count >= this.maxEntries) {
        this.deleteOldest();
        this.#statsCounter.recordEvictions(1);
      }
      this.#cacheKeyToEntryMap.set(cacheKey, cacheEntry);
      for (const key of keys) {
        if (!this.#keyToCacheKeySetMap.has(key.toString())) {
          this.#keyToCacheKeySetMap.set(key.toString(), new Set);
        }
        const cacheKeySet = this.#keyToCacheKeySetMap.get(key.toString());
        cacheKeySet.add(cacheKey);
      }
    }
    size() {
      return this.#cacheKeyToEntryMap.size;
    }
    createValueEntry(client, value) {
      return new ClientSideCacheEntryValue(this.ttl, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      return new ClientSideCacheEntryPromise(this.ttl, sendCommandPromise);
    }
    stats() {
      return this.#statsCounter.snapshot();
    }
    onError() {
      this.clear();
    }
    onClose() {
      this.clear();
    }
    deleteOldest() {
      const it = this.#cacheKeyToEntryMap[Symbol.iterator]();
      const n = it.next();
      if (!n.done) {
        const key = n.value[0];
        const entry = this.#cacheKeyToEntryMap.get(key);
        if (entry) {
          entry.invalidate();
        }
        this.#cacheKeyToEntryMap.delete(key);
      }
    }
    entryEntries() {
      return this.#cacheKeyToEntryMap.entries();
    }
    keySetEntries() {
      return this.#keyToCacheKeySetMap.entries();
    }
  }
  exports.BasicClientSideCache = BasicClientSideCache;

  class PooledClientSideCacheProvider extends BasicClientSideCache {
    #disabled = false;
    disable() {
      this.#disabled = true;
    }
    enable() {
      this.#disabled = false;
    }
    get(cacheKey) {
      if (this.#disabled) {
        return;
      }
      return super.get(cacheKey);
    }
    has(cacheKey) {
      if (this.#disabled) {
        return false;
      }
      return super.has(cacheKey);
    }
    onPoolClose() {
      this.clear();
    }
  }
  exports.PooledClientSideCacheProvider = PooledClientSideCacheProvider;

  class BasicPooledClientSideCache extends PooledClientSideCacheProvider {
    onError() {
      this.clear(false);
    }
    onClose() {
      this.clear(false);
    }
  }
  exports.BasicPooledClientSideCache = BasicPooledClientSideCache;

  class PooledClientSideCacheEntryValue extends ClientSideCacheEntryValue {
    #creator;
    constructor(ttl, creator, value) {
      super(ttl, value);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      if (this.#creator) {
        ret = ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
      }
      return ret;
    }
  }

  class PooledClientSideCacheEntryPromise extends ClientSideCacheEntryPromise {
    #creator;
    constructor(ttl, creator, sendCommandPromise) {
      super(ttl, sendCommandPromise);
      this.#creator = creator;
    }
    validate() {
      let ret = super.validate();
      return ret && this.#creator.client.isReady && this.#creator.client.socketEpoch == this.#creator.epoch;
    }
  }

  class PooledNoRedirectClientSideCache extends BasicPooledClientSideCache {
    createValueEntry(client, value) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryValue(this.ttl, creator, value);
    }
    createPromiseEntry(client, sendCommandPromise) {
      const creator = {
        epoch: client.socketEpoch,
        client
      };
      return new PooledClientSideCacheEntryPromise(this.ttl, creator, sendCommandPromise);
    }
    onError() {}
    onClose() {}
  }
  exports.PooledNoRedirectClientSideCache = PooledNoRedirectClientSideCache;
});

// node_modules/@redis/client/dist/lib/single-entry-cache.js
var require_single_entry_cache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class SingleEntryCache {
    #cached;
    #serializedKey;
    get(keyObj) {
      return JSON.stringify(keyObj, makeCircularReplacer()) === this.#serializedKey ? this.#cached : undefined;
    }
    set(keyObj, obj) {
      this.#cached = obj;
      this.#serializedKey = JSON.stringify(keyObj, makeCircularReplacer());
    }
  }
  exports.default = SingleEntryCache;
  function makeCircularReplacer() {
    const seen = new WeakSet;
    return function serialize(_, value) {
      if (value && typeof value === "object") {
        if (seen.has(value)) {
          return "circular";
        }
        seen.add(value);
        return value;
      }
      return value;
    };
  }
});

// node_modules/@redis/client/dist/lib/client/pool.js
var require_pool = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisClientPool = undefined;
  var commands_1 = __importDefault(require_commands());
  var _1 = __importDefault(require_client());
  var node_events_1 = __require("events");
  var linked_list_1 = require_linked_list();
  var errors_1 = require_errors2();
  var commander_1 = require_commander();
  var multi_command_1 = __importDefault(require_multi_command2());
  var cache_1 = require_cache();
  var parser_1 = require_parser();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisClientPool extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this.execute((client) => client._executeCommand(command, parser, this._commandOptions, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(command, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self.execute((client) => client._executeCommand(fn, parser, this._self._commandOptions, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.pushVariadic(prefix);
        script.parseCommand(parser, ...args);
        return this.execute((client) => client._executeScript(script, parser, this._commandOptions, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static create(clientOptions, options) {
      let Pool = RedisClientPool.#SingleEntryCache.get(clientOptions);
      if (!Pool) {
        Pool = (0, commander_1.attachConfig)({
          BaseClass: RedisClientPool,
          commands: commands_1.default,
          createCommand: RedisClientPool.#createCommand,
          createModuleCommand: RedisClientPool.#createModuleCommand,
          createFunctionCommand: RedisClientPool.#createFunctionCommand,
          createScriptCommand: RedisClientPool.#createScriptCommand,
          config: clientOptions
        });
        Pool.prototype.Multi = multi_command_1.default.extend(clientOptions);
        RedisClientPool.#SingleEntryCache.set(clientOptions, Pool);
      }
      return Object.create(new Pool(clientOptions, options));
    }
    static #DEFAULTS = {
      minimum: 1,
      maximum: 100,
      acquireTimeout: 3000,
      cleanupDelay: 3000
    };
    #clientFactory;
    #options;
    #idleClients = new linked_list_1.SinglyLinkedList;
    get idleClients() {
      return this._self.#idleClients.length;
    }
    #clientsInUse = new linked_list_1.DoublyLinkedList;
    get clientsInUse() {
      return this._self.#clientsInUse.length;
    }
    get totalClients() {
      return this._self.#idleClients.length + this._self.#clientsInUse.length;
    }
    #tasksQueue = new linked_list_1.SinglyLinkedList;
    get tasksQueueLength() {
      return this._self.#tasksQueue.length;
    }
    #isOpen = false;
    get isOpen() {
      return this._self.#isOpen;
    }
    #isClosing = false;
    get isClosing() {
      return this._self.#isClosing;
    }
    #clientSideCache;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    constructor(clientOptions, options) {
      super();
      this.#options = {
        ...RedisClientPool.#DEFAULTS,
        ...options
      };
      if (options?.clientSideCache) {
        if (clientOptions === undefined) {
          clientOptions = {};
        }
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = clientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = clientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#clientFactory = _1.default.factory(clientOptions).bind(undefined, clientOptions);
    }
    _self = this;
    _commandOptions;
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    #commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._self.#commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._self.#commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._self.#commandOptionsProxy("asap", true);
    }
    async connect() {
      if (this._self.#isOpen)
        return;
      this._self.#isOpen = true;
      const promises = [];
      while (promises.length < this._self.#options.minimum) {
        promises.push(this._self.#create());
      }
      try {
        await Promise.all(promises);
      } catch (err) {
        this.destroy();
        throw err;
      }
      return this;
    }
    async#create() {
      const node = this._self.#clientsInUse.push(this._self.#clientFactory().on("error", (err) => this.emit("error", err)));
      try {
        const client = node.value;
        await client.connect();
      } catch (err) {
        this._self.#clientsInUse.remove(node);
        throw err;
      }
      this._self.#returnClient(node);
    }
    execute(fn) {
      return new Promise((resolve, reject) => {
        const client = this._self.#idleClients.shift(), { tail } = this._self.#tasksQueue;
        if (!client) {
          let timeout;
          if (this._self.#options.acquireTimeout > 0) {
            timeout = setTimeout(() => {
              this._self.#tasksQueue.remove(task, tail);
              reject(new errors_1.TimeoutError("Timeout waiting for a client"));
            }, this._self.#options.acquireTimeout);
          }
          const task = this._self.#tasksQueue.push({
            timeout,
            resolve,
            reject,
            fn
          });
          if (this.totalClients < this._self.#options.maximum) {
            this._self.#create();
          }
          return;
        }
        const node = this._self.#clientsInUse.push(client);
        this._self.#executeTask(node, resolve, reject, fn);
      });
    }
    #executeTask(node, resolve, reject, fn) {
      const result = fn(node.value);
      if (result instanceof Promise) {
        result.then(resolve, reject);
        result.finally(() => this.#returnClient(node));
      } else {
        resolve(result);
        this.#returnClient(node);
      }
    }
    #returnClient(node) {
      const task = this.#tasksQueue.shift();
      if (task) {
        clearTimeout(task.timeout);
        this.#executeTask(node, task.resolve, task.reject, task.fn);
        return;
      }
      this.#clientsInUse.remove(node);
      this.#idleClients.push(node.value);
      this.#scheduleCleanup();
    }
    cleanupTimeout;
    #scheduleCleanup() {
      if (this.totalClients <= this.#options.minimum)
        return;
      clearTimeout(this.cleanupTimeout);
      this.cleanupTimeout = setTimeout(() => this.#cleanup(), this.#options.cleanupDelay);
    }
    #cleanup() {
      const toDestroy = Math.min(this.#idleClients.length, this.totalClients - this.#options.minimum);
      for (let i = 0;i < toDestroy; i++) {
        const client = this.#idleClients.shift();
        client.destroy();
      }
    }
    sendCommand(args, options) {
      return this.execute((client) => client.sendCommand(args, options));
    }
    MULTI() {
      return new this.Multi((commands, selectedDB) => this.execute((client) => client._executeMulti(commands, selectedDB)), (commands) => this.execute((client) => client._executePipeline(commands)), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async close() {
      if (this._self.#isClosing)
        return;
      if (!this._self.#isOpen)
        return;
      this._self.#isClosing = true;
      try {
        const promises = [];
        for (const client of this._self.#idleClients) {
          promises.push(client.close());
        }
        for (const client of this._self.#clientsInUse) {
          promises.push(client.close());
        }
        await Promise.all(promises);
        this.#clientSideCache?.onPoolClose();
        this._self.#idleClients.reset();
        this._self.#clientsInUse.reset();
      } catch (err) {} finally {
        this._self.#isClosing = false;
      }
    }
    destroy() {
      for (const client of this._self.#idleClients) {
        client.destroy();
      }
      this._self.#idleClients.reset();
      for (const client of this._self.#clientsInUse) {
        client.destroy();
      }
      this._self.#clientSideCache?.onPoolClose();
      this._self.#clientsInUse.reset();
      this._self.#isOpen = false;
    }
  }
  exports.RedisClientPool = RedisClientPool;
});

// node_modules/@redis/client/dist/package.json
var require_package3 = __commonJS((exports, module) => {
  module.exports = {
    name: "@redis/client",
    version: "5.5.6",
    license: "MIT",
    main: "./dist/index.js",
    types: "./dist/index.d.ts",
    files: [
      "dist/",
      "!dist/tsconfig.tsbuildinfo"
    ],
    scripts: {
      test: "nyc -r text-summary -r lcov mocha -r tsx './lib/**/*.spec.ts'",
      release: "release-it"
    },
    dependencies: {
      "cluster-key-slot": "1.1.2"
    },
    devDependencies: {
      "@redis/test-utils": "*",
      "@types/sinon": "^17.0.3",
      sinon: "^17.0.1"
    },
    engines: {
      node: ">= 18"
    },
    repository: {
      type: "git",
      url: "git://github.com/redis/node-redis.git"
    },
    bugs: {
      url: "https://github.com/redis/node-redis/issues"
    },
    homepage: "https://github.com/redis/node-redis/tree/master/packages/client",
    keywords: [
      "redis"
    ]
  };
});

// node_modules/@redis/client/dist/lib/client/index.js
var require_client = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var socket_1 = __importDefault(require_socket2());
  var authx_1 = require_authx();
  var commands_queue_1 = __importDefault(require_commands_queue());
  var node_events_1 = __require("events");
  var commander_1 = require_commander();
  var errors_1 = require_errors2();
  var node_url_1 = __require("url");
  var pub_sub_1 = require_pub_sub();
  var multi_command_1 = __importDefault(require_multi_command2());
  var HELLO_1 = __importDefault(require_HELLO());
  var legacy_mode_1 = require_legacy_mode();
  var pool_1 = require_pool();
  var generic_transformers_1 = require_generic_transformers();
  var cache_1 = require_cache();
  var parser_1 = require_parser();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());
  var package_json_1 = require_package3();

  class RedisClient extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._commandOptions, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._executeCommand(command, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._executeCommand(fn, parser, this._self._commandOptions, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._executeScript(script, parser, this._commandOptions, transformReply);
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config2) {
      let Client = _a.#SingleEntryCache.get(config2);
      if (!Client) {
        Client = (0, commander_1.attachConfig)({
          BaseClass: _a,
          commands: commands_1.default,
          createCommand: _a.#createCommand,
          createModuleCommand: _a.#createModuleCommand,
          createFunctionCommand: _a.#createFunctionCommand,
          createScriptCommand: _a.#createScriptCommand,
          config: config2
        });
        Client.prototype.Multi = multi_command_1.default.extend(config2);
        _a.#SingleEntryCache.set(config2, Client);
      }
      return (options) => {
        return Object.create(new Client(options));
      };
    }
    static create(options) {
      return _a.factory(options)(options);
    }
    static parseURL(url2) {
      const { hostname: hostname2, port, protocol, username, password, pathname } = new node_url_1.URL(url2), parsed = {
        socket: {
          host: hostname2
        }
      };
      if (protocol === "rediss:") {
        parsed.socket.tls = true;
      } else if (protocol !== "redis:") {
        throw new TypeError("Invalid protocol");
      }
      if (port) {
        parsed.socket.port = Number(port);
      }
      if (username) {
        parsed.username = decodeURIComponent(username);
      }
      if (password) {
        parsed.password = decodeURIComponent(password);
      }
      if (username || password) {
        parsed.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: username ? decodeURIComponent(username) : undefined,
            password: password ? decodeURIComponent(password) : undefined
          })
        };
      }
      if (pathname.length > 1) {
        const database = Number(pathname.substring(1));
        if (isNaN(database)) {
          throw new TypeError("Invalid pathname");
        }
        parsed.database = database;
      }
      return parsed;
    }
    #options;
    #socket;
    #queue;
    #selectedDB = 0;
    #monitorCallback;
    _self = this;
    _commandOptions;
    #dirtyWatch;
    #watchEpoch;
    #clientSideCache;
    #credentialsSubscription = null;
    get clientSideCache() {
      return this._self.#clientSideCache;
    }
    get options() {
      return this._self.#options;
    }
    get isOpen() {
      return this._self.#socket.isOpen;
    }
    get isReady() {
      return this._self.#socket.isReady;
    }
    get isPubSubActive() {
      return this._self.#queue.isPubSubActive;
    }
    get socketEpoch() {
      return this._self.#socket.socketEpoch;
    }
    get isWatching() {
      return this._self.#watchEpoch !== undefined;
    }
    get isDirtyWatch() {
      return this._self.#dirtyWatch !== undefined;
    }
    setDirtyWatch(msg) {
      this._self.#dirtyWatch = msg;
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#options = this.#initiateOptions(options);
      this.#queue = this.#initiateQueue();
      this.#socket = this.#initiateSocket();
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.ClientSideCacheProvider) {
          this.#clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = new cache_1.BasicClientSideCache(cscConfig);
        }
        this.#queue.setInvalidateCallback(this.#clientSideCache.invalidate.bind(this.#clientSideCache));
      }
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    #initiateOptions(options) {
      if (!options?.credentialsProvider && (options?.username || options?.password)) {
        options.credentialsProvider = {
          type: "async-credentials-provider",
          credentials: async () => ({
            username: options.username,
            password: options.password
          })
        };
      }
      if (options?.url) {
        const parsed = _a.parseURL(options.url);
        if (options.socket) {
          parsed.socket = Object.assign(options.socket, parsed.socket);
        }
        Object.assign(options, parsed);
      }
      if (options?.database) {
        this._self.#selectedDB = options.database;
      }
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
      return options;
    }
    #initiateQueue() {
      return new commands_queue_1.default(this.#options?.RESP ?? 2, this.#options?.commandsQueueMaxLength, (channel, listeners) => this.emit("sharded-channel-moved", channel, listeners));
    }
    reAuthenticate = async (credentials) => {
      if (!(this.isPubSubActive && !this.#options?.RESP)) {
        await this.sendCommand((0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
          username: credentials.username,
          password: credentials.password ?? ""
        }));
      }
    };
    #subscribeForStreamingCredentials(cp) {
      return cp.subscribe({
        onNext: (credentials) => {
          this.reAuthenticate(credentials).catch((error40) => {
            const errorMessage = error40 instanceof Error ? error40.message : String(error40);
            cp.onReAuthenticationError(new authx_1.CredentialsError(errorMessage));
          });
        },
        onError: (e) => {
          const errorMessage = `Error from streaming credentials provider: ${e.message}`;
          cp.onReAuthenticationError(new authx_1.UnableToObtainNewCredentialsError(errorMessage));
        }
      });
    }
    async#handshake(chainId, asap) {
      const promises = [];
      const commandsWithErrorHandlers = await this.#getHandshakeCommands();
      if (asap)
        commandsWithErrorHandlers.reverse();
      for (const { cmd, errorHandler: errorHandler2 } of commandsWithErrorHandlers) {
        promises.push(this.#queue.addCommand(cmd, {
          chainId,
          asap
        }).catch(errorHandler2));
      }
      return promises;
    }
    async#getHandshakeCommands() {
      const commands = [];
      const cp = this.#options?.credentialsProvider;
      if (this.#options?.RESP) {
        const hello = {};
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.password) {
            hello.AUTH = {
              username: credentials.username ?? "default",
              password: credentials.password
            };
          }
        }
        if (this.#options.name) {
          hello.SETNAME = this.#options.name;
        }
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(HELLO_1.default, this.#options.RESP, hello) });
      } else {
        if (cp && cp.type === "async-credentials-provider") {
          const credentials = await cp.credentials();
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (cp && cp.type === "streaming-credentials-provider") {
          const [credentials, disposable] = await this.#subscribeForStreamingCredentials(cp);
          this.#credentialsSubscription = disposable;
          if (credentials.username || credentials.password) {
            commands.push({
              cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.AUTH, {
                username: credentials.username,
                password: credentials.password ?? ""
              })
            });
          }
        }
        if (this.#options?.name) {
          commands.push({
            cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.CLIENT_SETNAME, this.#options.name)
          });
        }
      }
      if (this.#selectedDB !== 0) {
        commands.push({ cmd: ["SELECT", this.#selectedDB.toString()] });
      }
      if (this.#options?.readonly) {
        commands.push({ cmd: (0, generic_transformers_1.parseArgs)(commands_1.default.READONLY) });
      }
      if (!this.#options?.disableClientInfo) {
        commands.push({
          cmd: ["CLIENT", "SETINFO", "LIB-VER", package_json_1.version],
          errorHandler: () => {}
        });
        commands.push({
          cmd: [
            "CLIENT",
            "SETINFO",
            "LIB-NAME",
            this.#options?.clientInfoTag ? `node-redis(${this.#options.clientInfoTag})` : "node-redis"
          ],
          errorHandler: () => {}
        });
      }
      if (this.#clientSideCache) {
        commands.push({ cmd: this.#clientSideCache.trackingOn() });
      }
      return commands;
    }
    #initiateSocket() {
      const socketInitiator = async () => {
        const promises = [], chainId = Symbol("Socket Initiator");
        const resubscribePromise = this.#queue.resubscribe(chainId);
        if (resubscribePromise) {
          promises.push(resubscribePromise);
        }
        if (this.#monitorCallback) {
          promises.push(this.#queue.monitor(this.#monitorCallback, {
            typeMapping: this._commandOptions?.typeMapping,
            chainId,
            asap: true
          }));
        }
        promises.push(...await this.#handshake(chainId, true));
        if (promises.length) {
          this.#write();
          return Promise.all(promises);
        }
      };
      return new socket_1.default(socketInitiator, this.#options?.socket).on("data", (chunk) => {
        try {
          this.#queue.decoder.write(chunk);
        } catch (err) {
          this.#queue.resetDecoder();
          this.emit("error", err);
        }
      }).on("error", (err) => {
        this.emit("error", err);
        this.#clientSideCache?.onError();
        if (this.#socket.isOpen && !this.#options?.disableOfflineQueue) {
          this.#queue.flushWaitingForReply(err);
        } else {
          this.#queue.flushAll(err);
        }
      }).on("connect", () => this.emit("connect")).on("ready", () => {
        this.emit("ready");
        this.#setPingTimer();
        this.#maybeScheduleWrite();
      }).on("reconnecting", () => this.emit("reconnecting")).on("drain", () => this.#maybeScheduleWrite()).on("end", () => this.emit("end"));
    }
    #pingTimer;
    #setPingTimer() {
      if (!this.#options?.pingInterval || !this.#socket.isReady)
        return;
      clearTimeout(this.#pingTimer);
      this.#pingTimer = setTimeout(() => {
        if (!this.#socket.isReady)
          return;
        this.sendCommand(["PING"]).then((reply) => this.emit("ping-interval", reply)).catch((err) => this.emit("error", err)).finally(() => this.#setPingTimer());
      }, this.#options.pingInterval);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this._self);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    withAbortSignal(abortSignal) {
      return this._commandOptionsProxy("abortSignal", abortSignal);
    }
    asap() {
      return this._commandOptionsProxy("asap", true);
    }
    legacy() {
      return new legacy_mode_1.RedisLegacyClient(this);
    }
    createPool(options) {
      return pool_1.RedisClientPool.create(this._self.#options, options);
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self.#options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self.#socket.connect();
      return this;
    }
    async _executeCommand(command, parser, commandOptions, transformReply) {
      const csc = this._self.#clientSideCache;
      const defaultTypeMapping = this._self.#options?.commandOptions === commandOptions;
      const fn = () => {
        return this.sendCommand(parser.redisArgs, commandOptions);
      };
      if (csc && command.CACHEABLE && defaultTypeMapping) {
        return await csc.handleCache(this._self, parser, fn, transformReply, commandOptions?.typeMapping);
      } else {
        const reply = await fn();
        if (transformReply) {
          return transformReply(reply, parser.preserve, commandOptions?.typeMapping);
        }
        return reply;
      }
    }
    async _executeScript(script, parser, options, transformReply) {
      const args = parser.redisArgs;
      let reply;
      try {
        reply = await this.sendCommand(args, options);
      } catch (err) {
        if (!err?.message?.startsWith?.("NOSCRIPT"))
          throw err;
        args[0] = "EVAL";
        args[1] = script.SCRIPT;
        reply = await this.sendCommand(args, options);
      }
      return transformReply ? transformReply(reply, parser.preserve, options?.typeMapping) : reply;
    }
    sendCommand(args, options) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      } else if (!this._self.#socket.isReady && this._self.#options?.disableOfflineQueue) {
        return Promise.reject(new errors_1.ClientOfflineError);
      }
      const opts = {
        ...this._self._commandOptions,
        ...options
      };
      const promise2 = this._self.#queue.addCommand(args, opts);
      this._self.#scheduleWrite();
      return promise2;
    }
    async SELECT(db) {
      await this.sendCommand(["SELECT", db.toString()]);
      this._self.#selectedDB = db;
    }
    select = this.SELECT;
    #pubSubCommand(promise2) {
      if (promise2 === undefined)
        return Promise.resolve();
      this.#scheduleWrite();
      return promise2;
    }
    SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    subscribe = this.SUBSCRIBE;
    UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.CHANNELS, channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pSubscribe = this.PSUBSCRIBE;
    PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.PATTERNS, patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    SSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.subscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#pubSubCommand(this._self.#queue.unsubscribe(pub_sub_1.PUBSUB_TYPE.SHARDED, channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    async WATCH(key) {
      const reply = await this._self.sendCommand((0, generic_transformers_1.pushVariadicArguments)(["WATCH"], key));
      this._self.#watchEpoch ??= this._self.socketEpoch;
      return reply;
    }
    watch = this.WATCH;
    async UNWATCH() {
      const reply = await this._self.sendCommand(["UNWATCH"]);
      this._self.#watchEpoch = undefined;
      return reply;
    }
    unwatch = this.UNWATCH;
    getPubSubListeners(type) {
      return this._self.#queue.getPubSubListeners(type);
    }
    extendPubSubChannelListeners(type, channel, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubChannelListeners(type, channel, listeners));
    }
    extendPubSubListeners(type, listeners) {
      return this._self.#pubSubCommand(this._self.#queue.extendPubSubListeners(type, listeners));
    }
    #write() {
      this.#socket.write(this.#queue.commandsToWrite());
    }
    #scheduledWrite;
    #scheduleWrite() {
      if (!this.#socket.isReady || this.#scheduledWrite)
        return;
      this.#scheduledWrite = setImmediate(() => {
        this.#write();
        this.#scheduledWrite = undefined;
      });
    }
    #maybeScheduleWrite() {
      if (!this.#queue.isWaitingToWrite())
        return;
      this.#scheduleWrite();
    }
    async _executePipeline(commands, selectedDB) {
      if (!this._self.#socket.isOpen) {
        return Promise.reject(new errors_1.ClientClosedError);
      }
      const chainId = Symbol("Pipeline Chain"), promise2 = Promise.all(commands.map(({ args }) => this._self.#queue.addCommand(args, {
        chainId,
        typeMapping: this._commandOptions?.typeMapping
      })));
      this._self.#scheduleWrite();
      const result = await promise2;
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return result;
    }
    async _executeMulti(commands, selectedDB) {
      const dirtyWatch = this._self.#dirtyWatch;
      this._self.#dirtyWatch = undefined;
      const watchEpoch = this._self.#watchEpoch;
      this._self.#watchEpoch = undefined;
      if (!this._self.#socket.isOpen) {
        throw new errors_1.ClientClosedError;
      }
      if (dirtyWatch) {
        throw new errors_1.WatchError(dirtyWatch);
      }
      if (watchEpoch && watchEpoch !== this._self.socketEpoch) {
        throw new errors_1.WatchError("Client reconnected after WATCH");
      }
      const typeMapping = this._commandOptions?.typeMapping;
      const chainId = Symbol("MULTI Chain");
      const promises = [
        this._self.#queue.addCommand(["MULTI"], { chainId })
      ];
      for (const { args } of commands) {
        promises.push(this._self.#queue.addCommand(args, {
          chainId,
          typeMapping
        }));
      }
      promises.push(this._self.#queue.addCommand(["EXEC"], { chainId }));
      this._self.#scheduleWrite();
      const results = await Promise.all(promises), execResult = results[results.length - 1];
      if (execResult === null) {
        throw new errors_1.WatchError;
      }
      if (selectedDB !== undefined) {
        this._self.#selectedDB = selectedDB;
      }
      return execResult;
    }
    MULTI() {
      return new this.Multi(this._executeMulti.bind(this), this._executePipeline.bind(this), this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async* scanIterator(options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.scan(cursor, options);
        cursor = reply.cursor;
        yield reply.keys;
      } while (cursor !== "0");
    }
    async* hScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.entries;
      } while (cursor !== "0");
    }
    async* hScanValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* hScanNoValuesIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.hScanNoValues(key, cursor, options);
        cursor = reply.cursor;
        yield reply.fields;
      } while (cursor !== "0");
    }
    async* sScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.sScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async* zScanIterator(key, options) {
      let cursor = options?.cursor ?? "0";
      do {
        const reply = await this.zScan(key, cursor, options);
        cursor = reply.cursor;
        yield reply.members;
      } while (cursor !== "0");
    }
    async MONITOR(callback) {
      const promise2 = this._self.#queue.monitor(callback, {
        typeMapping: this._commandOptions?.typeMapping
      });
      this._self.#scheduleWrite();
      await promise2;
      this._self.#monitorCallback = callback;
    }
    monitor = this.MONITOR;
    async reset() {
      const chainId = Symbol("Reset Chain"), promises = [this._self.#queue.reset(chainId)], selectedDB = this._self.#options?.database ?? 0;
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      promises.push(...await this._self.#handshake(chainId, false));
      this._self.#scheduleWrite();
      await Promise.all(promises);
      this._self.#selectedDB = selectedDB;
      this._self.#monitorCallback = undefined;
      this._self.#dirtyWatch = undefined;
      this._self.#watchEpoch = undefined;
    }
    resetIfDirty() {
      let shouldReset = false;
      if (this._self.#selectedDB !== (this._self.#options?.database ?? 0)) {
        console.warn("Returning a client with a different selected DB");
        shouldReset = true;
      }
      if (this._self.#monitorCallback) {
        console.warn("Returning a client with active MONITOR");
        shouldReset = true;
      }
      if (this._self.#queue.isPubSubActive) {
        console.warn("Returning a client with active PubSub");
        shouldReset = true;
      }
      if (this._self.#dirtyWatch || this._self.#watchEpoch) {
        console.warn("Returning a client with active WATCH");
        shouldReset = true;
      }
      if (shouldReset) {
        return this.reset();
      }
    }
    QUIT() {
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
      return this._self.#socket.quit(async () => {
        clearTimeout(this._self.#pingTimer);
        const quitPromise = this._self.#queue.addCommand(["QUIT"]);
        this._self.#scheduleWrite();
        return quitPromise;
      });
    }
    quit = this.QUIT;
    disconnect() {
      return Promise.resolve(this.destroy());
    }
    close() {
      return new Promise((resolve) => {
        clearTimeout(this._self.#pingTimer);
        this._self.#socket.close();
        this._self.#clientSideCache?.onClose();
        if (this._self.#queue.isEmpty()) {
          this._self.#socket.destroySocket();
          return resolve();
        }
        const maybeClose = () => {
          if (!this._self.#queue.isEmpty())
            return;
          this._self.#socket.off("data", maybeClose);
          this._self.#socket.destroySocket();
          resolve();
        };
        this._self.#socket.on("data", maybeClose);
        this._self.#credentialsSubscription?.dispose();
        this._self.#credentialsSubscription = null;
      });
    }
    destroy() {
      clearTimeout(this._self.#pingTimer);
      this._self.#queue.flushAll(new errors_1.DisconnectsClientError);
      this._self.#socket.destroy();
      this._self.#clientSideCache?.onClose();
      this._self.#credentialsSubscription?.dispose();
      this._self.#credentialsSubscription = null;
    }
    ref() {
      this._self.#socket.ref();
    }
    unref() {
      this._self.#socket.unref();
    }
  }
  _a = RedisClient;
  exports.default = RedisClient;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
    }
    return result & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate(keys[0]);
    while (i < len) {
      if (generate(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/@redis/client/dist/lib/cluster/cluster-slots.js
var require_cluster_slots = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors_1 = require_errors2();
  var client_1 = __importDefault(require_client());
  var pub_sub_1 = require_pub_sub();
  var cluster_key_slot_1 = __importDefault(require_lib());
  var cache_1 = require_cache();

  class RedisClusterSlots {
    static #SLOTS = 16384;
    #options;
    #clientFactory;
    #emit;
    slots = new Array(_a.#SLOTS);
    masters = new Array;
    replicas = new Array;
    nodeByAddress = new Map;
    pubSubNode;
    clientSideCache;
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options, emit) {
      this.#validateOptions(options);
      this.#options = options;
      if (options?.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.clientSideCache = options.clientSideCache;
        } else {
          this.clientSideCache = new cache_1.BasicPooledClientSideCache(options.clientSideCache);
        }
      }
      this.#clientFactory = client_1.default.factory(this.#options);
      this.#emit = emit;
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("Cluster already open");
      }
      this.#isOpen = true;
      try {
        await this.#discoverWithRootNodes();
      } catch (err) {
        this.#isOpen = false;
        throw err;
      }
    }
    async#discoverWithRootNodes() {
      let start = Math.floor(Math.random() * this.#options.rootNodes.length);
      for (let i = start;i < this.#options.rootNodes.length; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      for (let i = 0;i < start; i++) {
        if (!this.#isOpen)
          throw new Error("Cluster closed");
        if (await this.#discover(this.#options.rootNodes[i]))
          return;
      }
      throw new errors_1.RootNodesUnavailableError;
    }
    #resetSlots() {
      this.slots = new Array(_a.#SLOTS);
      this.masters = [];
      this.replicas = [];
      this._randomNodeIterator = undefined;
    }
    async#discover(rootNode) {
      this.clientSideCache?.clear();
      this.clientSideCache?.disable();
      try {
        const addressesInUse = new Set, promises = [], eagerConnect = this.#options.minimizeConnections !== true;
        const shards = await this.#getShards(rootNode);
        this.#resetSlots();
        for (const { from, to, master, replicas } of shards) {
          const shard = {
            master: this.#initiateSlotNode(master, false, eagerConnect, addressesInUse, promises)
          };
          if (this.#options.useReplicas) {
            shard.replicas = replicas.map((replica) => this.#initiateSlotNode(replica, true, eagerConnect, addressesInUse, promises));
          }
          for (let i = from;i <= to; i++) {
            this.slots[i] = shard;
          }
        }
        if (this.pubSubNode && !addressesInUse.has(this.pubSubNode.address)) {
          const channelsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS), patternsListeners = this.pubSubNode.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS);
          this.pubSubNode.client.destroy();
          if (channelsListeners.size || patternsListeners.size) {
            promises.push(this.#initiatePubSubClient({
              [pub_sub_1.PUBSUB_TYPE.CHANNELS]: channelsListeners,
              [pub_sub_1.PUBSUB_TYPE.PATTERNS]: patternsListeners
            }));
          }
        }
        for (const [address, node] of this.nodeByAddress.entries()) {
          if (addressesInUse.has(address))
            continue;
          if (node.client) {
            node.client.destroy();
          }
          const { pubSub } = node;
          if (pubSub) {
            pubSub.client.destroy();
          }
          this.nodeByAddress.delete(address);
        }
        await Promise.all(promises);
        this.clientSideCache?.enable();
        return true;
      } catch (err) {
        this.#emit("error", err);
        return false;
      }
    }
    async#getShards(rootNode) {
      const options = this.#clientOptionsDefaults(rootNode);
      options.socket ??= {};
      options.socket.reconnectStrategy = false;
      options.RESP = this.#options.RESP;
      options.commandOptions = undefined;
      const client = await this.#clientFactory(options).on("error", (err) => this.#emit("error", err)).connect();
      try {
        return await client.clusterSlots();
      } finally {
        client.destroy();
      }
    }
    #getNodeAddress(address) {
      switch (typeof this.#options.nodeAddressMap) {
        case "object":
          return this.#options.nodeAddressMap[address];
        case "function":
          return this.#options.nodeAddressMap(address);
      }
    }
    #clientOptionsDefaults(options) {
      if (!this.#options.defaults)
        return options;
      let socket;
      if (this.#options.defaults.socket) {
        socket = {
          ...this.#options.defaults.socket,
          ...options?.socket
        };
      } else {
        socket = options?.socket;
      }
      return {
        ...this.#options.defaults,
        ...options,
        socket
      };
    }
    #initiateSlotNode(shard, readonly2, eagerConnent, addressesInUse, promises) {
      const address = `${shard.host}:${shard.port}`;
      let node = this.nodeByAddress.get(address);
      if (!node) {
        node = {
          ...shard,
          address,
          readonly: readonly2,
          client: undefined,
          connectPromise: undefined
        };
        if (eagerConnent) {
          promises.push(this.#createNodeClient(node));
        }
        this.nodeByAddress.set(address, node);
      }
      if (!addressesInUse.has(address)) {
        addressesInUse.add(address);
        (readonly2 ? this.replicas : this.masters).push(node);
      }
      return node;
    }
    #createClient(node, readonly2 = node.readonly) {
      return this.#clientFactory(this.#clientOptionsDefaults({
        clientSideCache: this.clientSideCache,
        RESP: this.#options.RESP,
        socket: this.#getNodeAddress(node.address) ?? {
          host: node.host,
          port: node.port
        },
        readonly: readonly2
      })).on("error", (err) => console.error(err));
    }
    #createNodeClient(node, readonly2) {
      const client = node.client = this.#createClient(node, readonly2);
      return node.connectPromise = client.connect().finally(() => node.connectPromise = undefined);
    }
    nodeClient(node) {
      return node.connectPromise ?? node.client ?? this.#createNodeClient(node);
    }
    #runningRediscoverPromise;
    async rediscover(startWith) {
      this.#runningRediscoverPromise ??= this.#rediscover(startWith).finally(() => this.#runningRediscoverPromise = undefined);
      return this.#runningRediscoverPromise;
    }
    async#rediscover(startWith) {
      if (await this.#discover(startWith.options))
        return;
      return this.#discoverWithRootNodes();
    }
    quit() {
      return this.#destroy((client) => client.quit());
    }
    disconnect() {
      return this.#destroy((client) => client.disconnect());
    }
    close() {
      return this.#destroy((client) => client.close());
    }
    destroy() {
      this.#isOpen = false;
      for (const client of this.#clients()) {
        client.destroy();
      }
      if (this.pubSubNode) {
        this.pubSubNode.client.destroy();
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
    }
    *#clients() {
      for (const master of this.masters) {
        if (master.client) {
          yield master.client;
        }
        if (master.pubSub) {
          yield master.pubSub.client;
        }
      }
      for (const replica of this.replicas) {
        if (replica.client) {
          yield replica.client;
        }
      }
    }
    async#destroy(fn) {
      this.#isOpen = false;
      const promises = [];
      for (const client of this.#clients()) {
        promises.push(fn(client));
      }
      if (this.pubSubNode) {
        promises.push(fn(this.pubSubNode.client));
        this.pubSubNode = undefined;
      }
      this.#resetSlots();
      this.nodeByAddress.clear();
      await Promise.allSettled(promises);
    }
    getClient(firstKey, isReadonly) {
      if (!firstKey) {
        return this.nodeClient(this.getRandomNode());
      }
      const slotNumber = (0, cluster_key_slot_1.default)(firstKey);
      if (!isReadonly) {
        return this.nodeClient(this.slots[slotNumber].master);
      }
      return this.nodeClient(this.getSlotRandomNode(slotNumber));
    }
    *#iterateAllNodes() {
      let i = Math.floor(Math.random() * (this.masters.length + this.replicas.length));
      if (i < this.masters.length) {
        do {
          yield this.masters[i];
        } while (++i < this.masters.length);
        for (const replica of this.replicas) {
          yield replica;
        }
      } else {
        i -= this.masters.length;
        do {
          yield this.replicas[i];
        } while (++i < this.replicas.length);
      }
      while (true) {
        for (const master of this.masters) {
          yield master;
        }
        for (const replica of this.replicas) {
          yield replica;
        }
      }
    }
    _randomNodeIterator;
    getRandomNode() {
      this._randomNodeIterator ??= this.#iterateAllNodes();
      return this._randomNodeIterator.next().value;
    }
    *#slotNodesIterator(slot) {
      let i = Math.floor(Math.random() * (1 + slot.replicas.length));
      if (i < slot.replicas.length) {
        do {
          yield slot.replicas[i];
        } while (++i < slot.replicas.length);
      }
      while (true) {
        yield slot.master;
        for (const replica of slot.replicas) {
          yield replica;
        }
      }
    }
    getSlotRandomNode(slotNumber) {
      const slot = this.slots[slotNumber];
      if (!slot.replicas?.length) {
        return slot.master;
      }
      slot.nodesIterator ??= this.#slotNodesIterator(slot);
      return slot.nodesIterator.next().value;
    }
    getMasterByAddress(address) {
      const master = this.nodeByAddress.get(address);
      if (!master)
        return;
      return this.nodeClient(master);
    }
    getPubSubClient() {
      if (!this.pubSubNode)
        return this.#initiatePubSubClient();
      return this.pubSubNode.connectPromise ?? this.pubSubNode.client;
    }
    async#initiatePubSubClient(toResubscribe) {
      const index = Math.floor(Math.random() * (this.masters.length + this.replicas.length)), node = index < this.masters.length ? this.masters[index] : this.replicas[index - this.masters.length], client = this.#createClient(node, false);
      this.pubSubNode = {
        address: node.address,
        client,
        connectPromise: client.connect().then(async (client2) => {
          if (toResubscribe) {
            await Promise.all([
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, toResubscribe[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
              client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, toResubscribe[pub_sub_1.PUBSUB_TYPE.PATTERNS])
            ]);
          }
          this.pubSubNode.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          this.pubSubNode = undefined;
          throw err;
        })
      };
      return this.pubSubNode.connectPromise;
    }
    async executeUnsubscribeCommand(unsubscribe) {
      const client = await this.getPubSubClient();
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        this.pubSubNode = undefined;
      }
    }
    getShardedPubSubClient(channel) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return this.#initiateShardedPubSubClient(master);
      return master.pubSub.connectPromise ?? master.pubSub.client;
    }
    async#initiateShardedPubSubClient(master) {
      const client = this.#createClient(master, false).on("server-sunsubscribe", async (channel, listeners) => {
        try {
          await this.rediscover(client);
          const redirectTo = await this.getShardedPubSubClient(channel);
          await redirectTo.extendPubSubChannelListeners(pub_sub_1.PUBSUB_TYPE.SHARDED, channel, listeners);
        } catch (err) {
          this.#emit("sharded-shannel-moved-error", err, channel, listeners);
        }
      });
      master.pubSub = {
        client,
        connectPromise: client.connect().then((client2) => {
          master.pubSub.connectPromise = undefined;
          return client2;
        }).catch((err) => {
          master.pubSub = undefined;
          throw err;
        })
      };
      return master.pubSub.connectPromise;
    }
    async executeShardedUnsubscribeCommand(channel, unsubscribe) {
      const { master } = this.slots[(0, cluster_key_slot_1.default)(channel)];
      if (!master.pubSub)
        return;
      const client = master.pubSub.connectPromise ? await master.pubSub.connectPromise : master.pubSub.client;
      await unsubscribe(client);
      if (!client.isPubSubActive) {
        client.destroy();
        master.pubSub = undefined;
      }
    }
  }
  _a = RedisClusterSlots;
  exports.default = RedisClusterSlots;
});

// node_modules/@redis/client/dist/lib/cluster/multi-command.js
var require_multi_command3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisClusterMultiCommand {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this._self.addCommand(firstKey, fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static #createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        const firstKey = parser.firstKey;
        return this.#addScript(firstKey, script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config2) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisClusterMultiCommand,
        commands: commands_1.default,
        createCommand: RedisClusterMultiCommand.#createCommand,
        createModuleCommand: RedisClusterMultiCommand.#createModuleCommand,
        createFunctionCommand: RedisClusterMultiCommand.#createFunctionCommand,
        createScriptCommand: RedisClusterMultiCommand.#createScriptCommand,
        config: config2
      });
    }
    #multi;
    #executeMulti;
    #executePipeline;
    #firstKey;
    #isReadonly = true;
    constructor(executeMulti, executePipeline, routing, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#executeMulti = executeMulti;
      this.#executePipeline = executePipeline;
      this.#firstKey = routing;
    }
    #setState(firstKey, isReadonly) {
      this.#firstKey ??= firstKey;
      this.#isReadonly &&= isReadonly;
    }
    addCommand(firstKey, isReadonly, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(firstKey, isReadonly, script, args, transformReply) {
      this.#setState(firstKey, isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#executeMulti(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#executePipeline(this.#firstKey, this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisClusterMultiCommand;
});

// node_modules/@redis/client/dist/lib/cluster/index.js
var require_cluster2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var node_events_1 = __require("events");
  var commander_1 = require_commander();
  var cluster_slots_1 = __importDefault(require_cluster_slots());
  var multi_command_1 = __importDefault(require_multi_command3());
  var errors_1 = require_errors2();
  var parser_1 = require_parser();
  var ASKING_1 = require_ASKING();
  var single_entry_cache_1 = __importDefault(require_single_entry_cache());

  class RedisCluster extends node_events_1.EventEmitter {
    static #createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, command.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(command, parser, opts, transformReply));
      };
    }
    static #createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, fn.IS_READ_ONLY, this._self._commandOptions, (client, opts) => client._executeCommand(fn, parser, opts, transformReply));
      };
    }
    static #createScriptCommand(script, resp) {
      const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return async function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        script.parseCommand(parser, ...args);
        return this._self._execute(parser.firstKey, script.IS_READ_ONLY, this._commandOptions, (client, opts) => client._executeScript(script, parser, opts, transformReply));
      };
    }
    static #SingleEntryCache = new single_entry_cache_1.default;
    static factory(config2) {
      let Cluster = RedisCluster.#SingleEntryCache.get(config2);
      if (!Cluster) {
        Cluster = (0, commander_1.attachConfig)({
          BaseClass: RedisCluster,
          commands: commands_1.default,
          createCommand: RedisCluster.#createCommand,
          createModuleCommand: RedisCluster.#createModuleCommand,
          createFunctionCommand: RedisCluster.#createFunctionCommand,
          createScriptCommand: RedisCluster.#createScriptCommand,
          config: config2
        });
        Cluster.prototype.Multi = multi_command_1.default.extend(config2);
        RedisCluster.#SingleEntryCache.set(config2, Cluster);
      }
      return (options) => {
        return Object.create(new Cluster(options));
      };
    }
    static create(options) {
      return RedisCluster.factory(options)(options);
    }
    _options;
    _slots;
    _self = this;
    _commandOptions;
    get slots() {
      return this._self._slots.slots;
    }
    get clientSideCache() {
      return this._self._slots.clientSideCache;
    }
    get masters() {
      return this._self._slots.masters;
    }
    get replicas() {
      return this._self._slots.replicas;
    }
    get nodeByAddress() {
      return this._self._slots.nodeByAddress;
    }
    get pubSubNode() {
      return this._self._slots.pubSubNode;
    }
    get isOpen() {
      return this._self._slots.isOpen;
    }
    constructor(options) {
      super();
      this._options = options;
      this._slots = new cluster_slots_1.default(options, this.emit.bind(this));
      if (options?.commandOptions) {
        this._commandOptions = options.commandOptions;
      }
    }
    duplicate(overrides) {
      return new (Object.getPrototypeOf(this)).constructor({
        ...this._self._options,
        commandOptions: this._commandOptions,
        ...overrides
      });
    }
    async connect() {
      await this._self._slots.connect();
      return this;
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    _handleAsk(fn) {
      return async (client, options) => {
        const chainId = Symbol("asking chain");
        const opts = options ? { ...options } : {};
        opts.chainId = chainId;
        const ret = await Promise.all([
          client.sendCommand([ASKING_1.ASKING_CMD], { chainId }),
          fn(client, opts)
        ]);
        return ret[1];
      };
    }
    async _execute(firstKey, isReadonly, options, fn) {
      const maxCommandRedirections = this._options.maxCommandRedirections ?? 16;
      let client = await this._slots.getClient(firstKey, isReadonly);
      let i = 0;
      let myFn = fn;
      while (true) {
        try {
          return await myFn(client, options);
        } catch (err) {
          myFn = fn;
          if (++i > maxCommandRedirections || !(err instanceof Error)) {
            throw err;
          }
          if (err.message.startsWith("ASK")) {
            const address = err.message.substring(err.message.lastIndexOf(" ") + 1);
            let redirectTo = await this._slots.getMasterByAddress(address);
            if (!redirectTo) {
              await this._slots.rediscover(client);
              redirectTo = await this._slots.getMasterByAddress(address);
            }
            if (!redirectTo) {
              throw new Error(`Cannot find node ${address}`);
            }
            client = redirectTo;
            myFn = this._handleAsk(fn);
            continue;
          }
          if (err.message.startsWith("MOVED")) {
            await this._slots.rediscover(client);
            client = await this._slots.getClient(firstKey, isReadonly);
            continue;
          }
          throw err;
        }
      }
    }
    async sendCommand(firstKey, isReadonly, args, options) {
      const opts = {
        ...this._self._commandOptions,
        ...options
      };
      return this._self._execute(firstKey, isReadonly, opts, (client, opts2) => client.sendCommand(args, opts2));
    }
    MULTI(routing) {
      return new this.Multi(async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executeMulti(commands);
      }, async (firstKey, isReadonly, commands) => {
        const client = await this._self._slots.getClient(firstKey, isReadonly);
        return client._executePipeline(commands);
      }, routing, this._commandOptions?.typeMapping);
    }
    multi = this.MULTI;
    async SUBSCRIBE(channels, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).SUBSCRIBE(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return (await this._self._slots.getPubSubClient()).PSUBSCRIBE(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self._slots.executeUnsubscribeCommand((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async SSUBSCRIBE(channels, listener, bufferMode) {
      const maxCommandRedirections = this._self._options.maxCommandRedirections ?? 16, firstChannel = Array.isArray(channels) ? channels[0] : channels;
      let client = await this._self._slots.getShardedPubSubClient(firstChannel);
      for (let i = 0;; i++) {
        try {
          return await client.SSUBSCRIBE(channels, listener, bufferMode);
        } catch (err) {
          if (++i > maxCommandRedirections || !(err instanceof errors_1.ErrorReply)) {
            throw err;
          }
          if (err.message.startsWith("MOVED")) {
            await this._self._slots.rediscover(client);
            client = await this._self._slots.getShardedPubSubClient(firstChannel);
            continue;
          }
          throw err;
        }
      }
    }
    sSubscribe = this.SSUBSCRIBE;
    SUNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self._slots.executeShardedUnsubscribeCommand(Array.isArray(channels) ? channels[0] : channels, (client) => client.SUNSUBSCRIBE(channels, listener, bufferMode));
    }
    sUnsubscribe = this.SUNSUBSCRIBE;
    quit() {
      return this._self._slots.quit();
    }
    disconnect() {
      return this._self._slots.disconnect();
    }
    close() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.close();
    }
    destroy() {
      this._self._slots.clientSideCache?.onPoolClose();
      return this._self._slots.destroy();
    }
    nodeClient(node) {
      return this._self._slots.nodeClient(node);
    }
    getRandomNode() {
      return this._self._slots.getRandomNode();
    }
    getSlotRandomNode(slot) {
      return this._self._slots.getSlotRandomNode(slot);
    }
    getMasters() {
      return this.masters;
    }
    getSlotMaster(slot) {
      return this.slots[slot].master;
    }
  }
  exports.default = RedisCluster;
});

// node_modules/@redis/client/dist/lib/sentinel/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createScriptCommand = exports.createModuleCommand = exports.createFunctionCommand = exports.createCommand = exports.clientSocketToNode = exports.createNodeList = exports.parseNode = undefined;
  var parser_1 = require_parser();
  var commander_1 = require_commander();
  function parseNode(node) {
    if (node.flags.includes("s_down") || node.flags.includes("disconnected") || node.flags.includes("failover_in_progress")) {
      return;
    }
    return { host: node.ip, port: Number(node.port) };
  }
  exports.parseNode = parseNode;
  function createNodeList(nodes) {
    var nodeList = [];
    for (const nodeData of nodes) {
      const node = parseNode(nodeData);
      if (node === undefined) {
        continue;
      }
      nodeList.push(node);
    }
    return nodeList;
  }
  exports.createNodeList = createNodeList;
  function clientSocketToNode(socket) {
    const s = socket;
    return {
      host: s.host,
      port: s.port
    };
  }
  exports.clientSocketToNode = clientSocketToNode;
  function createCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this.commandOptions, transformReply));
    };
  }
  exports.createCommand = createCommand;
  function createFunctionCommand(name, fn, resp) {
    const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
    const transformReply = (0, commander_1.getTransformReply)(fn, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      fn.parseCommand(parser, ...args);
      return this._self._execute(fn.IS_READ_ONLY, (client) => client._executeCommand(fn, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createFunctionCommand = createFunctionCommand;
  function createModuleCommand(command, resp) {
    const transformReply = (0, commander_1.getTransformReply)(command, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      command.parseCommand(parser, ...args);
      return this._self._execute(command.IS_READ_ONLY, (client) => client._executeCommand(command, parser, this._self.commandOptions, transformReply));
    };
  }
  exports.createModuleCommand = createModuleCommand;
  function createScriptCommand(script, resp) {
    const prefix = (0, commander_1.scriptArgumentsPrefix)(script);
    const transformReply = (0, commander_1.getTransformReply)(script, resp);
    return async function(...args) {
      const parser = new parser_1.BasicCommandParser;
      parser.push(...prefix);
      script.parseCommand(parser, ...args);
      return this._self._execute(script.IS_READ_ONLY, (client) => client._executeScript(script, parser, this.commandOptions, transformReply));
    };
  }
  exports.createScriptCommand = createScriptCommand;
});

// node_modules/@redis/client/dist/lib/sentinel/multi-commands.js
var require_multi_commands = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands());
  var multi_command_1 = __importDefault(require_multi_command());
  var commander_1 = require_commander();
  var parser_1 = require_parser();

  class RedisSentinelMultiCommand {
    static _createCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createModuleCommand(command, resp) {
      const transformReply = (0, commander_1.getTransformReply)(command, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        command.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(command.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createFunctionCommand(name, fn, resp) {
      const prefix = (0, commander_1.functionArgumentsPrefix)(name, fn);
      const transformReply = (0, commander_1.getTransformReply)(fn, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        parser.push(...prefix);
        fn.parseCommand(parser, ...args);
        const redisArgs = parser.redisArgs;
        redisArgs.preserve = parser.preserve;
        return this._self.addCommand(fn.IS_READ_ONLY, redisArgs, transformReply);
      };
    }
    static _createScriptCommand(script, resp) {
      const transformReply = (0, commander_1.getTransformReply)(script, resp);
      return function(...args) {
        const parser = new parser_1.BasicCommandParser;
        script.parseCommand(parser, ...args);
        const scriptArgs = parser.redisArgs;
        scriptArgs.preserve = parser.preserve;
        return this.#addScript(script.IS_READ_ONLY, script, scriptArgs, transformReply);
      };
    }
    static extend(config2) {
      return (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelMultiCommand,
        commands: commands_1.default,
        createCommand: RedisSentinelMultiCommand._createCommand,
        createModuleCommand: RedisSentinelMultiCommand._createModuleCommand,
        createFunctionCommand: RedisSentinelMultiCommand._createFunctionCommand,
        createScriptCommand: RedisSentinelMultiCommand._createScriptCommand,
        config: config2
      });
    }
    #multi = new multi_command_1.default;
    #sentinel;
    #isReadonly = true;
    constructor(sentinel, typeMapping) {
      this.#multi = new multi_command_1.default(typeMapping);
      this.#sentinel = sentinel;
    }
    #setState(isReadonly) {
      this.#isReadonly &&= isReadonly;
    }
    addCommand(isReadonly, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addCommand(args, transformReply);
      return this;
    }
    #addScript(isReadonly, script, args, transformReply) {
      this.#setState(isReadonly);
      this.#multi.addScript(script, args, transformReply);
      return this;
    }
    async exec(execAsPipeline = false) {
      if (execAsPipeline)
        return this.execAsPipeline();
      return this.#multi.transformReplies(await this.#sentinel._executeMulti(this.#isReadonly, this.#multi.queue));
    }
    EXEC = this.exec;
    execTyped(execAsPipeline = false) {
      return this.exec(execAsPipeline);
    }
    async execAsPipeline() {
      if (this.#multi.queue.length === 0)
        return [];
      return this.#multi.transformReplies(await this.#sentinel._executePipeline(this.#isReadonly, this.#multi.queue));
    }
    execAsPipelineTyped() {
      return this.execAsPipeline();
    }
  }
  exports.default = RedisSentinelMultiCommand;
});

// node_modules/@redis/client/dist/lib/sentinel/pub-sub-proxy.js
var require_pub_sub_proxy = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PubSubProxy = undefined;
  var node_events_1 = __importDefault(__require("events"));
  var pub_sub_1 = require_pub_sub();
  var client_1 = __importDefault(require_client());

  class PubSubProxy extends node_events_1.default {
    #clientOptions;
    #onError;
    #node;
    #state;
    #subscriptions;
    constructor(clientOptions, onError) {
      super();
      this.#clientOptions = clientOptions;
      this.#onError = onError;
    }
    #createClient() {
      if (this.#node === undefined) {
        throw new Error("pubSubProxy: didn't define node to do pubsub against");
      }
      return new client_1.default({
        ...this.#clientOptions,
        socket: {
          ...this.#clientOptions.socket,
          host: this.#node.host,
          port: this.#node.port
        }
      });
    }
    async#initiatePubSubClient(withSubscriptions = false) {
      const client = this.#createClient().on("error", this.#onError);
      const connectPromise = client.connect().then(async (client2) => {
        if (this.#state?.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        if (withSubscriptions && this.#subscriptions) {
          await Promise.all([
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.CHANNELS]),
            client2.extendPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS, this.#subscriptions[pub_sub_1.PUBSUB_TYPE.PATTERNS])
          ]);
        }
        if (this.#state.client !== client2) {
          client2.destroy();
          return this.#state?.connectPromise;
        }
        this.#state.connectPromise = undefined;
        return client2;
      }).catch((err) => {
        this.#state = undefined;
        throw err;
      });
      this.#state = {
        client,
        connectPromise
      };
      return connectPromise;
    }
    #getPubSubClient() {
      if (!this.#state)
        return this.#initiatePubSubClient();
      return this.#state.connectPromise ?? this.#state.client;
    }
    async changeNode(node) {
      this.#node = node;
      if (!this.#state)
        return;
      if (this.#state.connectPromise === undefined) {
        this.#subscriptions = {
          [pub_sub_1.PUBSUB_TYPE.CHANNELS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.CHANNELS),
          [pub_sub_1.PUBSUB_TYPE.PATTERNS]: this.#state.client.getPubSubListeners(pub_sub_1.PUBSUB_TYPE.PATTERNS)
        };
        this.#state.client.destroy();
      }
      await this.#initiatePubSubClient(true);
    }
    #executeCommand(fn) {
      const client = this.#getPubSubClient();
      if (client instanceof client_1.default) {
        return fn(client);
      }
      return client.then((client2) => {
        if (client2 === undefined)
          return;
        return fn(client2);
      }).catch((err) => {
        if (this.#state?.client.isPubSubActive) {
          this.#state.client.destroy();
          this.#state = undefined;
        }
        throw err;
      });
    }
    subscribe(channels, listener, bufferMode) {
      return this.#executeCommand((client) => client.SUBSCRIBE(channels, listener, bufferMode));
    }
    #unsubscribe(fn) {
      return this.#executeCommand(async (client) => {
        const reply = await fn(client);
        if (!client.isPubSubActive) {
          client.destroy();
          this.#state = undefined;
        }
        return reply;
      });
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#unsubscribe((client) => client.UNSUBSCRIBE(channels, listener, bufferMode));
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#executeCommand((client) => client.PSUBSCRIBE(patterns, listener, bufferMode));
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#unsubscribe((client) => client.PUNSUBSCRIBE(patterns, listener, bufferMode));
    }
    destroy() {
      this.#subscriptions = undefined;
      if (this.#state === undefined)
        return;
      if (!this.#state.connectPromise) {
        this.#state.client.destroy();
      }
      this.#state = undefined;
    }
  }
  exports.PubSubProxy = PubSubProxy;
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MASTER.js
var require_SENTINEL_MASTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "MASTER", dbname);
    },
    transformReply: {
      2: generic_transformers_1.transformTuplesReply,
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_MONITOR.js
var require_SENTINEL_MONITOR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, host, port, quorum) {
      parser.push("SENTINEL", "MONITOR", dbname, host, port, quorum);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_REPLICAS.js
var require_SENTINEL_REPLICAS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "REPLICAS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SENTINELS.js
var require_SENTINEL_SENTINELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    parseCommand(parser, dbname) {
      parser.push("SENTINEL", "SENTINELS", dbname);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        const inferred = reply;
        const initial = [];
        return inferred.reduce((sentinels, x) => {
          sentinels.push((0, generic_transformers_1.transformTuplesReply)(x, undefined, typeMapping));
          return sentinels;
        }, initial);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/SENTINEL_SET.js
var require_SENTINEL_SET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    parseCommand(parser, dbname, options) {
      parser.push("SENTINEL", "SET", dbname);
      for (const option of options) {
        parser.push(option.option, option.value);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/client/dist/lib/sentinel/commands/index.js
var require_commands2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SENTINEL_MASTER_1 = __importDefault(require_SENTINEL_MASTER());
  var SENTINEL_MONITOR_1 = __importDefault(require_SENTINEL_MONITOR());
  var SENTINEL_REPLICAS_1 = __importDefault(require_SENTINEL_REPLICAS());
  var SENTINEL_SENTINELS_1 = __importDefault(require_SENTINEL_SENTINELS());
  var SENTINEL_SET_1 = __importDefault(require_SENTINEL_SET());
  exports.default = {
    SENTINEL_SENTINELS: SENTINEL_SENTINELS_1.default,
    sentinelSentinels: SENTINEL_SENTINELS_1.default,
    SENTINEL_MASTER: SENTINEL_MASTER_1.default,
    sentinelMaster: SENTINEL_MASTER_1.default,
    SENTINEL_REPLICAS: SENTINEL_REPLICAS_1.default,
    sentinelReplicas: SENTINEL_REPLICAS_1.default,
    SENTINEL_MONITOR: SENTINEL_MONITOR_1.default,
    sentinelMonitor: SENTINEL_MONITOR_1.default,
    SENTINEL_SET: SENTINEL_SET_1.default,
    sentinelSet: SENTINEL_SET_1.default
  };
});

// node_modules/@redis/client/dist/lib/sentinel/module.js
var require_module = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = __importDefault(require_commands2());
  exports.default = {
    sentinel: commands_1.default
  };
});

// node_modules/@redis/client/dist/lib/sentinel/wait-queue.js
var require_wait_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WaitQueue = undefined;
  var linked_list_1 = require_linked_list();

  class WaitQueue {
    #list = new linked_list_1.SinglyLinkedList;
    #queue = new linked_list_1.SinglyLinkedList;
    push(value) {
      const resolve = this.#queue.shift();
      if (resolve !== undefined) {
        resolve(value);
        return;
      }
      this.#list.push(value);
    }
    shift() {
      return this.#list.shift();
    }
    wait() {
      return new Promise((resolve) => this.#queue.push(resolve));
    }
  }
  exports.WaitQueue = WaitQueue;
});

// node_modules/@redis/client/dist/lib/sentinel/index.js
var require_sentinel = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RedisSentinelFactory = exports.RedisSentinelClient = undefined;
  var node_events_1 = __require("events");
  var client_1 = __importDefault(require_client());
  var commander_1 = require_commander();
  var commands_1 = __importDefault(require_commands());
  var utils_1 = require_utils();
  var multi_commands_1 = __importDefault(require_multi_commands());
  var pub_sub_proxy_1 = require_pub_sub_proxy();
  var promises_1 = __require("timers/promises");
  var module_1 = __importDefault(require_module());
  var wait_queue_1 = require_wait_queue();
  var cache_1 = require_cache();

  class RedisSentinelClient {
    #clientInfo;
    #internal;
    _self;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    constructor(internal, clientInfo, commandOptions) {
      this._self = this;
      this.#internal = internal;
      this.#clientInfo = clientInfo;
      this.#commandOptions = commandOptions;
    }
    static factory(config2) {
      const SentinelClient = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinelClient,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config: config2
      });
      SentinelClient.prototype.Multi = multi_commands_1.default.extend(config2);
      return (internal, clientInfo, commandOptions) => {
        return Object.create(new SentinelClient(internal, clientInfo, commandOptions));
      };
    }
    static create(options, internal, clientInfo, commandOptions) {
      return RedisSentinelClient.factory(options)(internal, clientInfo, commandOptions);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._commandOptions = Object.create(this._self.#commandOptions ?? null);
      proxy._commandOptions[key] = value;
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async _execute(isReadonly, fn) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return await this._self.#internal.execute(fn, this._self.#clientInfo);
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    WATCH(key) {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.watch(key));
    }
    watch = this.WATCH;
    UNWATCH() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("Attempted execution on released RedisSentinelClient lease");
      }
      return this._execute(false, (client) => client.unwatch());
    }
    unwatch = this.UNWATCH;
    release() {
      if (this._self.#clientInfo === undefined) {
        throw new Error("RedisSentinelClient lease already released");
      }
      const result = this._self.#internal.releaseClientLease(this._self.#clientInfo);
      this._self.#clientInfo = undefined;
      return result;
    }
  }
  exports.RedisSentinelClient = RedisSentinelClient;

  class RedisSentinel extends node_events_1.EventEmitter {
    _self;
    #internal;
    #options;
    get isOpen() {
      return this._self.#internal.isOpen;
    }
    get isReady() {
      return this._self.#internal.isReady;
    }
    get commandOptions() {
      return this._self.#commandOptions;
    }
    #commandOptions;
    #trace = () => {};
    #reservedClientInfo;
    #masterClientCount = 0;
    #masterClientInfo;
    get clientSideCache() {
      return this._self.#internal.clientSideCache;
    }
    constructor(options) {
      super();
      this._self = this;
      this.#options = options;
      if (options.commandOptions) {
        this.#commandOptions = options.commandOptions;
      }
      this.#internal = new RedisSentinelInternal(options);
      this.#internal.on("error", (err) => this.emit("error", err));
      this.#internal.on("topology-change", (event) => {
        if (!this.emit("topology-change", event)) {
          this._self.#trace(`RedisSentinel: re-emit for topology-change for ${event.type} event returned false`);
        }
      });
    }
    static factory(config2) {
      const Sentinel = (0, commander_1.attachConfig)({
        BaseClass: RedisSentinel,
        commands: commands_1.default,
        createCommand: utils_1.createCommand,
        createModuleCommand: utils_1.createModuleCommand,
        createFunctionCommand: utils_1.createFunctionCommand,
        createScriptCommand: utils_1.createScriptCommand,
        config: config2
      });
      Sentinel.prototype.Multi = multi_commands_1.default.extend(config2);
      return (options) => {
        return Object.create(new Sentinel(options));
      };
    }
    static create(options) {
      return RedisSentinel.factory(options)(options);
    }
    withCommandOptions(options) {
      const proxy = Object.create(this);
      proxy._commandOptions = options;
      return proxy;
    }
    _commandOptionsProxy(key, value) {
      const proxy = Object.create(this);
      proxy._self.#commandOptions = {
        ...this._self.#commandOptions || {},
        [key]: value
      };
      return proxy;
    }
    withTypeMapping(typeMapping) {
      return this._commandOptionsProxy("typeMapping", typeMapping);
    }
    async connect() {
      await this._self.#internal.connect();
      if (this._self.#options.reserveClient) {
        this._self.#reservedClientInfo = await this._self.#internal.getClientLease();
      }
      return this;
    }
    async _execute(isReadonly, fn) {
      let clientInfo;
      if (!isReadonly || !this._self.#internal.useReplicas) {
        if (this._self.#reservedClientInfo) {
          clientInfo = this._self.#reservedClientInfo;
        } else {
          this._self.#masterClientInfo ??= await this._self.#internal.getClientLease();
          clientInfo = this._self.#masterClientInfo;
          this._self.#masterClientCount++;
        }
      }
      try {
        return await this._self.#internal.execute(fn, clientInfo);
      } finally {
        if (clientInfo !== undefined && clientInfo === this._self.#masterClientInfo && --this._self.#masterClientCount === 0) {
          const promise2 = this._self.#internal.releaseClientLease(clientInfo);
          this._self.#masterClientInfo = undefined;
          if (promise2)
            await promise2;
        }
      }
    }
    async use(fn) {
      const clientInfo = await this._self.#internal.getClientLease();
      try {
        return await fn(RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions));
      } finally {
        const promise2 = this._self.#internal.releaseClientLease(clientInfo);
        if (promise2)
          await promise2;
      }
    }
    async sendCommand(isReadonly, args, options) {
      return this._execute(isReadonly, (client) => client.sendCommand(args, options));
    }
    async _executePipeline(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executePipeline(commands));
    }
    async _executeMulti(isReadonly, commands) {
      return this._execute(isReadonly, (client) => client._executeMulti(commands));
    }
    MULTI() {
      return new this.Multi(this);
    }
    multi = this.MULTI;
    async close() {
      return this._self.#internal.close();
    }
    destroy() {
      return this._self.#internal.destroy();
    }
    async SUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.subscribe(channels, listener, bufferMode);
    }
    subscribe = this.SUBSCRIBE;
    async UNSUBSCRIBE(channels, listener, bufferMode) {
      return this._self.#internal.unsubscribe(channels, listener, bufferMode);
    }
    unsubscribe = this.UNSUBSCRIBE;
    async PSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pSubscribe(patterns, listener, bufferMode);
    }
    pSubscribe = this.PSUBSCRIBE;
    async PUNSUBSCRIBE(patterns, listener, bufferMode) {
      return this._self.#internal.pUnsubscribe(patterns, listener, bufferMode);
    }
    pUnsubscribe = this.PUNSUBSCRIBE;
    async acquire() {
      const clientInfo = await this._self.#internal.getClientLease();
      return RedisSentinelClient.create(this._self.#options, this._self.#internal, clientInfo, this._self.#commandOptions);
    }
    getSentinelNode() {
      return this._self.#internal.getSentinelNode();
    }
    getMasterNode() {
      return this._self.#internal.getMasterNode();
    }
    getReplicaNodes() {
      return this._self.#internal.getReplicaNodes();
    }
    setTracer(tracer) {
      if (tracer) {
        this._self.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this._self.#trace = () => {};
      }
      this._self.#internal.setTracer(tracer);
    }
  }
  exports.default = RedisSentinel;

  class RedisSentinelInternal extends node_events_1.EventEmitter {
    #isOpen = false;
    get isOpen() {
      return this.#isOpen;
    }
    #isReady = false;
    get isReady() {
      return this.#isReady;
    }
    #name;
    #nodeClientOptions;
    #sentinelClientOptions;
    #scanInterval;
    #passthroughClientErrorEvents;
    #RESP;
    #anotherReset = false;
    #configEpoch = 0;
    #sentinelRootNodes;
    #sentinelClient;
    #masterClients = [];
    #masterClientQueue;
    #masterPoolSize;
    #replicaClients = [];
    #replicaClientsIdx = 0;
    #replicaPoolSize;
    get useReplicas() {
      return this.#replicaPoolSize > 0;
    }
    #connectPromise;
    #maxCommandRediscovers;
    #pubSubProxy;
    #scanTimer;
    #destroy = false;
    #trace = () => {};
    #clientSideCache;
    get clientSideCache() {
      return this.#clientSideCache;
    }
    #validateOptions(options) {
      if (options?.clientSideCache && options?.RESP !== 3) {
        throw new Error("Client Side Caching is only supported with RESP3");
      }
    }
    constructor(options) {
      super();
      this.#validateOptions(options);
      this.#name = options.name;
      this.#RESP = options.RESP;
      this.#sentinelRootNodes = Array.from(options.sentinelRootNodes);
      this.#maxCommandRediscovers = options.maxCommandRediscovers ?? 16;
      this.#masterPoolSize = options.masterPoolSize ?? 1;
      this.#replicaPoolSize = options.replicaPoolSize ?? 0;
      this.#scanInterval = options.scanInterval ?? 0;
      this.#passthroughClientErrorEvents = options.passthroughClientErrorEvents ?? false;
      this.#nodeClientOptions = options.nodeClientOptions ? { ...options.nodeClientOptions } : {};
      if (this.#nodeClientOptions.url !== undefined) {
        throw new Error("invalid nodeClientOptions for Sentinel");
      }
      if (options.clientSideCache) {
        if (options.clientSideCache instanceof cache_1.PooledClientSideCacheProvider) {
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = options.clientSideCache;
        } else {
          const cscConfig = options.clientSideCache;
          this.#clientSideCache = this.#nodeClientOptions.clientSideCache = new cache_1.BasicPooledClientSideCache(cscConfig);
        }
      }
      this.#sentinelClientOptions = options.sentinelClientOptions ? Object.assign({}, options.sentinelClientOptions) : {};
      this.#sentinelClientOptions.modules = module_1.default;
      if (this.#sentinelClientOptions.url !== undefined) {
        throw new Error("invalid sentinelClientOptions for Sentinel");
      }
      this.#masterClientQueue = new wait_queue_1.WaitQueue;
      for (let i = 0;i < this.#masterPoolSize; i++) {
        this.#masterClientQueue.push(i);
      }
      this.#pubSubProxy = new pub_sub_proxy_1.PubSubProxy(this.#nodeClientOptions, (err) => this.emit("error", err));
    }
    #createClient(node, clientOptions, reconnectStrategy) {
      return client_1.default.create({
        RESP: this.#RESP,
        ...clientOptions,
        socket: {
          ...clientOptions.socket,
          host: node.host,
          port: node.port,
          reconnectStrategy
        }
      });
    }
    getClientLease() {
      const id = this.#masterClientQueue.shift();
      if (id !== undefined) {
        return { id };
      }
      return this.#masterClientQueue.wait().then((id2) => ({ id: id2 }));
    }
    releaseClientLease(clientInfo) {
      const client = this.#masterClients[clientInfo.id];
      if (client !== undefined) {
        const dirtyPromise = client.resetIfDirty();
        if (dirtyPromise) {
          return dirtyPromise.then(() => this.#masterClientQueue.push(clientInfo.id));
        }
      }
      this.#masterClientQueue.push(clientInfo.id);
    }
    async connect() {
      if (this.#isOpen) {
        throw new Error("already attempting to open");
      }
      try {
        this.#isOpen = true;
        this.#connectPromise = this.#connect();
        await this.#connectPromise;
        this.#isReady = true;
      } finally {
        this.#connectPromise = undefined;
        if (this.#scanInterval > 0) {
          this.#scanTimer = setInterval(this.#reset.bind(this), this.#scanInterval);
        }
      }
    }
    async#connect() {
      let count = 0;
      while (true) {
        this.#trace("starting connect loop");
        count += 1;
        if (this.#destroy) {
          this.#trace("in #connect and want to destroy");
          return;
        }
        try {
          this.#anotherReset = false;
          await this.transform(this.analyze(await this.observe()));
          if (this.#anotherReset) {
            this.#trace("#connect: anotherReset is true, so continuing");
            continue;
          }
          this.#trace("#connect: returning");
          return;
        } catch (e) {
          this.#trace(`#connect: exception ${e.message}`);
          if (!this.#isReady && count > this.#maxCommandRediscovers) {
            throw e;
          }
          if (e.message !== "no valid master node") {
            console.log(e);
          }
          await (0, promises_1.setTimeout)(1000);
        } finally {
          this.#trace("finished connect");
        }
      }
    }
    async execute(fn, clientInfo) {
      let iter = 0;
      while (true) {
        if (this.#connectPromise !== undefined) {
          await this.#connectPromise;
        }
        const client = this.#getClient(clientInfo);
        if (!client.isReady) {
          await this.#reset();
          continue;
        }
        const sockOpts = client.options?.socket;
        this.#trace("attemping to send command to " + sockOpts?.host + ":" + sockOpts?.port);
        try {
          return await fn(client);
        } catch (err) {
          if (++iter > this.#maxCommandRediscovers || !(err instanceof Error)) {
            throw err;
          }
          if (clientInfo !== undefined && (err.message.startsWith("READONLY") || !client.isReady)) {
            await this.#reset();
            continue;
          }
          throw err;
        }
      }
    }
    async#createPubSub(client) {
      await client.pSubscribe(["switch-master", "[-+]sdown", "+slave", "+sentinel", "[-+]odown", "+slave-reconf-done"], (message, channel) => {
        this.#handlePubSubControlChannel(channel, message);
      }, true);
      return client;
    }
    async#handlePubSubControlChannel(channel, message) {
      this.#trace("pubsub control channel message on " + channel);
      this.#reset();
    }
    #getClient(clientInfo) {
      if (clientInfo !== undefined) {
        return this.#masterClients[clientInfo.id];
      }
      if (this.#replicaClientsIdx >= this.#replicaClients.length) {
        this.#replicaClientsIdx = 0;
      }
      if (this.#replicaClients.length == 0) {
        throw new Error("no replicas available for read");
      }
      return this.#replicaClients[this.#replicaClientsIdx++];
    }
    async#reset() {
      if (this.#isReady == false || this.#destroy == true) {
        return;
      }
      if (this.#connectPromise !== undefined) {
        this.#anotherReset = true;
        return await this.#connectPromise;
      }
      try {
        this.#connectPromise = this.#connect();
        return await this.#connectPromise;
      } finally {
        this.#trace("finished reconfgure");
        this.#connectPromise = undefined;
      }
    }
    async close() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      const promises = [];
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          promises.push(this.#sentinelClient.close());
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          promises.push(client.close());
        }
      }
      this.#replicaClients = [];
      await Promise.all(promises);
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
    }
    async destroy() {
      this.#destroy = true;
      if (this.#connectPromise != null) {
        await this.#connectPromise;
      }
      this.#isReady = false;
      this.#clientSideCache?.onPoolClose();
      if (this.#scanTimer) {
        clearInterval(this.#scanTimer);
        this.#scanTimer = undefined;
      }
      if (this.#sentinelClient !== undefined) {
        if (this.#sentinelClient.isOpen) {
          this.#sentinelClient.destroy();
        }
        this.#sentinelClient = undefined;
      }
      for (const client of this.#masterClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#masterClients = [];
      for (const client of this.#replicaClients) {
        if (client.isOpen) {
          client.destroy();
        }
      }
      this.#replicaClients = [];
      this.#pubSubProxy.destroy();
      this.#isOpen = false;
      this.#destroy = false;
    }
    async subscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.subscribe(channels, listener, bufferMode);
    }
    async unsubscribe(channels, listener, bufferMode) {
      return this.#pubSubProxy.unsubscribe(channels, listener, bufferMode);
    }
    async pSubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pSubscribe(patterns, listener, bufferMode);
    }
    async pUnsubscribe(patterns, listener, bufferMode) {
      return this.#pubSubProxy.pUnsubscribe(patterns, listener, bufferMode);
    }
    async observe() {
      for (const node of this.#sentinelRootNodes) {
        let client;
        try {
          this.#trace(`observe: trying to connect to sentinel: ${node.host}:${node.port}`);
          client = this.#createClient(node, this.#sentinelClientOptions, false);
          client.on("error", (err) => this.emit("error", `obseve client error: ${err}`));
          await client.connect();
          this.#trace(`observe: connected to sentinel`);
          const [sentinelData, masterData, replicaData] = await Promise.all([
            client.sentinel.sentinelSentinels(this.#name),
            client.sentinel.sentinelMaster(this.#name),
            client.sentinel.sentinelReplicas(this.#name)
          ]);
          this.#trace("observe: got all sentinel data");
          const ret = {
            sentinelConnected: node,
            sentinelData,
            masterData,
            replicaData,
            currentMaster: this.getMasterNode(),
            currentReplicas: this.getReplicaNodes(),
            currentSentinel: this.getSentinelNode(),
            replicaPoolSize: this.#replicaPoolSize,
            useReplicas: this.useReplicas
          };
          return ret;
        } catch (err) {
          this.#trace(`observe: error ${err}`);
          this.emit("error", err);
        } finally {
          if (client !== undefined && client.isOpen) {
            this.#trace(`observe: destroying sentinel client`);
            client.destroy();
          }
        }
      }
      this.#trace(`observe: none of the sentinels are available`);
      throw new Error("None of the sentinels are available");
    }
    analyze(observed) {
      let master = (0, utils_1.parseNode)(observed.masterData);
      if (master === undefined) {
        this.#trace(`analyze: no valid master node because ${observed.masterData.flags}`);
        throw new Error("no valid master node");
      }
      if (master.host === observed.currentMaster?.host && master.port === observed.currentMaster?.port) {
        this.#trace(`analyze: master node hasn't changed from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
        master = undefined;
      } else {
        this.#trace(`analyze: master node has changed to ${master.host}:${master.port} from ${observed.currentMaster?.host}:${observed.currentMaster?.port}`);
      }
      let sentinel = observed.sentinelConnected;
      if (sentinel.host === observed.currentSentinel?.host && sentinel.port === observed.currentSentinel.port) {
        this.#trace(`analyze: sentinel node hasn't changed`);
        sentinel = undefined;
      } else {
        this.#trace(`analyze: sentinel node has changed to ${sentinel.host}:${sentinel.port}`);
      }
      const replicasToClose = [];
      const replicasToOpen = new Map;
      const desiredSet = new Set;
      const seen = new Set;
      if (observed.useReplicas) {
        const replicaList = (0, utils_1.createNodeList)(observed.replicaData);
        for (const node of replicaList) {
          desiredSet.add(JSON.stringify(node));
        }
        for (const [node, value] of observed.currentReplicas) {
          if (!desiredSet.has(JSON.stringify(node))) {
            replicasToClose.push(node);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToClose`);
          } else {
            seen.add(JSON.stringify(node));
            if (value != observed.replicaPoolSize) {
              replicasToOpen.set(node, observed.replicaPoolSize - value);
              this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
            }
          }
        }
        for (const node of replicaList) {
          if (!seen.has(JSON.stringify(node))) {
            replicasToOpen.set(node, observed.replicaPoolSize);
            this.#trace(`analyze: adding ${node.host}:${node.port} to replicsToOpen`);
          }
        }
      }
      const ret = {
        sentinelList: [observed.sentinelConnected].concat((0, utils_1.createNodeList)(observed.sentinelData)),
        epoch: Number(observed.masterData["config-epoch"]),
        sentinelToOpen: sentinel,
        masterToOpen: master,
        replicasToClose,
        replicasToOpen
      };
      return ret;
    }
    async transform(analyzed) {
      this.#trace("transform: enter");
      let promises = [];
      if (analyzed.sentinelToOpen) {
        this.#trace(`transform: opening a new sentinel`);
        if (this.#sentinelClient !== undefined && this.#sentinelClient.isOpen) {
          this.#trace(`transform: destroying old sentinel as open`);
          this.#sentinelClient.destroy();
          this.#sentinelClient = undefined;
        } else {
          this.#trace(`transform: not destroying old sentinel as not open`);
        }
        this.#trace(`transform: creating new sentinel to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const node = analyzed.sentinelToOpen;
        const client = this.#createClient(analyzed.sentinelToOpen, this.#sentinelClientOptions, false);
        client.on("error", (err) => {
          if (this.#passthroughClientErrorEvents) {
            this.emit("error", new Error(`Sentinel Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
          }
          const event2 = {
            type: "SENTINEL",
            node: (0, utils_1.clientSocketToNode)(client.options.socket),
            error: err
          };
          this.emit("client-error", event2);
          this.#reset();
        });
        this.#sentinelClient = client;
        this.#trace(`transform: adding sentinel client connect() to promise list`);
        const promise2 = this.#sentinelClient.connect().then((client2) => {
          return this.#createPubSub(client2);
        });
        promises.push(promise2);
        this.#trace(`created sentinel client to ${analyzed.sentinelToOpen.host}:${analyzed.sentinelToOpen.port}`);
        const event = {
          type: "SENTINEL_CHANGE",
          node: analyzed.sentinelToOpen
        };
        this.#trace(`transform: emiting topology-change event for sentinel_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for sentinel_change returned false`);
        }
      }
      if (analyzed.masterToOpen) {
        this.#trace(`transform: opening a new master`);
        const masterPromises = [];
        const masterWatches = [];
        this.#trace(`transform: destroying old masters if open`);
        for (const client of this.#masterClients) {
          masterWatches.push(client.isWatching || client.isDirtyWatch);
          if (client.isOpen) {
            client.destroy();
          }
        }
        this.#masterClients = [];
        this.#trace(`transform: creating all master clients and adding connect promises`);
        for (let i = 0;i < this.#masterPoolSize; i++) {
          const node = analyzed.masterToOpen;
          const client = this.#createClient(analyzed.masterToOpen, this.#nodeClientOptions);
          client.on("error", (err) => {
            if (this.#passthroughClientErrorEvents) {
              this.emit("error", new Error(`Master Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
            }
            const event2 = {
              type: "MASTER",
              node: (0, utils_1.clientSocketToNode)(client.options.socket),
              error: err
            };
            this.emit("client-error", event2);
          });
          if (masterWatches[i]) {
            client.setDirtyWatch("sentinel config changed in middle of a WATCH Transaction");
          }
          this.#masterClients.push(client);
          masterPromises.push(client.connect());
          this.#trace(`created master client to ${analyzed.masterToOpen.host}:${analyzed.masterToOpen.port}`);
        }
        this.#trace(`transform: adding promise to change #pubSubProxy node`);
        masterPromises.push(this.#pubSubProxy.changeNode(analyzed.masterToOpen));
        promises.push(...masterPromises);
        const event = {
          type: "MASTER_CHANGE",
          node: analyzed.masterToOpen
        };
        this.#trace(`transform: emiting topology-change event for master_change`);
        if (!this.emit("topology-change", event)) {
          this.#trace(`transform: emit for topology-change for master_change returned false`);
        }
        this.#configEpoch++;
      }
      const replicaCloseSet = new Set;
      for (const node of analyzed.replicasToClose) {
        const str = JSON.stringify(node);
        replicaCloseSet.add(str);
      }
      const newClientList = [];
      const removedSet = new Set;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const str = JSON.stringify(node);
        if (replicaCloseSet.has(str) || !replica.isOpen) {
          if (replica.isOpen) {
            const sockOpts = replica.options?.socket;
            this.#trace(`destroying replica client to ${sockOpts?.host}:${sockOpts?.port}`);
            replica.destroy();
          }
          if (!removedSet.has(str)) {
            const event = {
              type: "REPLICA_REMOVE",
              node
            };
            this.emit("topology-change", event);
            removedSet.add(str);
          }
        } else {
          newClientList.push(replica);
        }
      }
      this.#replicaClients = newClientList;
      if (analyzed.replicasToOpen.size != 0) {
        for (const [node, size] of analyzed.replicasToOpen) {
          for (let i = 0;i < size; i++) {
            const client = this.#createClient(node, this.#nodeClientOptions);
            client.on("error", (err) => {
              if (this.#passthroughClientErrorEvents) {
                this.emit("error", new Error(`Replica Client (${node.host}:${node.port}): ${err.message}`, { cause: err }));
              }
              const event2 = {
                type: "REPLICA",
                node: (0, utils_1.clientSocketToNode)(client.options.socket),
                error: err
              };
              this.emit("client-error", event2);
            });
            this.#replicaClients.push(client);
            promises.push(client.connect());
            this.#trace(`created replica client to ${node.host}:${node.port}`);
          }
          const event = {
            type: "REPLICA_ADD",
            node
          };
          this.emit("topology-change", event);
        }
      }
      if (analyzed.sentinelList.length != this.#sentinelRootNodes.length) {
        this.#sentinelRootNodes = analyzed.sentinelList;
        const event = {
          type: "SENTINE_LIST_CHANGE",
          size: analyzed.sentinelList.length
        };
        this.emit("topology-change", event);
      }
      await Promise.all(promises);
      this.#trace("transform: exit");
    }
    getMasterNode() {
      if (this.#masterClients.length == 0) {
        return;
      }
      for (const master of this.#masterClients) {
        if (master.isReady) {
          return (0, utils_1.clientSocketToNode)(master.options.socket);
        }
      }
      return;
    }
    getSentinelNode() {
      if (this.#sentinelClient === undefined) {
        return;
      }
      return (0, utils_1.clientSocketToNode)(this.#sentinelClient.options.socket);
    }
    getReplicaNodes() {
      const ret = new Map;
      const initialMap = new Map;
      for (const replica of this.#replicaClients) {
        const node = (0, utils_1.clientSocketToNode)(replica.options.socket);
        const hash2 = JSON.stringify(node);
        if (replica.isReady) {
          initialMap.set(hash2, (initialMap.get(hash2) ?? 0) + 1);
        } else {
          if (!initialMap.has(hash2)) {
            initialMap.set(hash2, 0);
          }
        }
      }
      for (const [key, value] of initialMap) {
        ret.set(JSON.parse(key), value);
      }
      return ret;
    }
    setTracer(tracer) {
      if (tracer) {
        this.#trace = (msg) => {
          tracer.push(msg);
        };
      } else {
        this.#trace = () => {};
      }
    }
  }

  class RedisSentinelFactory extends node_events_1.EventEmitter {
    options;
    #sentinelRootNodes;
    #replicaIdx = -1;
    constructor(options) {
      super();
      this.options = options;
      this.#sentinelRootNodes = options.sentinelRootNodes;
    }
    async updateSentinelRootNodes() {
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`updateSentinelRootNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        try {
          const sentinelData = await client.sentinel.sentinelSentinels(this.options.name);
          this.#sentinelRootNodes = [node].concat((0, utils_1.createNodeList)(sentinelData));
          return;
        } finally {
          client.destroy();
        }
      }
      throw new Error("Couldn't connect to any sentinel node");
    }
    async getMasterNode() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getMasterNode: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const masterData = await client.sentinel.sentinelMaster(this.options.name);
          let master = (0, utils_1.parseNode)(masterData);
          if (master === undefined) {
            continue;
          }
          return master;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("Master Node Not Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getMasterClient() {
      const master = await this.getMasterNode();
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: master.host,
          port: master.port
        }
      });
    }
    async getReplicaNodes() {
      let connected = false;
      for (const node of this.#sentinelRootNodes) {
        const client = client_1.default.create({
          ...this.options.sentinelClientOptions,
          socket: {
            ...this.options.sentinelClientOptions?.socket,
            host: node.host,
            port: node.port,
            reconnectStrategy: false
          },
          modules: module_1.default
        }).on("error", (err) => this.emit(`getReplicaNodes: ${err}`));
        try {
          await client.connect();
        } catch {
          if (client.isOpen) {
            client.destroy();
          }
          continue;
        }
        connected = true;
        try {
          const replicaData = await client.sentinel.sentinelReplicas(this.options.name);
          const replicas = (0, utils_1.createNodeList)(replicaData);
          if (replicas.length == 0) {
            continue;
          }
          return replicas;
        } finally {
          client.destroy();
        }
      }
      if (connected) {
        throw new Error("No Replicas Nodes Enumerated");
      }
      throw new Error("couldn't connect to any sentinels");
    }
    async getReplicaClient() {
      const replicas = await this.getReplicaNodes();
      if (replicas.length == 0) {
        throw new Error("no available replicas");
      }
      this.#replicaIdx++;
      if (this.#replicaIdx >= replicas.length) {
        this.#replicaIdx = 0;
      }
      return client_1.default.create({
        ...this.options.nodeClientOptions,
        socket: {
          ...this.options.nodeClientOptions?.socket,
          host: replicas[this.#replicaIdx].host,
          port: replicas[this.#replicaIdx].port
        }
      });
    }
  }
  exports.RedisSentinelFactory = RedisSentinelFactory;
});

// node_modules/@redis/client/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasicPooledClientSideCache = exports.BasicClientSideCache = exports.REDIS_FLUSH_MODES = exports.GEO_REPLY_WITH = exports.createSentinel = exports.createCluster = exports.createClientPool = exports.createClient = exports.defineScript = exports.VerbatimString = exports.RESP_TYPES = undefined;
  var decoder_1 = require_decoder9();
  Object.defineProperty(exports, "RESP_TYPES", { enumerable: true, get: function() {
    return decoder_1.RESP_TYPES;
  } });
  var verbatim_string_1 = require_verbatim_string();
  Object.defineProperty(exports, "VerbatimString", { enumerable: true, get: function() {
    return verbatim_string_1.VerbatimString;
  } });
  var lua_script_1 = require_lua_script();
  Object.defineProperty(exports, "defineScript", { enumerable: true, get: function() {
    return lua_script_1.defineScript;
  } });
  __exportStar(require_errors2(), exports);
  var client_1 = __importDefault(require_client());
  exports.createClient = client_1.default.create;
  var pool_1 = require_pool();
  exports.createClientPool = pool_1.RedisClientPool.create;
  var cluster_1 = __importDefault(require_cluster2());
  exports.createCluster = cluster_1.default.create;
  var sentinel_1 = __importDefault(require_sentinel());
  exports.createSentinel = sentinel_1.default.create;
  var GEOSEARCH_WITH_1 = require_GEOSEARCH_WITH();
  Object.defineProperty(exports, "GEO_REPLY_WITH", { enumerable: true, get: function() {
    return GEOSEARCH_WITH_1.GEO_REPLY_WITH;
  } });
  var FLUSHALL_1 = require_FLUSHALL();
  Object.defineProperty(exports, "REDIS_FLUSH_MODES", { enumerable: true, get: function() {
    return FLUSHALL_1.REDIS_FLUSH_MODES;
  } });
  var cache_1 = require_cache();
  Object.defineProperty(exports, "BasicClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicClientSideCache;
  } });
  Object.defineProperty(exports, "BasicPooledClientSideCache", { enumerable: true, get: function() {
    return cache_1.BasicPooledClientSideCache;
  } });
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/ADD.js
var require_ADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("BF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/CARD.js
var require_CARD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.CARD");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/EXISTS.js
var require_EXISTS2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("BF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformInfoV2Reply = undefined;
  var client_1 = require_dist();
  function transformInfoV2Reply(reply, typeMapping) {
    const mapType = typeMapping ? typeMapping[client_1.RESP_TYPES.MAP] : undefined;
    switch (mapType) {
      case Array: {
        return reply;
      }
      case Map: {
        const ret = new Map;
        for (let i = 0;i < reply.length; i += 2) {
          ret.set(reply[i].toString(), reply[i + 1]);
        }
        return ret;
      }
      default: {
        const ret = Object.create(null);
        for (let i = 0;i < reply.length; i += 2) {
          ret[reply[i].toString()] = reply[i + 1];
        }
        return ret;
      }
    }
  }
  exports.transformInfoV2Reply = transformInfoV2Reply;
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/INFO.js
var require_INFO2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("BF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, helpers_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/INSERT.js
var require_INSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items, options) {
      parser.push("BF.INSERT");
      parser.pushKey(key);
      if (options?.CAPACITY !== undefined) {
        parser.push("CAPACITY", options.CAPACITY.toString());
      }
      if (options?.ERROR !== undefined) {
        parser.push("ERROR", options.ERROR.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NOCREATE) {
        parser.push("NOCREATE");
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
      parser.push("ITEMS");
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/LOADCHUNK.js
var require_LOADCHUNK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator, chunk) {
      parser.push("BF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator.toString(), chunk);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/MADD.js
var require_MADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("BF.MADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/MEXISTS.js
var require_MEXISTS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("BF.MEXISTS");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/RESERVE.js
var require_RESERVE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, errorRate, capacity, options) {
      parser.push("BF.RESERVE");
      parser.pushKey(key);
      parser.push(errorRate.toString(), capacity.toString());
      if (options?.EXPANSION) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
      if (options?.NONSCALING) {
        parser.push("NONSCALING");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/SCANDUMP.js
var require_SCANDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator) {
      parser.push("BF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/bloom/index.js
var require_bloom = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD());
  var CARD_1 = __importDefault(require_CARD());
  var EXISTS_1 = __importDefault(require_EXISTS2());
  var INFO_1 = __importDefault(require_INFO2());
  var INSERT_1 = __importDefault(require_INSERT());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK());
  var MADD_1 = __importDefault(require_MADD());
  var MEXISTS_1 = __importDefault(require_MEXISTS());
  var RESERVE_1 = __importDefault(require_RESERVE());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP());
  __exportStar(require_helpers(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    CARD: CARD_1.default,
    card: CARD_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MEXISTS: MEXISTS_1.default,
    mExists: MEXISTS_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INCRBY.js
var require_INCRBY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("CMS.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INFO.js
var require_INFO3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CMS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYDIM.js
var require_INITBYDIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, width, depth) {
      parser.push("CMS.INITBYDIM");
      parser.pushKey(key);
      parser.push(width.toString(), depth.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/INITBYPROB.js
var require_INITBYPROB = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, error40, probability) {
      parser.push("CMS.INITBYPROB");
      parser.pushKey(key);
      parser.push(error40.toString(), probability.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/MERGE.js
var require_MERGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source) {
      parser.push("CMS.MERGE");
      parser.pushKey(destination);
      parser.push(source.length.toString());
      if (isPlainSketches(source)) {
        parser.pushVariadic(source);
      } else {
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].name);
        }
        parser.push("WEIGHTS");
        for (let i = 0;i < source.length; i++) {
          parser.push(source[i].weight.toString());
        }
      }
    },
    transformReply: undefined
  };
  function isPlainSketches(src) {
    return typeof src[0] === "string" || src[0] instanceof Buffer;
  }
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/QUERY.js
var require_QUERY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("CMS.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/count-min-sketch/index.js
var require_count_min_sketch = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importDefault(require_INCRBY2());
  var INFO_1 = __importDefault(require_INFO3());
  var INITBYDIM_1 = __importDefault(require_INITBYDIM());
  var INITBYPROB_1 = __importDefault(require_INITBYPROB());
  var MERGE_1 = __importDefault(require_MERGE());
  var QUERY_1 = __importDefault(require_QUERY());
  exports.default = {
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INITBYDIM: INITBYDIM_1.default,
    initByDim: INITBYDIM_1.default,
    INITBYPROB: INITBYPROB_1.default,
    initByProb: INITBYPROB_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADD.js
var require_ADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADD");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/ADDNX.js
var require_ADDNX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.ADDNX");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/COUNT.js
var require_COUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, item) {
      parser.push("CF.COUNT");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/DEL.js
var require_DEL2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.DEL");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/EXISTS.js
var require_EXISTS3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, item) {
      parser.push("CF.EXISTS");
      parser.pushKey(key);
      parser.push(item);
    },
    transformReply: generic_transformers_1.transformBooleanReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INFO.js
var require_INFO4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("CF.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERT.js
var require_INSERT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCfInsertArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function parseCfInsertArguments(parser, key, items, options) {
    parser.pushKey(key);
    if (options?.CAPACITY !== undefined) {
      parser.push("CAPACITY", options.CAPACITY.toString());
    }
    if (options?.NOCREATE) {
      parser.push("NOCREATE");
    }
    parser.push("ITEMS");
    parser.pushVariadic(items);
  }
  exports.parseCfInsertArguments = parseCfInsertArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      args[0].push("CF.INSERT");
      parseCfInsertArguments(...args);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/INSERTNX.js
var require_INSERTNX = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INSERT_1 = __importStar(require_INSERT2());
  exports.default = {
    IS_READ_ONLY: INSERT_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("CF.INSERTNX");
      (0, INSERT_1.parseCfInsertArguments)(...args);
    },
    transformReply: INSERT_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/LOADCHUNK.js
var require_LOADCHUNK2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, iterator, chunk) {
      parser.push("CF.LOADCHUNK");
      parser.pushKey(key);
      parser.push(iterator.toString(), chunk);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/RESERVE.js
var require_RESERVE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, capacity, options) {
      parser.push("CF.RESERVE");
      parser.pushKey(key);
      parser.push(capacity.toString());
      if (options?.BUCKETSIZE !== undefined) {
        parser.push("BUCKETSIZE", options.BUCKETSIZE.toString());
      }
      if (options?.MAXITERATIONS !== undefined) {
        parser.push("MAXITERATIONS", options.MAXITERATIONS.toString());
      }
      if (options?.EXPANSION !== undefined) {
        parser.push("EXPANSION", options.EXPANSION.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/SCANDUMP.js
var require_SCANDUMP2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, iterator) {
      parser.push("CF.SCANDUMP");
      parser.pushKey(key);
      parser.push(iterator.toString());
    },
    transformReply(reply) {
      return {
        iterator: reply[0],
        chunk: reply[1]
      };
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/cuckoo/index.js
var require_cuckoo = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD2());
  var ADDNX_1 = __importDefault(require_ADDNX());
  var COUNT_1 = __importDefault(require_COUNT());
  var DEL_1 = __importDefault(require_DEL2());
  var EXISTS_1 = __importDefault(require_EXISTS3());
  var INFO_1 = __importDefault(require_INFO4());
  var INSERT_1 = __importDefault(require_INSERT2());
  var INSERTNX_1 = __importDefault(require_INSERTNX());
  var LOADCHUNK_1 = __importDefault(require_LOADCHUNK2());
  var RESERVE_1 = __importDefault(require_RESERVE2());
  var SCANDUMP_1 = __importDefault(require_SCANDUMP2());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ADDNX: ADDNX_1.default,
    addNX: ADDNX_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    EXISTS: EXISTS_1.default,
    exists: EXISTS_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    INSERT: INSERT_1.default,
    insert: INSERT_1.default,
    INSERTNX: INSERTNX_1.default,
    insertNX: INSERTNX_1.default,
    LOADCHUNK: LOADCHUNK_1.default,
    loadChunk: LOADCHUNK_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default,
    SCANDUMP: SCANDUMP_1.default,
    scanDump: SCANDUMP_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/ADD.js
var require_ADD3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.ADD");
      parser.pushKey(key);
      for (const value of values) {
        parser.push(value.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/BYRANK.js
var require_BYRANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformByRankArguments = undefined;
  var generic_transformers_1 = require_generic_transformers();
  function transformByRankArguments(parser, key, ranks) {
    parser.pushKey(key);
    for (const rank of ranks) {
      parser.push(rank.toString());
    }
  }
  exports.transformByRankArguments = transformByRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYRANK");
      transformByRankArguments(...args);
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/BYREVRANK.js
var require_BYREVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var BYRANK_1 = __importStar(require_BYRANK());
  exports.default = {
    IS_READ_ONLY: BYRANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.BYREVRANK");
      (0, BYRANK_1.transformByRankArguments)(...args);
    },
    transformReply: BYRANK_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/CDF.js
var require_CDF = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, values) {
      parser.push("TDIGEST.CDF");
      parser.pushKey(key);
      for (const item of values) {
        parser.push(item.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/CREATE.js
var require_CREATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TDIGEST.CREATE");
      parser.pushKey(key);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/INFO.js
var require_INFO5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MAX.js
var require_MAX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MAX");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MERGE.js
var require_MERGE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, destination, source, options) {
      parser.push("TDIGEST.MERGE");
      parser.pushKey(destination);
      parser.pushKeysLength(source);
      if (options?.COMPRESSION !== undefined) {
        parser.push("COMPRESSION", options.COMPRESSION.toString());
      }
      if (options?.OVERRIDE) {
        parser.push("OVERRIDE");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/MIN.js
var require_MIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TDIGEST.MIN");
      parser.pushKey(key);
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/QUANTILE.js
var require_QUANTILE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, quantiles) {
      parser.push("TDIGEST.QUANTILE");
      parser.pushKey(key);
      for (const quantile of quantiles) {
        parser.push(quantile.toString());
      }
    },
    transformReply: generic_transformers_1.transformDoubleArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/RANK.js
var require_RANK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRankArguments = undefined;
  function transformRankArguments(parser, key, values) {
    parser.pushKey(key);
    for (const value of values) {
      parser.push(value.toString());
    }
  }
  exports.transformRankArguments = transformRankArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      args[0].push("TDIGEST.RANK");
      transformRankArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/RESET.js
var require_RESET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key) {
      parser.push("TDIGEST.RESET");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/REVRANK.js
var require_REVRANK = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANK_1 = __importStar(require_RANK());
  exports.default = {
    IS_READ_ONLY: RANK_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      args[0].push("TDIGEST.REVRANK");
      (0, RANK_1.transformRankArguments)(...args);
    },
    transformReply: RANK_1.default.transformReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/TRIMMED_MEAN.js
var require_TRIMMED_MEAN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, lowCutPercentile, highCutPercentile) {
      parser.push("TDIGEST.TRIMMED_MEAN");
      parser.pushKey(key);
      parser.push(lowCutPercentile.toString(), highCutPercentile.toString());
    },
    transformReply: generic_transformers_1.transformDoubleReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/t-digest/index.js
var require_t_digest = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD3());
  var BYRANK_1 = __importDefault(require_BYRANK());
  var BYREVRANK_1 = __importDefault(require_BYREVRANK());
  var CDF_1 = __importDefault(require_CDF());
  var CREATE_1 = __importDefault(require_CREATE());
  var INFO_1 = __importDefault(require_INFO5());
  var MAX_1 = __importDefault(require_MAX());
  var MERGE_1 = __importDefault(require_MERGE2());
  var MIN_1 = __importDefault(require_MIN());
  var QUANTILE_1 = __importDefault(require_QUANTILE());
  var RANK_1 = __importDefault(require_RANK());
  var RESET_1 = __importDefault(require_RESET());
  var REVRANK_1 = __importDefault(require_REVRANK());
  var TRIMMED_MEAN_1 = __importDefault(require_TRIMMED_MEAN());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    BYRANK: BYRANK_1.default,
    byRank: BYRANK_1.default,
    BYREVRANK: BYREVRANK_1.default,
    byRevRank: BYREVRANK_1.default,
    CDF: CDF_1.default,
    cdf: CDF_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MAX: MAX_1.default,
    max: MAX_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MIN: MIN_1.default,
    min: MIN_1.default,
    QUANTILE: QUANTILE_1.default,
    quantile: QUANTILE_1.default,
    RANK: RANK_1.default,
    rank: RANK_1.default,
    RESET: RESET_1.default,
    reset: RESET_1.default,
    REVRANK: REVRANK_1.default,
    revRank: REVRANK_1.default,
    TRIMMED_MEAN: TRIMMED_MEAN_1.default,
    trimmedMean: TRIMMED_MEAN_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/ADD.js
var require_ADD4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.ADD");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/COUNT.js
var require_COUNT2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, items) {
      parser.push("TOPK.COUNT");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/INCRBY.js
var require_INCRBY3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function pushIncrByItem(parser, { item, incrementBy }) {
    parser.push(item, incrementBy.toString());
  }
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.INCRBY");
      parser.pushKey(key);
      if (Array.isArray(items)) {
        for (const item of items) {
          pushIncrByItem(parser, item);
        }
      } else {
        pushIncrByItem(parser, items);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/INFO.js
var require_INFO6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var bloom_1 = require_bloom();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        reply[7] = generic_transformers_1.transformDoubleReply[2](reply[7], preserve, typeMapping);
        return (0, bloom_1.transformInfoV2Reply)(reply, typeMapping);
      },
      3: undefined
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/LIST_WITHCOUNT.js
var require_LIST_WITHCOUNT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
      parser.push("WITHCOUNT");
    },
    transformReply(rawReply) {
      const reply = [];
      for (let i = 0;i < rawReply.length; i++) {
        reply.push({
          item: rawReply[i],
          count: rawReply[++i]
        });
      }
      return reply;
    }
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/LIST.js
var require_LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TOPK.LIST");
      parser.pushKey(key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/QUERY.js
var require_QUERY2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, items) {
      parser.push("TOPK.QUERY");
      parser.pushKey(key);
      parser.pushVariadic(items);
    },
    transformReply: generic_transformers_1.transformBooleanArrayReply
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/RESERVE.js
var require_RESERVE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, topK, options) {
      parser.push("TOPK.RESERVE");
      parser.pushKey(key);
      parser.push(topK.toString());
      if (options) {
        parser.push(options.width.toString(), options.depth.toString(), options.decay.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/bloom/dist/lib/commands/top-k/index.js
var require_top_k = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD4());
  var COUNT_1 = __importDefault(require_COUNT2());
  var INCRBY_1 = __importDefault(require_INCRBY3());
  var INFO_1 = __importDefault(require_INFO6());
  var LIST_WITHCOUNT_1 = __importDefault(require_LIST_WITHCOUNT());
  var LIST_1 = __importDefault(require_LIST());
  var QUERY_1 = __importDefault(require_QUERY2());
  var RESERVE_1 = __importDefault(require_RESERVE3());
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    COUNT: COUNT_1.default,
    count: COUNT_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    LIST_WITHCOUNT: LIST_WITHCOUNT_1.default,
    listWithCount: LIST_WITHCOUNT_1.default,
    LIST: LIST_1.default,
    list: LIST_1.default,
    QUERY: QUERY_1.default,
    query: QUERY_1.default,
    RESERVE: RESERVE_1.default,
    reserve: RESERVE_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/commands/index.js
var require_commands3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var bloom_1 = __importDefault(require_bloom());
  var count_min_sketch_1 = __importDefault(require_count_min_sketch());
  var cuckoo_1 = __importDefault(require_cuckoo());
  var t_digest_1 = __importDefault(require_t_digest());
  var top_k_1 = __importDefault(require_top_k());
  exports.default = {
    bf: bloom_1.default,
    cms: count_min_sketch_1.default,
    cf: cuckoo_1.default,
    tDigest: t_digest_1.default,
    topK: top_k_1.default
  };
});

// node_modules/@redis/bloom/dist/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands3();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// node_modules/@redis/json/dist/lib/commands/ARRAPPEND.js
var require_ARRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, json2, ...jsons) {
      parser.push("JSON.ARRAPPEND");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json2));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRINDEX.js
var require_ARRINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, path, json2, options) {
      parser.push("JSON.ARRINDEX");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json2));
      if (options?.range) {
        parser.push(options.range.start.toString());
        if (options.range.stop !== undefined) {
          parser.push(options.range.stop.toString());
        }
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRINSERT.js
var require_ARRINSERT = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, index, json2, ...jsons) {
      parser.push("JSON.ARRINSERT");
      parser.pushKey(key);
      parser.push(path, index.toString(), (0, generic_transformers_1.transformRedisJsonArgument)(json2));
      for (let i = 0;i < jsons.length; i++) {
        parser.push((0, generic_transformers_1.transformRedisJsonArgument)(jsons[i]));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRLEN.js
var require_ARRLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRPOP.js
var require_ARRPOP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.ARRPOP");
      parser.pushKey(key);
      if (options) {
        parser.push(options.path);
        if (options.index !== undefined) {
          parser.push(options.index.toString());
        }
      }
    },
    transformReply(reply) {
      return (0, generic_transformers_1.isArrayReply)(reply) ? reply.map((item) => (0, generic_transformers_1.transformRedisJsonNullReply)(item)) : (0, generic_transformers_1.transformRedisJsonNullReply)(reply);
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/ARRTRIM.js
var require_ARRTRIM = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, start, stop) {
      parser.push("JSON.ARRTRIM");
      parser.pushKey(key);
      parser.push(path, start.toString(), stop.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/CLEAR.js
var require_CLEAR = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.CLEAR");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/DEBUG_MEMORY.js
var require_DEBUG_MEMORY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEBUG", "MEMORY");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/DEL.js
var require_DEL3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.DEL");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/FORGET.js
var require_FORGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.FORGET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/GET.js
var require_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.GET");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.pushVariadic(options.path);
      }
    },
    transformReply: generic_transformers_1.transformRedisJsonNullReply
  };
});

// node_modules/@redis/json/dist/lib/commands/MERGE.js
var require_MERGE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, value) {
      parser.push("JSON.MERGE");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(value));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/MGET.js
var require_MGET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, keys, path) {
      parser.push("JSON.MGET");
      parser.pushKeys(keys);
      parser.push(path);
    },
    transformReply(reply) {
      return reply.map((json2) => (0, generic_transformers_1.transformRedisJsonNullReply)(json2));
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/MSET.js
var require_MSET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, items) {
      parser.push("JSON.MSET");
      for (let i = 0;i < items.length; i++) {
        parser.pushKey(items[i].key);
        parser.push(items[i].path, (0, generic_transformers_1.transformRedisJsonArgument)(items[i].value));
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/NUMINCRBY.js
var require_NUMINCRBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, by) {
      parser.push("JSON.NUMINCRBY");
      parser.pushKey(key);
      parser.push(path, by.toString());
    },
    transformReply: {
      2: (reply) => {
        return JSON.parse(reply.toString());
      },
      3: undefined
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/NUMMULTBY.js
var require_NUMMULTBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, by) {
      parser.push("JSON.NUMMULTBY");
      parser.pushKey(key);
      parser.push(path, by.toString());
    },
    transformReply: NUMINCRBY_1.default.transformReply
  };
});

// node_modules/@redis/json/dist/lib/commands/OBJKEYS.js
var require_OBJKEYS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJKEYS");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/OBJLEN.js
var require_OBJLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.OBJLEN");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/SET.js
var require_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path, json2, options) {
      parser.push("JSON.SET");
      parser.pushKey(key);
      parser.push(path, (0, generic_transformers_1.transformRedisJsonArgument)(json2));
      if (options?.condition) {
        parser.push(options?.condition);
      } else if (options?.NX) {
        parser.push("NX");
      } else if (options?.XX) {
        parser.push("XX");
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/STRAPPEND.js
var require_STRAPPEND = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, append, options) {
      parser.push("JSON.STRAPPEND");
      parser.pushKey(key);
      if (options?.path !== undefined) {
        parser.push(options.path);
      }
      parser.push((0, generic_transformers_1.transformRedisJsonArgument)(append));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/STRLEN.js
var require_STRLEN2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.STRLEN");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/TOGGLE.js
var require_TOGGLE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, path) {
      parser.push("JSON.TOGGLE");
      parser.pushKey(key);
      parser.push(path);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/json/dist/lib/commands/TYPE.js
var require_TYPE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("JSON.TYPE");
      parser.pushKey(key);
      if (options?.path) {
        parser.push(options.path);
      }
    },
    transformReply: {
      2: undefined,
      3: (reply) => {
        return reply[0];
      }
    }
  };
});

// node_modules/@redis/json/dist/lib/commands/index.js
var require_commands4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRedisJsonNullReply = exports.transformRedisJsonReply = exports.transformRedisJsonArgument = undefined;
  var ARRAPPEND_1 = __importDefault(require_ARRAPPEND());
  var ARRINDEX_1 = __importDefault(require_ARRINDEX());
  var ARRINSERT_1 = __importDefault(require_ARRINSERT());
  var ARRLEN_1 = __importDefault(require_ARRLEN());
  var ARRPOP_1 = __importDefault(require_ARRPOP());
  var ARRTRIM_1 = __importDefault(require_ARRTRIM());
  var CLEAR_1 = __importDefault(require_CLEAR());
  var DEBUG_MEMORY_1 = __importDefault(require_DEBUG_MEMORY());
  var DEL_1 = __importDefault(require_DEL3());
  var FORGET_1 = __importDefault(require_FORGET());
  var GET_1 = __importDefault(require_GET2());
  var MERGE_1 = __importDefault(require_MERGE3());
  var MGET_1 = __importDefault(require_MGET2());
  var MSET_1 = __importDefault(require_MSET2());
  var NUMINCRBY_1 = __importDefault(require_NUMINCRBY());
  var NUMMULTBY_1 = __importDefault(require_NUMMULTBY());
  var OBJKEYS_1 = __importDefault(require_OBJKEYS());
  var OBJLEN_1 = __importDefault(require_OBJLEN());
  var SET_1 = __importDefault(require_SET2());
  var STRAPPEND_1 = __importDefault(require_STRAPPEND());
  var STRLEN_1 = __importDefault(require_STRLEN2());
  var TOGGLE_1 = __importDefault(require_TOGGLE());
  var TYPE_1 = __importDefault(require_TYPE2());
  var generic_transformers_1 = require_generic_transformers();
  Object.defineProperty(exports, "transformRedisJsonArgument", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonArgument;
  } });
  Object.defineProperty(exports, "transformRedisJsonReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonReply;
  } });
  Object.defineProperty(exports, "transformRedisJsonNullReply", { enumerable: true, get: function() {
    return generic_transformers_1.transformRedisJsonNullReply;
  } });
  exports.default = {
    ARRAPPEND: ARRAPPEND_1.default,
    arrAppend: ARRAPPEND_1.default,
    ARRINDEX: ARRINDEX_1.default,
    arrIndex: ARRINDEX_1.default,
    ARRINSERT: ARRINSERT_1.default,
    arrInsert: ARRINSERT_1.default,
    ARRLEN: ARRLEN_1.default,
    arrLen: ARRLEN_1.default,
    ARRPOP: ARRPOP_1.default,
    arrPop: ARRPOP_1.default,
    ARRTRIM: ARRTRIM_1.default,
    arrTrim: ARRTRIM_1.default,
    CLEAR: CLEAR_1.default,
    clear: CLEAR_1.default,
    DEBUG_MEMORY: DEBUG_MEMORY_1.default,
    debugMemory: DEBUG_MEMORY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    FORGET: FORGET_1.default,
    forget: FORGET_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    MERGE: MERGE_1.default,
    merge: MERGE_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MSET: MSET_1.default,
    mSet: MSET_1.default,
    NUMINCRBY: NUMINCRBY_1.default,
    numIncrBy: NUMINCRBY_1.default,
    NUMMULTBY: NUMMULTBY_1.default,
    numMultBy: NUMMULTBY_1.default,
    OBJKEYS: OBJKEYS_1.default,
    objKeys: OBJKEYS_1.default,
    OBJLEN: OBJLEN_1.default,
    objLen: OBJLEN_1.default,
    SET: SET_1.default,
    set: SET_1.default,
    STRAPPEND: STRAPPEND_1.default,
    strAppend: STRAPPEND_1.default,
    STRLEN: STRLEN_1.default,
    strLen: STRLEN_1.default,
    TOGGLE: TOGGLE_1.default,
    toggle: TOGGLE_1.default,
    TYPE: TYPE_1.default,
    type: TYPE_1.default
  };
});

// node_modules/@redis/json/dist/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = undefined;
  var commands_1 = require_commands4();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
});

// node_modules/@redis/search/dist/lib/commands/_LIST.js
var require__LIST = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser) {
      parser.push("FT._LIST");
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/CREATE.js
var require_CREATE2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.REDISEARCH_LANGUAGE = exports.parseSchema = exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = undefined;
  var generic_transformers_1 = require_generic_transformers();
  exports.SCHEMA_FIELD_TYPE = {
    TEXT: "TEXT",
    NUMERIC: "NUMERIC",
    GEO: "GEO",
    TAG: "TAG",
    VECTOR: "VECTOR",
    GEOSHAPE: "GEOSHAPE"
  };
  exports.SCHEMA_TEXT_FIELD_PHONETIC = {
    DM_EN: "dm:en",
    DM_FR: "dm:fr",
    FM_PT: "dm:pt",
    DM_ES: "dm:es"
  };
  exports.SCHEMA_VECTOR_FIELD_ALGORITHM = {
    FLAT: "FLAT",
    HNSW: "HNSW"
  };
  exports.SCHEMA_GEO_SHAPE_COORD_SYSTEM = {
    SPHERICAL: "SPHERICAL",
    FLAT: "FLAT"
  };
  function parseCommonSchemaFieldOptions(parser, fieldOptions) {
    if (fieldOptions.SORTABLE) {
      parser.push("SORTABLE");
      if (fieldOptions.SORTABLE === "UNF") {
        parser.push("UNF");
      }
    }
    if (fieldOptions.NOINDEX) {
      parser.push("NOINDEX");
    }
  }
  function parseSchema(parser, schema2) {
    for (const [field, fieldOptions] of Object.entries(schema2)) {
      parser.push(field);
      if (typeof fieldOptions === "string") {
        parser.push(fieldOptions);
        continue;
      }
      if (fieldOptions.AS) {
        parser.push("AS", fieldOptions.AS);
      }
      parser.push(fieldOptions.type);
      if (fieldOptions.INDEXMISSING) {
        parser.push("INDEXMISSING");
      }
      switch (fieldOptions.type) {
        case exports.SCHEMA_FIELD_TYPE.TEXT:
          if (fieldOptions.NOSTEM) {
            parser.push("NOSTEM");
          }
          if (fieldOptions.WEIGHT) {
            parser.push("WEIGHT", fieldOptions.WEIGHT.toString());
          }
          if (fieldOptions.PHONETIC) {
            parser.push("PHONETIC", fieldOptions.PHONETIC);
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.NUMERIC:
        case exports.SCHEMA_FIELD_TYPE.GEO:
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.TAG:
          if (fieldOptions.SEPARATOR) {
            parser.push("SEPARATOR", fieldOptions.SEPARATOR);
          }
          if (fieldOptions.CASESENSITIVE) {
            parser.push("CASESENSITIVE");
          }
          if (fieldOptions.WITHSUFFIXTRIE) {
            parser.push("WITHSUFFIXTRIE");
          }
          if (fieldOptions.INDEXEMPTY) {
            parser.push("INDEXEMPTY");
          }
          parseCommonSchemaFieldOptions(parser, fieldOptions);
          break;
        case exports.SCHEMA_FIELD_TYPE.VECTOR:
          parser.push(fieldOptions.ALGORITHM);
          const args = [];
          args.push("TYPE", fieldOptions.TYPE, "DIM", fieldOptions.DIM.toString(), "DISTANCE_METRIC", fieldOptions.DISTANCE_METRIC);
          if (fieldOptions.INITIAL_CAP) {
            args.push("INITIAL_CAP", fieldOptions.INITIAL_CAP.toString());
          }
          switch (fieldOptions.ALGORITHM) {
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.FLAT:
              if (fieldOptions.BLOCK_SIZE) {
                args.push("BLOCK_SIZE", fieldOptions.BLOCK_SIZE.toString());
              }
              break;
            case exports.SCHEMA_VECTOR_FIELD_ALGORITHM.HNSW:
              if (fieldOptions.M) {
                args.push("M", fieldOptions.M.toString());
              }
              if (fieldOptions.EF_CONSTRUCTION) {
                args.push("EF_CONSTRUCTION", fieldOptions.EF_CONSTRUCTION.toString());
              }
              if (fieldOptions.EF_RUNTIME) {
                args.push("EF_RUNTIME", fieldOptions.EF_RUNTIME.toString());
              }
              break;
          }
          parser.pushVariadicWithLength(args);
          break;
        case exports.SCHEMA_FIELD_TYPE.GEOSHAPE:
          if (fieldOptions.COORD_SYSTEM !== undefined) {
            parser.push("COORD_SYSTEM", fieldOptions.COORD_SYSTEM);
          }
          break;
      }
    }
  }
  exports.parseSchema = parseSchema;
  exports.REDISEARCH_LANGUAGE = {
    ARABIC: "Arabic",
    BASQUE: "Basque",
    CATALANA: "Catalan",
    DANISH: "Danish",
    DUTCH: "Dutch",
    ENGLISH: "English",
    FINNISH: "Finnish",
    FRENCH: "French",
    GERMAN: "German",
    GREEK: "Greek",
    HUNGARIAN: "Hungarian",
    INDONESAIN: "Indonesian",
    IRISH: "Irish",
    ITALIAN: "Italian",
    LITHUANIAN: "Lithuanian",
    NEPALI: "Nepali",
    NORWEIGAN: "Norwegian",
    PORTUGUESE: "Portuguese",
    ROMANIAN: "Romanian",
    RUSSIAN: "Russian",
    SPANISH: "Spanish",
    SWEDISH: "Swedish",
    TAMIL: "Tamil",
    TURKISH: "Turkish",
    CHINESE: "Chinese"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema2, options) {
      parser.push("FT.CREATE", index);
      if (options?.ON) {
        parser.push("ON", options.ON);
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "PREFIX", options?.PREFIX);
      if (options?.FILTER) {
        parser.push("FILTER", options.FILTER);
      }
      if (options?.LANGUAGE) {
        parser.push("LANGUAGE", options.LANGUAGE);
      }
      if (options?.LANGUAGE_FIELD) {
        parser.push("LANGUAGE_FIELD", options.LANGUAGE_FIELD);
      }
      if (options?.SCORE) {
        parser.push("SCORE", options.SCORE.toString());
      }
      if (options?.SCORE_FIELD) {
        parser.push("SCORE_FIELD", options.SCORE_FIELD);
      }
      if (options?.MAXTEXTFIELDS) {
        parser.push("MAXTEXTFIELDS");
      }
      if (options?.TEMPORARY) {
        parser.push("TEMPORARY", options.TEMPORARY.toString());
      }
      if (options?.NOOFFSETS) {
        parser.push("NOOFFSETS");
      }
      if (options?.NOHL) {
        parser.push("NOHL");
      }
      if (options?.NOFIELDS) {
        parser.push("NOFIELDS");
      }
      if (options?.NOFREQS) {
        parser.push("NOFREQS");
      }
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "STOPWORDS", options?.STOPWORDS);
      parser.push("SCHEMA");
      parseSchema(parser, schema2);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALTER.js
var require_ALTER = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var CREATE_1 = require_CREATE2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, schema2) {
      parser.push("FT.ALTER", index, "SCHEMA", "ADD");
      (0, CREATE_1.parseSchema)(parser, schema2);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/dialect/default.js
var require_default2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_DIALECT = undefined;
  exports.DEFAULT_DIALECT = "2";
});

// node_modules/@redis/search/dist/lib/commands/SEARCH.js
var require_SEARCH = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseSearchOptions = exports.parseParamsArgument = undefined;
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default2();
  function parseParamsArgument(parser, params) {
    if (params) {
      parser.push("PARAMS");
      const args = [];
      for (const key in params) {
        if (!Object.hasOwn(params, key))
          continue;
        const value = params[key];
        args.push(key, typeof value === "number" ? value.toString() : value);
      }
      parser.pushVariadicWithLength(args);
    }
  }
  exports.parseParamsArgument = parseParamsArgument;
  function parseSearchOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.NOSTOPWORDS) {
      parser.push("NOSTOPWORDS");
    }
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INKEYS", options?.INKEYS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "INFIELDS", options?.INFIELDS);
    (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "RETURN", options?.RETURN);
    if (options?.SUMMARIZE) {
      parser.push("SUMMARIZE");
      if (typeof options.SUMMARIZE === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.SUMMARIZE.FIELDS);
        if (options.SUMMARIZE.FRAGS !== undefined) {
          parser.push("FRAGS", options.SUMMARIZE.FRAGS.toString());
        }
        if (options.SUMMARIZE.LEN !== undefined) {
          parser.push("LEN", options.SUMMARIZE.LEN.toString());
        }
        if (options.SUMMARIZE.SEPARATOR !== undefined) {
          parser.push("SEPARATOR", options.SUMMARIZE.SEPARATOR);
        }
      }
    }
    if (options?.HIGHLIGHT) {
      parser.push("HIGHLIGHT");
      if (typeof options.HIGHLIGHT === "object") {
        (0, generic_transformers_1.parseOptionalVariadicArgument)(parser, "FIELDS", options.HIGHLIGHT.FIELDS);
        if (options.HIGHLIGHT.TAGS) {
          parser.push("TAGS", options.HIGHLIGHT.TAGS.open, options.HIGHLIGHT.TAGS.close);
        }
      }
    }
    if (options?.SLOP !== undefined) {
      parser.push("SLOP", options.SLOP.toString());
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.INORDER) {
      parser.push("INORDER");
    }
    if (options?.LANGUAGE) {
      parser.push("LANGUAGE", options.LANGUAGE);
    }
    if (options?.EXPANDER) {
      parser.push("EXPANDER", options.EXPANDER);
    }
    if (options?.SCORER) {
      parser.push("SCORER", options.SCORER);
    }
    if (options?.SORTBY) {
      parser.push("SORTBY");
      if (typeof options.SORTBY === "string" || options.SORTBY instanceof Buffer) {
        parser.push(options.SORTBY);
      } else {
        parser.push(options.SORTBY.BY);
        if (options.SORTBY.DIRECTION) {
          parser.push(options.SORTBY.DIRECTION);
        }
      }
    }
    if (options?.LIMIT) {
      parser.push("LIMIT", options.LIMIT.from.toString(), options.LIMIT.size.toString());
    }
    parseParamsArgument(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseSearchOptions = parseSearchOptions;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SEARCH", index, query);
      parseSearchOptions(parser, options);
    },
    transformReply: {
      2: (reply) => {
        const withoutDocuments = reply[0] + 1 == reply.length;
        const documents = [];
        let i = 1;
        while (i < reply.length) {
          documents.push({
            id: reply[i++],
            value: withoutDocuments ? Object.create(null) : documentValue(reply[i++])
          });
        }
        return {
          total: reply[0],
          documents
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function documentValue(tuples) {
    const message = Object.create(null);
    if (!tuples) {
      return message;
    }
    let i = 0;
    while (i < tuples.length) {
      const key = tuples[i++], value = tuples[i++];
      if (key === "$") {
        try {
          Object.assign(message, JSON.parse(value));
          continue;
        } catch {}
      }
      message[key] = value;
    }
    return message;
  }
});

// node_modules/@redis/search/dist/lib/commands/AGGREGATE.js
var require_AGGREGATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseAggregateOptions = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.FT_AGGREGATE_STEPS = undefined;
  var SEARCH_1 = require_SEARCH();
  var generic_transformers_1 = require_generic_transformers();
  var default_1 = require_default2();
  exports.FT_AGGREGATE_STEPS = {
    GROUPBY: "GROUPBY",
    SORTBY: "SORTBY",
    APPLY: "APPLY",
    LIMIT: "LIMIT",
    FILTER: "FILTER"
  };
  exports.FT_AGGREGATE_GROUP_BY_REDUCERS = {
    COUNT: "COUNT",
    COUNT_DISTINCT: "COUNT_DISTINCT",
    COUNT_DISTINCTISH: "COUNT_DISTINCTISH",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    STDDEV: "STDDEV",
    QUANTILE: "QUANTILE",
    TOLIST: "TOLIST",
    FIRST_VALUE: "FIRST_VALUE",
    RANDOM_SAMPLE: "RANDOM_SAMPLE"
  };
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: false,
    parseCommand(parser, index, query, options) {
      parser.push("FT.AGGREGATE", index, query);
      return parseAggregateOptions(parser, options);
    },
    transformReply: {
      2: (rawReply, preserve, typeMapping) => {
        const results = [];
        for (let i = 1;i < rawReply.length; i++) {
          results.push((0, generic_transformers_1.transformTuplesReply)(rawReply[i], preserve, typeMapping));
        }
        return {
          total: Number(rawReply[0]),
          results
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseAggregateOptions(parser, options) {
    if (options?.VERBATIM) {
      parser.push("VERBATIM");
    }
    if (options?.ADDSCORES) {
      parser.push("ADDSCORES");
    }
    if (options?.LOAD) {
      const args = [];
      if (Array.isArray(options.LOAD)) {
        for (const load of options.LOAD) {
          pushLoadField(args, load);
        }
      } else {
        pushLoadField(args, options.LOAD);
      }
      parser.push("LOAD");
      parser.pushVariadicWithLength(args);
    }
    if (options?.TIMEOUT !== undefined) {
      parser.push("TIMEOUT", options.TIMEOUT.toString());
    }
    if (options?.STEPS) {
      for (const step of options.STEPS) {
        parser.push(step.type);
        switch (step.type) {
          case exports.FT_AGGREGATE_STEPS.GROUPBY:
            if (!step.properties) {
              parser.push("0");
            } else {
              parser.pushVariadicWithLength(step.properties);
            }
            if (Array.isArray(step.REDUCE)) {
              for (const reducer of step.REDUCE) {
                parseGroupByReducer(parser, reducer);
              }
            } else {
              parseGroupByReducer(parser, step.REDUCE);
            }
            break;
          case exports.FT_AGGREGATE_STEPS.SORTBY:
            const args = [];
            if (Array.isArray(step.BY)) {
              for (const by of step.BY) {
                pushSortByProperty(args, by);
              }
            } else {
              pushSortByProperty(args, step.BY);
            }
            if (step.MAX) {
              args.push("MAX", step.MAX.toString());
            }
            parser.pushVariadicWithLength(args);
            break;
          case exports.FT_AGGREGATE_STEPS.APPLY:
            parser.push(step.expression, "AS", step.AS);
            break;
          case exports.FT_AGGREGATE_STEPS.LIMIT:
            parser.push(step.from.toString(), step.size.toString());
            break;
          case exports.FT_AGGREGATE_STEPS.FILTER:
            parser.push(step.expression);
            break;
        }
      }
    }
    (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
    if (options?.DIALECT) {
      parser.push("DIALECT", options.DIALECT.toString());
    } else {
      parser.push("DIALECT", default_1.DEFAULT_DIALECT);
    }
  }
  exports.parseAggregateOptions = parseAggregateOptions;
  function pushLoadField(args, toLoad) {
    if (typeof toLoad === "string" || toLoad instanceof Buffer) {
      args.push(toLoad);
    } else {
      args.push(toLoad.identifier);
      if (toLoad.AS) {
        args.push("AS", toLoad.AS);
      }
    }
  }
  function parseGroupByReducer(parser, reducer) {
    parser.push("REDUCE", reducer.type);
    switch (reducer.type) {
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT:
        parser.push("0");
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCT:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.COUNT_DISTINCTISH:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.SUM:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MIN:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.MAX:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.AVG:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.STDDEV:
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.TOLIST:
        parser.push("1", reducer.property);
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.QUANTILE:
        parser.push("2", reducer.property, reducer.quantile.toString());
        break;
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.FIRST_VALUE: {
        const args = [reducer.property];
        if (reducer.BY) {
          args.push("BY");
          if (typeof reducer.BY === "string" || reducer.BY instanceof Buffer) {
            args.push(reducer.BY);
          } else {
            args.push(reducer.BY.property);
            if (reducer.BY.direction) {
              args.push(reducer.BY.direction);
            }
          }
        }
        parser.pushVariadicWithLength(args);
        break;
      }
      case exports.FT_AGGREGATE_GROUP_BY_REDUCERS.RANDOM_SAMPLE:
        parser.push("2", reducer.property, reducer.sampleSize.toString());
        break;
    }
    if (reducer.AS) {
      parser.push("AS", reducer.AS);
    }
  }
  function pushSortByProperty(args, sortBy) {
    if (typeof sortBy === "string" || sortBy instanceof Buffer) {
      args.push(sortBy);
    } else {
      args.push(sortBy.BY);
      if (sortBy.DIRECTION) {
        args.push(sortBy.DIRECTION);
      }
    }
  }
});

// node_modules/@redis/search/dist/lib/commands/AGGREGATE_WITHCURSOR.js
var require_AGGREGATE_WITHCURSOR = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  exports.default = {
    IS_READ_ONLY: AGGREGATE_1.default.IS_READ_ONLY,
    parseCommand(parser, index, query, options) {
      AGGREGATE_1.default.parseCommand(parser, index, query, options);
      parser.push("WITHCURSOR");
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
      if (options?.MAXIDLE !== undefined) {
        parser.push("MAXIDLE", options.MAXIDLE.toString());
      }
    },
    transformReply: {
      2: (reply) => {
        return {
          ...AGGREGATE_1.default.transformReply[2](reply[0]),
          cursor: reply[1]
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASADD.js
var require_ALIASADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASADD", alias, index);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASDEL.js
var require_ALIASDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias) {
      parser.push("FT.ALIASDEL", alias);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/ALIASUPDATE.js
var require_ALIASUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, alias, index) {
      parser.push("FT.ALIASUPDATE", alias, index);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CONFIG_GET.js
var require_CONFIG_GET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, option) {
      parser.push("FT.CONFIG", "GET", option);
    },
    transformReply(reply) {
      const transformedReply = Object.create(null);
      for (const item of reply) {
        const [key, value] = item;
        transformedReply[key.toString()] = value;
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/CONFIG_SET.js
var require_CONFIG_SET2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, property, value) {
      parser.push("FT.CONFIG", "SET", property, value);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CURSOR_DEL.js
var require_CURSOR_DEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursorId) {
      parser.push("FT.CURSOR", "DEL", index, cursorId.toString());
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/CURSOR_READ.js
var require_CURSOR_READ = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, cursor, options) {
      parser.push("FT.CURSOR", "READ", index, cursor.toString());
      if (options?.COUNT !== undefined) {
        parser.push("COUNT", options.COUNT.toString());
      }
    },
    transformReply: AGGREGATE_WITHCURSOR_1.default.transformReply,
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTADD.js
var require_DICTADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTADD", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTDEL.js
var require_DICTDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary, term) {
      parser.push("FT.DICTDEL", dictionary);
      parser.pushVariadic(term);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/DICTDUMP.js
var require_DICTDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, dictionary) {
      parser.push("FT.DICTDUMP", dictionary);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/DROPINDEX.js
var require_DROPINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, options) {
      parser.push("FT.DROPINDEX", index);
      if (options?.DD) {
        parser.push("DD");
      }
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/EXPLAIN.js
var require_EXPLAIN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = require_SEARCH();
  var default_1 = require_default2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAIN", index, query);
      (0, SEARCH_1.parseParamsArgument)(parser, options?.PARAMS);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/EXPLAINCLI.js
var require_EXPLAINCLI = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.EXPLAINCLI", index, query);
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/INFO.js
var require_INFO7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.INFO", index);
    },
    transformReply: {
      2: transformV2Reply,
      3: undefined
    },
    unstableResp3: true
  };
  function transformV2Reply(reply, preserve, typeMapping) {
    const myTransformFunc = (0, generic_transformers_1.createTransformTuplesReplyFunc)(preserve, typeMapping);
    const ret = {};
    for (let i = 0;i < reply.length; i += 2) {
      const key = reply[i].toString();
      switch (key) {
        case "index_name":
        case "index_options":
        case "num_docs":
        case "max_doc_id":
        case "num_terms":
        case "num_records":
        case "total_inverted_index_blocks":
        case "hash_indexing_failures":
        case "indexing":
        case "number_of_uses":
        case "cleaning":
        case "stopwords_list":
          ret[key] = reply[i + 1];
          break;
        case "inverted_sz_mb":
        case "vector_index_sz_mb":
        case "offset_vectors_sz_mb":
        case "doc_table_size_mb":
        case "sortable_values_size_mb":
        case "key_table_size_mb":
        case "text_overhead_sz_mb":
        case "tag_overhead_sz_mb":
        case "total_index_memory_sz_mb":
        case "geoshapes_sz_mb":
        case "records_per_doc_avg":
        case "bytes_per_record_avg":
        case "offsets_per_term_avg":
        case "offset_bits_per_record_avg":
        case "total_indexing_time":
        case "percent_indexed":
          ret[key] = generic_transformers_1.transformDoubleReply[2](reply[i + 1], undefined, typeMapping);
          break;
        case "index_definition":
          ret[key] = myTransformFunc(reply[i + 1]);
          break;
        case "attributes":
          ret[key] = reply[i + 1].map((attribute) => myTransformFunc(attribute));
          break;
        case "gc_stats": {
          const innerRet = {};
          const array2 = reply[i + 1];
          for (let i2 = 0;i2 < array2.length; i2 += 2) {
            const innerKey = array2[i2].toString();
            switch (innerKey) {
              case "bytes_collected":
              case "total_ms_run":
              case "total_cycles":
              case "average_cycle_time_ms":
              case "last_run_time_ms":
              case "gc_numeric_trees_missed":
              case "gc_blocks_denied":
                innerRet[innerKey] = generic_transformers_1.transformDoubleReply[2](array2[i2 + 1], undefined, typeMapping);
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
        case "cursor_stats": {
          const innerRet = {};
          const array2 = reply[i + 1];
          for (let i2 = 0;i2 < array2.length; i2 += 2) {
            const innerKey = array2[i2].toString();
            switch (innerKey) {
              case "global_idle":
              case "global_total":
              case "index_capacity":
              case "index_total":
                innerRet[innerKey] = array2[i2 + 1];
                break;
            }
          }
          ret[key] = innerRet;
          break;
        }
      }
    }
    return ret;
  }
});

// node_modules/@redis/search/dist/lib/commands/PROFILE_SEARCH.js
var require_PROFILE_SEARCH = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importStar(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "SEARCH");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, SEARCH_1.parseSearchOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: SEARCH_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/PROFILE_AGGREGATE.js
var require_PROFILE_AGGREGATE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var AGGREGATE_1 = __importStar(require_AGGREGATE());
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.PROFILE", index, "AGGREGATE");
      if (options?.LIMITED) {
        parser.push("LIMITED");
      }
      parser.push("QUERY", query);
      (0, AGGREGATE_1.parseAggregateOptions)(parser, options);
    },
    transformReply: {
      2: (reply) => {
        return {
          results: AGGREGATE_1.default.transformReply[2](reply[0]),
          profile: reply[1]
        };
      },
      3: (reply) => reply
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/SEARCH_NOCONTENT.js
var require_SEARCH_NOCONTENT = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var SEARCH_1 = __importDefault(require_SEARCH());
  exports.default = {
    NOT_KEYED_COMMAND: SEARCH_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: SEARCH_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SEARCH_1.default.parseCommand(...args);
      args[0].push("NOCONTENT");
    },
    transformReply: {
      2: (reply) => {
        return {
          total: reply[0],
          documents: reply.slice(1)
        };
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/search/dist/lib/commands/SPELLCHECK.js
var require_SPELLCHECK = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var default_1 = require_default2();
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, query, options) {
      parser.push("FT.SPELLCHECK", index, query);
      if (options?.DISTANCE) {
        parser.push("DISTANCE", options.DISTANCE.toString());
      }
      if (options?.TERMS) {
        if (Array.isArray(options.TERMS)) {
          for (const term of options.TERMS) {
            parseTerms(parser, term);
          }
        } else {
          parseTerms(parser, options.TERMS);
        }
      }
      if (options?.DIALECT) {
        parser.push("DIALECT", options.DIALECT.toString());
      } else {
        parser.push("DIALECT", default_1.DEFAULT_DIALECT);
      }
    },
    transformReply: {
      2: (rawReply) => {
        return rawReply.map(([, term, suggestions]) => ({
          term,
          suggestions: suggestions.map(([score, suggestion]) => ({
            score: Number(score),
            suggestion
          }))
        }));
      },
      3: undefined
    },
    unstableResp3: true
  };
  function parseTerms(parser, { mode, dictionary }) {
    parser.push("TERMS", mode, dictionary);
  }
});

// node_modules/@redis/search/dist/lib/commands/SUGADD.js
var require_SUGADD = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string4, score, options) {
      parser.push("FT.SUGADD");
      parser.pushKey(key);
      parser.push(string4, score.toString());
      if (options?.INCR) {
        parser.push("INCR");
      }
      if (options?.PAYLOAD) {
        parser.push("PAYLOAD", options.PAYLOAD);
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGDEL.js
var require_SUGDEL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, string4) {
      parser.push("FT.SUGDEL");
      parser.pushKey(key);
      parser.push(string4);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET.js
var require_SUGGET = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, prefix, options) {
      parser.push("FT.SUGGET");
      parser.pushKey(key);
      parser.push(prefix);
      if (options?.FUZZY) {
        parser.push("FUZZY");
      }
      if (options?.MAX !== undefined) {
        parser.push("MAX", options.MAX.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHPAYLOADS.js
var require_SUGGET_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHPAYLOADS");
    },
    transformReply(reply) {
      if ((0, generic_transformers_1.isNullReply)(reply))
        return null;
      const transformedReply = new Array(reply.length / 2);
      let replyIndex = 0, arrIndex = 0;
      while (replyIndex < reply.length) {
        transformedReply[arrIndex++] = {
          suggestion: reply[replyIndex++],
          payload: reply[replyIndex++]
        };
      }
      return transformedReply;
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES_WITHPAYLOADS.js
var require_SUGGET_WITHSCORES_WITHPAYLOADS = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES", "WITHPAYLOADS");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping),
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 3);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++],
            payload: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGGET_WITHSCORES.js
var require_SUGGET_WITHSCORES = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  var SUGGET_1 = __importDefault(require_SUGGET());
  exports.default = {
    IS_READ_ONLY: SUGGET_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      SUGGET_1.default.parseCommand(...args);
      args[0].push("WITHSCORES");
    },
    transformReply: {
      2: (reply, preserve, typeMapping) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: generic_transformers_1.transformDoubleReply[2](reply[replyIndex++], preserve, typeMapping)
          };
        }
        return transformedReply;
      },
      3: (reply) => {
        if ((0, generic_transformers_1.isNullReply)(reply))
          return null;
        const transformedReply = new Array(reply.length / 2);
        let replyIndex = 0, arrIndex = 0;
        while (replyIndex < reply.length) {
          transformedReply[arrIndex++] = {
            suggestion: reply[replyIndex++],
            score: reply[replyIndex++]
          };
        }
        return transformedReply;
      }
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SUGLEN.js
var require_SUGLEN = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("FT.SUGLEN", key);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/SYNDUMP.js
var require_SYNDUMP = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index) {
      parser.push("FT.SYNDUMP", index);
    },
    transformReply: {
      2: (reply) => {
        const result = {};
        let i = 0;
        while (i < reply.length) {
          const key = reply[i++].toString(), value = reply[i++];
          result[key] = value;
        }
        return result;
      },
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/SYNUPDATE.js
var require_SYNUPDATE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, groupId, terms, options) {
      parser.push("FT.SYNUPDATE", index, groupId);
      if (options?.SKIPINITIALSCAN) {
        parser.push("SKIPINITIALSCAN");
      }
      parser.pushVariadic(terms);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/search/dist/lib/commands/TAGVALS.js
var require_TAGVALS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, index, fieldName) {
      parser.push("FT.TAGVALS", index, fieldName);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/search/dist/lib/commands/index.js
var require_commands5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _LIST_1 = __importDefault(require__LIST());
  var ALTER_1 = __importDefault(require_ALTER());
  var AGGREGATE_WITHCURSOR_1 = __importDefault(require_AGGREGATE_WITHCURSOR());
  var AGGREGATE_1 = __importDefault(require_AGGREGATE());
  var ALIASADD_1 = __importDefault(require_ALIASADD());
  var ALIASDEL_1 = __importDefault(require_ALIASDEL());
  var ALIASUPDATE_1 = __importDefault(require_ALIASUPDATE());
  var CONFIG_GET_1 = __importDefault(require_CONFIG_GET2());
  var CONFIG_SET_1 = __importDefault(require_CONFIG_SET2());
  var CREATE_1 = __importDefault(require_CREATE2());
  var CURSOR_DEL_1 = __importDefault(require_CURSOR_DEL());
  var CURSOR_READ_1 = __importDefault(require_CURSOR_READ());
  var DICTADD_1 = __importDefault(require_DICTADD());
  var DICTDEL_1 = __importDefault(require_DICTDEL());
  var DICTDUMP_1 = __importDefault(require_DICTDUMP());
  var DROPINDEX_1 = __importDefault(require_DROPINDEX());
  var EXPLAIN_1 = __importDefault(require_EXPLAIN());
  var EXPLAINCLI_1 = __importDefault(require_EXPLAINCLI());
  var INFO_1 = __importDefault(require_INFO7());
  var PROFILE_SEARCH_1 = __importDefault(require_PROFILE_SEARCH());
  var PROFILE_AGGREGATE_1 = __importDefault(require_PROFILE_AGGREGATE());
  var SEARCH_NOCONTENT_1 = __importDefault(require_SEARCH_NOCONTENT());
  var SEARCH_1 = __importDefault(require_SEARCH());
  var SPELLCHECK_1 = __importDefault(require_SPELLCHECK());
  var SUGADD_1 = __importDefault(require_SUGADD());
  var SUGDEL_1 = __importDefault(require_SUGDEL());
  var SUGGET_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHPAYLOADS());
  var SUGGET_WITHSCORES_WITHPAYLOADS_1 = __importDefault(require_SUGGET_WITHSCORES_WITHPAYLOADS());
  var SUGGET_WITHSCORES_1 = __importDefault(require_SUGGET_WITHSCORES());
  var SUGGET_1 = __importDefault(require_SUGGET());
  var SUGLEN_1 = __importDefault(require_SUGLEN());
  var SYNDUMP_1 = __importDefault(require_SYNDUMP());
  var SYNUPDATE_1 = __importDefault(require_SYNUPDATE());
  var TAGVALS_1 = __importDefault(require_TAGVALS());
  exports.default = {
    _LIST: _LIST_1.default,
    _list: _LIST_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    AGGREGATE_WITHCURSOR: AGGREGATE_WITHCURSOR_1.default,
    aggregateWithCursor: AGGREGATE_WITHCURSOR_1.default,
    AGGREGATE: AGGREGATE_1.default,
    aggregate: AGGREGATE_1.default,
    ALIASADD: ALIASADD_1.default,
    aliasAdd: ALIASADD_1.default,
    ALIASDEL: ALIASDEL_1.default,
    aliasDel: ALIASDEL_1.default,
    ALIASUPDATE: ALIASUPDATE_1.default,
    aliasUpdate: ALIASUPDATE_1.default,
    CONFIG_GET: CONFIG_GET_1.default,
    configGet: CONFIG_GET_1.default,
    CONFIG_SET: CONFIG_SET_1.default,
    configSet: CONFIG_SET_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CURSOR_DEL: CURSOR_DEL_1.default,
    cursorDel: CURSOR_DEL_1.default,
    CURSOR_READ: CURSOR_READ_1.default,
    cursorRead: CURSOR_READ_1.default,
    DICTADD: DICTADD_1.default,
    dictAdd: DICTADD_1.default,
    DICTDEL: DICTDEL_1.default,
    dictDel: DICTDEL_1.default,
    DICTDUMP: DICTDUMP_1.default,
    dictDump: DICTDUMP_1.default,
    DROPINDEX: DROPINDEX_1.default,
    dropIndex: DROPINDEX_1.default,
    EXPLAIN: EXPLAIN_1.default,
    explain: EXPLAIN_1.default,
    EXPLAINCLI: EXPLAINCLI_1.default,
    explainCli: EXPLAINCLI_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    PROFILESEARCH: PROFILE_SEARCH_1.default,
    profileSearch: PROFILE_SEARCH_1.default,
    PROFILEAGGREGATE: PROFILE_AGGREGATE_1.default,
    profileAggregate: PROFILE_AGGREGATE_1.default,
    SEARCH_NOCONTENT: SEARCH_NOCONTENT_1.default,
    searchNoContent: SEARCH_NOCONTENT_1.default,
    SEARCH: SEARCH_1.default,
    search: SEARCH_1.default,
    SPELLCHECK: SPELLCHECK_1.default,
    spellCheck: SPELLCHECK_1.default,
    SUGADD: SUGADD_1.default,
    sugAdd: SUGADD_1.default,
    SUGDEL: SUGDEL_1.default,
    sugDel: SUGDEL_1.default,
    SUGGET_WITHPAYLOADS: SUGGET_WITHPAYLOADS_1.default,
    sugGetWithPayloads: SUGGET_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES_WITHPAYLOADS: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    sugGetWithScoresWithPayloads: SUGGET_WITHSCORES_WITHPAYLOADS_1.default,
    SUGGET_WITHSCORES: SUGGET_WITHSCORES_1.default,
    sugGetWithScores: SUGGET_WITHSCORES_1.default,
    SUGGET: SUGGET_1.default,
    sugGet: SUGGET_1.default,
    SUGLEN: SUGLEN_1.default,
    sugLen: SUGLEN_1.default,
    SYNDUMP: SYNDUMP_1.default,
    synDump: SYNDUMP_1.default,
    SYNUPDATE: SYNUPDATE_1.default,
    synUpdate: SYNUPDATE_1.default,
    TAGVALS: TAGVALS_1.default,
    tagVals: TAGVALS_1.default
  };
});

// node_modules/@redis/search/dist/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FT_AGGREGATE_STEPS = exports.FT_AGGREGATE_GROUP_BY_REDUCERS = exports.SCHEMA_VECTOR_FIELD_ALGORITHM = exports.SCHEMA_TEXT_FIELD_PHONETIC = exports.SCHEMA_FIELD_TYPE = exports.REDISEARCH_LANGUAGE = exports.default = undefined;
  var commands_1 = require_commands5();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  var CREATE_1 = require_CREATE2();
  Object.defineProperty(exports, "REDISEARCH_LANGUAGE", { enumerable: true, get: function() {
    return CREATE_1.REDISEARCH_LANGUAGE;
  } });
  Object.defineProperty(exports, "SCHEMA_FIELD_TYPE", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_FIELD_TYPE;
  } });
  Object.defineProperty(exports, "SCHEMA_TEXT_FIELD_PHONETIC", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_TEXT_FIELD_PHONETIC;
  } });
  Object.defineProperty(exports, "SCHEMA_VECTOR_FIELD_ALGORITHM", { enumerable: true, get: function() {
    return CREATE_1.SCHEMA_VECTOR_FIELD_ALGORITHM;
  } });
  var AGGREGATE_1 = require_AGGREGATE();
  Object.defineProperty(exports, "FT_AGGREGATE_GROUP_BY_REDUCERS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_GROUP_BY_REDUCERS;
  } });
  Object.defineProperty(exports, "FT_AGGREGATE_STEPS", { enumerable: true, get: function() {
    return AGGREGATE_1.FT_AGGREGATE_STEPS;
  } });
});

// node_modules/@redis/time-series/dist/lib/commands/helpers.js
var require_helpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRESP2LabelsWithSources = exports.transformRESP2Labels = exports.parseSelectedLabelsArguments = exports.resp3MapToValue = exports.resp2MapToValue = exports.transformSamplesReply = exports.transformSampleReply = exports.parseLabelsArgument = exports.transformTimestampArgument = exports.parseDuplicatePolicy = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.parseChunkSizeArgument = exports.parseEncodingArgument = exports.TIME_SERIES_ENCODING = exports.parseRetentionArgument = exports.parseIgnoreArgument = undefined;
  var client_1 = require_dist();
  function parseIgnoreArgument(parser, ignore) {
    if (ignore !== undefined) {
      parser.push("IGNORE", ignore.maxTimeDiff.toString(), ignore.maxValDiff.toString());
    }
  }
  exports.parseIgnoreArgument = parseIgnoreArgument;
  function parseRetentionArgument(parser, retention) {
    if (retention !== undefined) {
      parser.push("RETENTION", retention.toString());
    }
  }
  exports.parseRetentionArgument = parseRetentionArgument;
  exports.TIME_SERIES_ENCODING = {
    COMPRESSED: "COMPRESSED",
    UNCOMPRESSED: "UNCOMPRESSED"
  };
  function parseEncodingArgument(parser, encoding) {
    if (encoding !== undefined) {
      parser.push("ENCODING", encoding);
    }
  }
  exports.parseEncodingArgument = parseEncodingArgument;
  function parseChunkSizeArgument(parser, chunkSize) {
    if (chunkSize !== undefined) {
      parser.push("CHUNK_SIZE", chunkSize.toString());
    }
  }
  exports.parseChunkSizeArgument = parseChunkSizeArgument;
  exports.TIME_SERIES_DUPLICATE_POLICIES = {
    BLOCK: "BLOCK",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM"
  };
  function parseDuplicatePolicy(parser, duplicatePolicy) {
    if (duplicatePolicy !== undefined) {
      parser.push("DUPLICATE_POLICY", duplicatePolicy);
    }
  }
  exports.parseDuplicatePolicy = parseDuplicatePolicy;
  function transformTimestampArgument(timestamp) {
    if (typeof timestamp === "string")
      return timestamp;
    return (typeof timestamp === "number" ? timestamp : timestamp.getTime()).toString();
  }
  exports.transformTimestampArgument = transformTimestampArgument;
  function parseLabelsArgument(parser, labels) {
    if (labels) {
      parser.push("LABELS");
      for (const [label, value] of Object.entries(labels)) {
        parser.push(label, value);
      }
    }
  }
  exports.parseLabelsArgument = parseLabelsArgument;
  exports.transformSampleReply = {
    2(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value: Number(value)
      };
    },
    3(reply) {
      const [timestamp, value] = reply;
      return {
        timestamp,
        value
      };
    }
  };
  exports.transformSamplesReply = {
    2(reply) {
      return reply.map((sample) => exports.transformSampleReply[2](sample));
    },
    3(reply) {
      return reply.map((sample) => exports.transformSampleReply[3](sample));
    }
  };
  function resp2MapToValue(wrappedReply, parseFunc, typeMapping) {
    const reply = wrappedReply;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map: {
        const ret = new Map;
        for (const wrappedTuple of reply) {
          const tuple2 = wrappedTuple;
          const key = tuple2[0];
          ret.set(key.toString(), parseFunc(tuple2));
        }
        return ret;
      }
      case Array: {
        for (const wrappedTuple of reply) {
          const tuple2 = wrappedTuple;
          tuple2[1] = parseFunc(tuple2);
        }
        return reply;
      }
      default: {
        const ret = Object.create(null);
        for (const wrappedTuple of reply) {
          const tuple2 = wrappedTuple;
          const key = tuple2[0];
          ret[key.toString()] = parseFunc(tuple2);
        }
        return ret;
      }
    }
  }
  exports.resp2MapToValue = resp2MapToValue;
  function resp3MapToValue(wrappedReply, parseFunc) {
    const reply = wrappedReply;
    if (reply instanceof Array) {
      for (let i = 1;i < reply.length; i += 2) {
        reply[i] = parseFunc(reply[i]);
      }
    } else if (reply instanceof Map) {
      for (const [key, value] of reply.entries()) {
        reply.set(key, parseFunc(value));
      }
    } else {
      for (const [key, value] of Object.entries(reply)) {
        reply[key] = parseFunc(value);
      }
    }
    return reply;
  }
  exports.resp3MapToValue = resp3MapToValue;
  function parseSelectedLabelsArguments(parser, selectedLabels) {
    parser.push("SELECTED_LABELS");
    parser.pushVariadic(selectedLabels);
  }
  exports.parseSelectedLabelsArguments = parseSelectedLabelsArguments;
  function transformRESP2Labels(labels, typeMapping) {
    const unwrappedLabels = labels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map2 = new Map;
        for (const tuple2 of unwrappedLabels) {
          const [key, value] = tuple2;
          const unwrappedKey = key;
          map2.set(unwrappedKey.toString(), value);
        }
        return map2;
      case Array:
        return unwrappedLabels.flat();
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (const tuple2 of unwrappedLabels) {
          const [key, value] = tuple2;
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        return labelsObject;
    }
  }
  exports.transformRESP2Labels = transformRESP2Labels;
  function transformRESP2LabelsWithSources(labels, typeMapping) {
    const unwrappedLabels = labels;
    const to = unwrappedLabels.length - 2;
    let transformedLabels;
    switch (typeMapping?.[client_1.RESP_TYPES.MAP]) {
      case Map:
        const map2 = new Map;
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          map2.set(unwrappedKey.toString(), value);
        }
        transformedLabels = map2;
        break;
      case Array:
        transformedLabels = unwrappedLabels.slice(0, to).flat();
        break;
      case Object:
      default:
        const labelsObject = Object.create(null);
        for (let i = 0;i < to; i++) {
          const [key, value] = unwrappedLabels[i];
          const unwrappedKey = key;
          labelsObject[unwrappedKey.toString()] = value;
        }
        transformedLabels = labelsObject;
        break;
    }
    const sourcesTuple = unwrappedLabels[unwrappedLabels.length - 1];
    const unwrappedSourcesTuple = sourcesTuple;
    const transformedSources = transformRESP2Sources(unwrappedSourcesTuple[1]);
    return {
      labels: transformedLabels,
      sources: transformedSources
    };
  }
  exports.transformRESP2LabelsWithSources = transformRESP2LabelsWithSources;
  function transformRESP2Sources(sourcesRaw) {
    const unwrappedSources = sourcesRaw;
    if (typeof unwrappedSources === "string") {
      return unwrappedSources.split(",");
    }
    const indexOfComma = unwrappedSources.indexOf(",");
    if (indexOfComma === -1) {
      return [unwrappedSources];
    }
    const sourcesArray = [
      unwrappedSources.subarray(0, indexOfComma)
    ];
    let previousComma = indexOfComma + 1;
    while (true) {
      const indexOf = unwrappedSources.indexOf(",", previousComma);
      if (indexOf === -1) {
        sourcesArray.push(unwrappedSources.subarray(previousComma));
        break;
      }
      const source = unwrappedSources.subarray(previousComma, indexOf);
      sourcesArray.push(source);
      previousComma = indexOf + 1;
    }
    return sourcesArray;
  }
});

// node_modules/@redis/time-series/dist/lib/commands/ADD.js
var require_ADD5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, timestamp, value, options) {
      parser.push("TS.ADD");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      if (options?.ON_DUPLICATE) {
        parser.push("ON_DUPLICATE", options.ON_DUPLICATE);
      }
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/ALTER.js
var require_ALTER2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.ALTER");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/CREATE.js
var require_CREATE3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, options) {
      parser.push("TS.CREATE");
      parser.pushKey(key);
      (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
      (0, helpers_1.parseEncodingArgument)(parser, options?.ENCODING);
      (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
      (0, helpers_1.parseDuplicatePolicy)(parser, options?.DUPLICATE_POLICY);
      (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
      (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/CREATERULE.js
var require_CREATERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_AGGREGATION_TYPE = undefined;
  exports.TIME_SERIES_AGGREGATION_TYPE = {
    AVG: "AVG",
    FIRST: "FIRST",
    LAST: "LAST",
    MIN: "MIN",
    MAX: "MAX",
    SUM: "SUM",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S",
    TWA: "TWA"
  };
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey, aggregationType, bucketDuration, alignTimestamp) {
      parser.push("TS.CREATERULE");
      parser.pushKeys([sourceKey, destinationKey]);
      parser.push("AGGREGATION", aggregationType, bucketDuration.toString());
      if (alignTimestamp !== undefined) {
        parser.push(alignTimestamp.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INCRBY.js
var require_INCRBY4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseIncrByArguments = undefined;
  var helpers_1 = require_helpers2();
  function parseIncrByArguments(parser, key, value, options) {
    parser.pushKey(key);
    parser.push(value.toString());
    if (options?.TIMESTAMP !== undefined && options?.TIMESTAMP !== null) {
      parser.push("TIMESTAMP", (0, helpers_1.transformTimestampArgument)(options.TIMESTAMP));
    }
    (0, helpers_1.parseRetentionArgument)(parser, options?.RETENTION);
    if (options?.UNCOMPRESSED) {
      parser.push("UNCOMPRESSED");
    }
    (0, helpers_1.parseChunkSizeArgument)(parser, options?.CHUNK_SIZE);
    (0, helpers_1.parseLabelsArgument)(parser, options?.LABELS);
    (0, helpers_1.parseIgnoreArgument)(parser, options?.IGNORE);
  }
  exports.parseIncrByArguments = parseIncrByArguments;
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.INCRBY");
      parseIncrByArguments(...args);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DECRBY.js
var require_DECRBY2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INCRBY_1 = __importStar(require_INCRBY4());
  exports.default = {
    IS_READ_ONLY: INCRBY_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.DECRBY");
      (0, INCRBY_1.parseIncrByArguments)(...args);
    },
    transformReply: INCRBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DEL.js
var require_DEL4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, key, fromTimestamp, toTimestamp) {
      parser.push("TS.DEL");
      parser.pushKey(key);
      parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/DELETERULE.js
var require_DELETERULE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, sourceKey, destinationKey) {
      parser.push("TS.DELETERULE");
      parser.pushKeys([sourceKey, destinationKey]);
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/GET.js
var require_GET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key, options) {
      parser.push("TS.GET");
      parser.pushKey(key);
      if (options?.LATEST) {
        parser.push("LATEST");
      }
    },
    transformReply: {
      2(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: Number(reply[1])
        };
      },
      3(reply) {
        return reply.length === 0 ? null : {
          timestamp: reply[0],
          value: reply[1]
        };
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INFO.js
var require_INFO8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var generic_transformers_1 = require_generic_transformers();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, key) {
      parser.push("TS.INFO");
      parser.pushKey(key);
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = {};
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "totalSamples":
            case "memoryUsage":
            case "firstTimestamp":
            case "lastTimestamp":
            case "retentionTime":
            case "chunkCount":
            case "chunkSize":
            case "chunkType":
            case "duplicatePolicy":
            case "sourceKey":
            case "ignoreMaxTimeDiff":
              ret[key] = reply[i + 1];
              break;
            case "labels":
              ret[key] = reply[i + 1].map(([name, value]) => ({
                name,
                value
              }));
              break;
            case "rules":
              ret[key] = reply[i + 1].map(([key2, timeBucket, aggregationType]) => ({
                key: key2,
                timeBucket,
                aggregationType
              }));
              break;
            case "ignoreMaxValDiff":
              ret[key] = generic_transformers_1.transformDoubleReply[2](reply[27], undefined, typeMapping);
              break;
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/time-series/dist/lib/commands/INFO_DEBUG.js
var require_INFO_DEBUG = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var INFO_1 = __importDefault(require_INFO8());
  exports.default = {
    IS_READ_ONLY: INFO_1.default.IS_READ_ONLY,
    parseCommand(parser, key) {
      INFO_1.default.parseCommand(parser, key);
      parser.push("DEBUG");
    },
    transformReply: {
      2: (reply, _, typeMapping) => {
        const ret = INFO_1.default.transformReply[2](reply, _, typeMapping);
        for (let i = 0;i < reply.length; i += 2) {
          const key = reply[i].toString();
          switch (key) {
            case "keySelfName": {
              ret[key] = reply[i + 1];
              break;
            }
            case "Chunks": {
              ret["chunks"] = reply[i + 1].map((chunk) => ({
                startTimestamp: chunk[1],
                endTimestamp: chunk[3],
                samples: chunk[5],
                size: chunk[7],
                bytesPerSample: chunk[9]
              }));
              break;
            }
          }
        }
        return ret;
      },
      3: undefined
    },
    unstableResp3: true
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MADD.js
var require_MADD2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var helpers_1 = require_helpers2();
  exports.default = {
    IS_READ_ONLY: false,
    parseCommand(parser, toAdd) {
      parser.push("TS.MADD");
      for (const { key, timestamp, value } of toAdd) {
        parser.pushKey(key);
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp), value.toString());
      }
    },
    transformReply: undefined
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET.js
var require_MGET3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseFilterArgument = exports.parseLatestArgument = undefined;
  var helpers_1 = require_helpers2();
  function parseLatestArgument(parser, latest) {
    if (latest) {
      parser.push("LATEST");
    }
  }
  exports.parseLatestArgument = parseLatestArgument;
  function parseFilterArgument(parser, filter) {
    parser.push("FILTER");
    parser.pushVariadic(filter);
  }
  exports.parseFilterArgument = parseFilterArgument;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter, options) {
      parser.push("TS.MGET");
      parseLatestArgument(parser, options?.LATEST);
      parseFilterArgument(parser, filter);
    },
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, , sample]) => {
          return {
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([, sample]) => {
          return {
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET_WITHLABELS.js
var require_MGET_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMGetLabelsReply = undefined;
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers2();
  function createTransformMGetLabelsReply() {
    return {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([, labels, sample]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels),
            sample: helpers_1.transformSampleReply[2](sample)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, sample]) => {
          return {
            labels,
            sample: helpers_1.transformSampleReply[3](sample)
          };
        });
      }
    };
  }
  exports.createTransformMGetLabelsReply = createTransformMGetLabelsReply;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
    },
    transformReply: createTransformMGetLabelsReply()
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MGET_SELECTED_LABELS.js
var require_MGET_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var MGET_1 = require_MGET3();
  var helpers_1 = require_helpers2();
  var MGET_WITHLABELS_1 = require_MGET_WITHLABELS();
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(parser, filter, selectedLabels, options) {
      parser.push("TS.MGET");
      (0, MGET_1.parseLatestArgument)(parser, options?.LATEST);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    },
    transformReply: (0, MGET_WITHLABELS_1.createTransformMGetLabelsReply)()
  };
});

// node_modules/@redis/time-series/dist/lib/commands/RANGE.js
var require_RANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.transformRangeArguments = exports.parseRangeArguments = exports.TIME_SERIES_BUCKET_TIMESTAMP = undefined;
  var helpers_1 = require_helpers2();
  exports.TIME_SERIES_BUCKET_TIMESTAMP = {
    LOW: "-",
    MIDDLE: "~",
    END: "+"
  };
  function parseRangeArguments(parser, fromTimestamp, toTimestamp, options) {
    parser.push((0, helpers_1.transformTimestampArgument)(fromTimestamp), (0, helpers_1.transformTimestampArgument)(toTimestamp));
    if (options?.LATEST) {
      parser.push("LATEST");
    }
    if (options?.FILTER_BY_TS) {
      parser.push("FILTER_BY_TS");
      for (const timestamp of options.FILTER_BY_TS) {
        parser.push((0, helpers_1.transformTimestampArgument)(timestamp));
      }
    }
    if (options?.FILTER_BY_VALUE) {
      parser.push("FILTER_BY_VALUE", options.FILTER_BY_VALUE.min.toString(), options.FILTER_BY_VALUE.max.toString());
    }
    if (options?.COUNT !== undefined) {
      parser.push("COUNT", options.COUNT.toString());
    }
    if (options?.AGGREGATION) {
      if (options?.ALIGN !== undefined) {
        parser.push("ALIGN", (0, helpers_1.transformTimestampArgument)(options.ALIGN));
      }
      parser.push("AGGREGATION", options.AGGREGATION.type, (0, helpers_1.transformTimestampArgument)(options.AGGREGATION.timeBucket));
      if (options.AGGREGATION.BUCKETTIMESTAMP) {
        parser.push("BUCKETTIMESTAMP", options.AGGREGATION.BUCKETTIMESTAMP);
      }
      if (options.AGGREGATION.EMPTY) {
        parser.push("EMPTY");
      }
    }
  }
  exports.parseRangeArguments = parseRangeArguments;
  function transformRangeArguments(parser, key, fromTimestamp, toTimestamp, options) {
    parser.pushKey(key);
    parseRangeArguments(parser, fromTimestamp, toTimestamp, options);
  }
  exports.transformRangeArguments = transformRangeArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.RANGE");
      transformRangeArguments(...args);
    },
    transformReply: {
      2(reply) {
        return helpers_1.transformSamplesReply[2](reply);
      },
      3(reply) {
        return helpers_1.transformSamplesReply[3](reply);
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_GROUPBY.js
var require_MRANGE_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractResp3MRangeSources = exports.createTransformMRangeGroupByArguments = exports.parseGroupByArguments = exports.TIME_SERIES_REDUCERS = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  exports.TIME_SERIES_REDUCERS = {
    AVG: "AVG",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    RANGE: "RANGE",
    COUNT: "COUNT",
    STD_P: "STD.P",
    STD_S: "STD.S",
    VAR_P: "VAR.P",
    VAR_S: "VAR.S"
  };
  function parseGroupByArguments(parser, groupBy) {
    parser.push("GROUPBY", groupBy.label, "REDUCE", groupBy.REDUCE);
  }
  exports.parseGroupByArguments = parseGroupByArguments;
  function createTransformMRangeGroupByArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter);
      parseGroupByArguments(parser, groupBy);
    };
  }
  exports.createTransformMRangeGroupByArguments = createTransformMRangeGroupByArguments;
  function extractResp3MRangeSources(raw2) {
    const unwrappedMetadata2 = raw2;
    if (unwrappedMetadata2 instanceof Map) {
      return unwrappedMetadata2.get("sources");
    } else if (unwrappedMetadata2 instanceof Array) {
      return unwrappedMetadata2[1];
    } else {
      return unwrappedMetadata2.sources;
    }
  }
  exports.extractResp3MRangeSources = extractResp3MRangeSources;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeGroupByArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key2, _labels, samples]) => {
          return {
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata1, metadata2, samples]) => {
          return {
            sources: extractResp3MRangeSources(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS.js
var require_MRANGE_SELECTED_LABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeSelectedLabelsArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeSelectedLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeSelectedLabelsArguments = createTransformMRangeSelectedLabelsArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeSelectedLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key2, labels, samples]) => {
          return {
            labels: (0, helpers_1.transformRESP2Labels)(labels, typeMapping),
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_key2, labels, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_SELECTED_LABELS_GROUPBY.js
var require_MRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeSelectedLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  function createMRangeSelectedLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, selectedLabels, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, helpers_1.parseSelectedLabelsArguments)(parser, selectedLabels);
      (0, MGET_1.parseFilterArgument)(parser, filter);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeSelectedLabelsGroupByTransformArguments = createMRangeSelectedLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeSelectedLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2: MRANGE_SELECTED_LABELS_1.default.transformReply[2],
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS_GROUPBY.js
var require_MRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMRangeWithLabelsGroupByTransformArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  var MGET_1 = require_MGET3();
  function createMRangeWithLabelsGroupByTransformArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, groupBy, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
      (0, MRANGE_GROUPBY_1.parseGroupByArguments)(parser, groupBy);
    };
  }
  exports.createMRangeWithLabelsGroupByTransformArguments = createMRangeWithLabelsGroupByTransformArguments;
  exports.default = {
    IS_READ_ONLY: true,
    parseCommand: createMRangeWithLabelsGroupByTransformArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key2, labels, samples]) => {
          const transformed = (0, helpers_1.transformRESP2LabelsWithSources)(labels);
          return {
            labels: transformed.labels,
            sources: transformed.sources,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, metadata2, samples]) => {
          return {
            labels,
            sources: (0, MRANGE_GROUPBY_1.extractResp3MRangeSources)(metadata2),
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE_WITHLABELS.js
var require_MRANGE_WITHLABELS = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeWithLabelsArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeWithLabelsArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      parser.push("WITHLABELS");
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeWithLabelsArguments = createTransformMRangeWithLabelsArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeWithLabelsArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key2, labels, samples]) => {
          const unwrappedLabels = labels;
          const labelsObject = Object.create(null);
          for (const tuple2 of unwrappedLabels) {
            const [key, value] = tuple2;
            const unwrappedKey = key;
            labelsObject[unwrappedKey.toString()] = value;
          }
          return {
            labels: labelsObject,
            samples: helpers_1.transformSamplesReply[2](samples)
          };
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([labels, _metadata, samples]) => {
          return {
            labels,
            samples: helpers_1.transformSamplesReply[3](samples)
          };
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MRANGE.js
var require_MRANGE = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTransformMRangeArguments = undefined;
  var helpers_1 = require_helpers2();
  var RANGE_1 = require_RANGE();
  var MGET_1 = require_MGET3();
  function createTransformMRangeArguments(command) {
    return (parser, fromTimestamp, toTimestamp, filter, options) => {
      parser.push(command);
      (0, RANGE_1.parseRangeArguments)(parser, fromTimestamp, toTimestamp, options);
      (0, MGET_1.parseFilterArgument)(parser, filter);
    };
  }
  exports.createTransformMRangeArguments = createTransformMRangeArguments;
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand: createTransformMRangeArguments("TS.MRANGE"),
    transformReply: {
      2(reply, _, typeMapping) {
        return (0, helpers_1.resp2MapToValue)(reply, ([_key2, _labels, samples]) => {
          return helpers_1.transformSamplesReply[2](samples);
        }, typeMapping);
      },
      3(reply) {
        return (0, helpers_1.resp3MapToValue)(reply, ([_labels, _metadata, samples]) => {
          return helpers_1.transformSamplesReply[3](samples);
        });
      }
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_GROUPBY.js
var require_MREVRANGE_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_GROUPBY_1 = __importStar(require_MRANGE_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_GROUPBY_1.createTransformMRangeGroupByArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS_GROUPBY.js
var require_MREVRANGE_SELECTED_LABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importStar(require_MRANGE_SELECTED_LABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_GROUPBY_1.createMRangeSelectedLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_SELECTED_LABELS.js
var require_MREVRANGE_SELECTED_LABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_SELECTED_LABELS_1 = __importStar(require_MRANGE_SELECTED_LABELS());
  exports.default = {
    IS_READ_ONLY: MRANGE_SELECTED_LABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_SELECTED_LABELS_1.createTransformMRangeSelectedLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_SELECTED_LABELS_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS_GROUPBY.js
var require_MREVRANGE_WITHLABELS_GROUPBY = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_GROUPBY_1 = __importStar(require_MRANGE_WITHLABELS_GROUPBY());
  exports.default = {
    IS_READ_ONLY: MRANGE_WITHLABELS_GROUPBY_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_GROUPBY_1.createMRangeWithLabelsGroupByTransformArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_GROUPBY_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE_WITHLABELS.js
var require_MREVRANGE_WITHLABELS = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_WITHLABELS_1 = __importStar(require_MRANGE_WITHLABELS());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_WITHLABELS_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_WITHLABELS_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_WITHLABELS_1.createTransformMRangeWithLabelsArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_WITHLABELS_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/MREVRANGE.js
var require_MREVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var MRANGE_1 = __importStar(require_MRANGE());
  exports.default = {
    NOT_KEYED_COMMAND: MRANGE_1.default.NOT_KEYED_COMMAND,
    IS_READ_ONLY: MRANGE_1.default.IS_READ_ONLY,
    parseCommand: (0, MRANGE_1.createTransformMRangeArguments)("TS.MREVRANGE"),
    transformReply: MRANGE_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/QUERYINDEX.js
var require_QUERYINDEX = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {
    NOT_KEYED_COMMAND: true,
    IS_READ_ONLY: true,
    parseCommand(parser, filter) {
      parser.push("TS.QUERYINDEX");
      parser.pushVariadic(filter);
    },
    transformReply: {
      2: undefined,
      3: undefined
    }
  };
});

// node_modules/@redis/time-series/dist/lib/commands/REVRANGE.js
var require_REVRANGE = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var RANGE_1 = __importStar(require_RANGE());
  exports.default = {
    IS_READ_ONLY: RANGE_1.default.IS_READ_ONLY,
    parseCommand(...args) {
      const parser = args[0];
      parser.push("TS.REVRANGE");
      (0, RANGE_1.transformRangeArguments)(...args);
    },
    transformReply: RANGE_1.default.transformReply
  };
});

// node_modules/@redis/time-series/dist/lib/commands/index.js
var require_commands6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var ADD_1 = __importDefault(require_ADD5());
  var ALTER_1 = __importDefault(require_ALTER2());
  var CREATE_1 = __importDefault(require_CREATE3());
  var CREATERULE_1 = __importDefault(require_CREATERULE());
  var DECRBY_1 = __importDefault(require_DECRBY2());
  var DEL_1 = __importDefault(require_DEL4());
  var DELETERULE_1 = __importDefault(require_DELETERULE());
  var GET_1 = __importDefault(require_GET3());
  var INCRBY_1 = __importDefault(require_INCRBY4());
  var INFO_DEBUG_1 = __importDefault(require_INFO_DEBUG());
  var INFO_1 = __importDefault(require_INFO8());
  var MADD_1 = __importDefault(require_MADD2());
  var MGET_SELECTED_LABELS_1 = __importDefault(require_MGET_SELECTED_LABELS());
  var MGET_WITHLABELS_1 = __importDefault(require_MGET_WITHLABELS());
  var MGET_1 = __importDefault(require_MGET3());
  var MRANGE_GROUPBY_1 = __importDefault(require_MRANGE_GROUPBY());
  var MRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MRANGE_SELECTED_LABELS_GROUPBY());
  var MRANGE_SELECTED_LABELS_1 = __importDefault(require_MRANGE_SELECTED_LABELS());
  var MRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MRANGE_WITHLABELS_GROUPBY());
  var MRANGE_WITHLABELS_1 = __importDefault(require_MRANGE_WITHLABELS());
  var MRANGE_1 = __importDefault(require_MRANGE());
  var MREVRANGE_GROUPBY_1 = __importDefault(require_MREVRANGE_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS_GROUPBY());
  var MREVRANGE_SELECTED_LABELS_1 = __importDefault(require_MREVRANGE_SELECTED_LABELS());
  var MREVRANGE_WITHLABELS_GROUPBY_1 = __importDefault(require_MREVRANGE_WITHLABELS_GROUPBY());
  var MREVRANGE_WITHLABELS_1 = __importDefault(require_MREVRANGE_WITHLABELS());
  var MREVRANGE_1 = __importDefault(require_MREVRANGE());
  var QUERYINDEX_1 = __importDefault(require_QUERYINDEX());
  var RANGE_1 = __importDefault(require_RANGE());
  var REVRANGE_1 = __importDefault(require_REVRANGE());
  __exportStar(require_helpers2(), exports);
  exports.default = {
    ADD: ADD_1.default,
    add: ADD_1.default,
    ALTER: ALTER_1.default,
    alter: ALTER_1.default,
    CREATE: CREATE_1.default,
    create: CREATE_1.default,
    CREATERULE: CREATERULE_1.default,
    createRule: CREATERULE_1.default,
    DECRBY: DECRBY_1.default,
    decrBy: DECRBY_1.default,
    DEL: DEL_1.default,
    del: DEL_1.default,
    DELETERULE: DELETERULE_1.default,
    deleteRule: DELETERULE_1.default,
    GET: GET_1.default,
    get: GET_1.default,
    INCRBY: INCRBY_1.default,
    incrBy: INCRBY_1.default,
    INFO_DEBUG: INFO_DEBUG_1.default,
    infoDebug: INFO_DEBUG_1.default,
    INFO: INFO_1.default,
    info: INFO_1.default,
    MADD: MADD_1.default,
    mAdd: MADD_1.default,
    MGET_SELECTED_LABELS: MGET_SELECTED_LABELS_1.default,
    mGetSelectedLabels: MGET_SELECTED_LABELS_1.default,
    MGET_WITHLABELS: MGET_WITHLABELS_1.default,
    mGetWithLabels: MGET_WITHLABELS_1.default,
    MGET: MGET_1.default,
    mGet: MGET_1.default,
    MRANGE_GROUPBY: MRANGE_GROUPBY_1.default,
    mRangeGroupBy: MRANGE_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS_GROUPBY: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRangeSelectedLabelsGroupBy: MRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MRANGE_SELECTED_LABELS: MRANGE_SELECTED_LABELS_1.default,
    mRangeSelectedLabels: MRANGE_SELECTED_LABELS_1.default,
    MRANGE_WITHLABELS_GROUPBY: MRANGE_WITHLABELS_GROUPBY_1.default,
    mRangeWithLabelsGroupBy: MRANGE_WITHLABELS_GROUPBY_1.default,
    MRANGE_WITHLABELS: MRANGE_WITHLABELS_1.default,
    mRangeWithLabels: MRANGE_WITHLABELS_1.default,
    MRANGE: MRANGE_1.default,
    mRange: MRANGE_1.default,
    MREVRANGE_GROUPBY: MREVRANGE_GROUPBY_1.default,
    mRevRangeGroupBy: MREVRANGE_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS_GROUPBY: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    mRevRangeSelectedLabelsGroupBy: MREVRANGE_SELECTED_LABELS_GROUPBY_1.default,
    MREVRANGE_SELECTED_LABELS: MREVRANGE_SELECTED_LABELS_1.default,
    mRevRangeSelectedLabels: MREVRANGE_SELECTED_LABELS_1.default,
    MREVRANGE_WITHLABELS_GROUPBY: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    mRevRangeWithLabelsGroupBy: MREVRANGE_WITHLABELS_GROUPBY_1.default,
    MREVRANGE_WITHLABELS: MREVRANGE_WITHLABELS_1.default,
    mRevRangeWithLabels: MREVRANGE_WITHLABELS_1.default,
    MREVRANGE: MREVRANGE_1.default,
    mRevRange: MREVRANGE_1.default,
    QUERYINDEX: QUERYINDEX_1.default,
    queryIndex: QUERYINDEX_1.default,
    RANGE: RANGE_1.default,
    range: RANGE_1.default,
    REVRANGE: REVRANGE_1.default,
    revRange: REVRANGE_1.default
  };
});

// node_modules/@redis/time-series/dist/lib/index.js
var require_lib5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TIME_SERIES_REDUCERS = exports.TIME_SERIES_BUCKET_TIMESTAMP = exports.TIME_SERIES_AGGREGATION_TYPE = exports.TIME_SERIES_DUPLICATE_POLICIES = exports.TIME_SERIES_ENCODING = exports.default = undefined;
  var commands_1 = require_commands6();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return __importDefault(commands_1).default;
  } });
  Object.defineProperty(exports, "TIME_SERIES_ENCODING", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_ENCODING;
  } });
  Object.defineProperty(exports, "TIME_SERIES_DUPLICATE_POLICIES", { enumerable: true, get: function() {
    return commands_1.TIME_SERIES_DUPLICATE_POLICIES;
  } });
  var CREATERULE_1 = require_CREATERULE();
  Object.defineProperty(exports, "TIME_SERIES_AGGREGATION_TYPE", { enumerable: true, get: function() {
    return CREATERULE_1.TIME_SERIES_AGGREGATION_TYPE;
  } });
  var RANGE_1 = require_RANGE();
  Object.defineProperty(exports, "TIME_SERIES_BUCKET_TIMESTAMP", { enumerable: true, get: function() {
    return RANGE_1.TIME_SERIES_BUCKET_TIMESTAMP;
  } });
  var MRANGE_GROUPBY_1 = require_MRANGE_GROUPBY();
  Object.defineProperty(exports, "TIME_SERIES_REDUCERS", { enumerable: true, get: function() {
    return MRANGE_GROUPBY_1.TIME_SERIES_REDUCERS;
  } });
});

// node_modules/redis/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createSentinel = exports.createCluster = exports.createClient = undefined;
  var client_1 = require_dist();
  var bloom_1 = __importDefault(require_lib2());
  var json_1 = __importDefault(require_lib3());
  var search_1 = __importDefault(require_lib4());
  var time_series_1 = __importDefault(require_lib5());
  __exportStar(require_dist(), exports);
  __exportStar(require_lib2(), exports);
  __exportStar(require_lib3(), exports);
  __exportStar(require_lib4(), exports);
  __exportStar(require_lib5(), exports);
  var modules = {
    ...bloom_1.default,
    json: json_1.default,
    ft: search_1.default,
    ts: time_series_1.default
  };
  function createClient(options) {
    return (0, client_1.createClient)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createClient = createClient;
  function createCluster(options) {
    return (0, client_1.createCluster)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createCluster = createCluster;
  function createSentinel(options) {
    return (0, client_1.createSentinel)({
      ...options,
      modules: {
        ...modules,
        ...options?.modules
      }
    });
  }
  exports.createSentinel = createSentinel;
});

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.charCodeAt(9) === 58 ? 13 : 8);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("text").then((text) => JSON.parse(text));
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    this.header("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          if (!part) {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/hono/dist/utils/color.js
function getColorEnabled() {
  const { process: process2, Deno } = globalThis;
  const isNoColor = typeof Deno?.noColor === "boolean" ? Deno.noColor : process2 !== undefined ? "NO_COLOR" in process2?.env : false;
  return !isNoColor;
}
async function getColorEnabledAsync() {
  const { navigator: navigator2 } = globalThis;
  const cfWorkers = "cloudflare:workers";
  const isNoColor = navigator2 !== undefined && navigator2.userAgent === "Cloudflare-Workers" ? await (async () => {
    try {
      return "NO_COLOR" in ((await import(cfWorkers)).env ?? {});
    } catch {
      return false;
    }
  })() : !getColorEnabled();
  return !isNoColor;
}

// node_modules/hono/dist/middleware/logger/index.js
var humanize = (times) => {
  const [delimiter, separator] = [",", "."];
  const orderTimes = times.map((v) => v.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1" + delimiter));
  return orderTimes.join(separator);
};
var time = (start) => {
  const delta = Date.now() - start;
  return humanize([delta < 1000 ? delta + "ms" : Math.round(delta / 1000) + "s"]);
};
var colorStatus = async (status) => {
  const colorEnabled = await getColorEnabledAsync();
  if (colorEnabled) {
    switch (status / 100 | 0) {
      case 5:
        return `\x1B[31m${status}\x1B[0m`;
      case 4:
        return `\x1B[33m${status}\x1B[0m`;
      case 3:
        return `\x1B[36m${status}\x1B[0m`;
      case 2:
        return `\x1B[32m${status}\x1B[0m`;
    }
  }
  return `${status}`;
};
async function log(fn, prefix, method, path, status = 0, elapsed) {
  const out = prefix === "<--" ? `${prefix} ${method} ${path}` : `${prefix} ${method} ${path} ${await colorStatus(status)} ${elapsed}`;
  fn(out);
}
var logger = (fn = console.log) => {
  return async function logger2(c, next) {
    const { method, url } = c.req;
    const path = url.slice(url.indexOf("/", 8));
    await log(fn, "<--", method, path);
    const start = Date.now();
    await next();
    await log(fn, "-->", method, path, c.res.status, time(start));
  };
};

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  };
};

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  function: () => _function,
  formatError: () => formatError,
  flattenError: () => flattenError,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  stringifyPrimitive: () => stringifyPrimitive,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  const set = false;
  Object.defineProperty(object, key, {
    get() {
      if (!set) {
        const value = getter();
        object[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b) => a.path.length - b.path.length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time2,
  string: () => string,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  html5Email: () => html5Email,
  hostname: () => hostname,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time2(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 5
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time2(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === undefined) {
      if (key in input) {
        final.value[key] = undefined;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === undefined) {
    if (key in input)
      final.value[key] = undefined;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o of opts) {
      const values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  vi: () => vi_default,
  ur: () => ur_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  ko: () => ko_default,
  kh: () => kh_default,
  ja: () => ja_default,
  it: () => it_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error7 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType3(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType3(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType3(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}
// node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType3(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error34 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType4(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new Map;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/function.js
class $ZodFunction {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
}
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
// node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time3,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time3(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time3(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse5 = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = cookieValue.indexOf("%") !== -1 ? tryDecode(cookieValue, decodeURIComponent_) : cookieValue;
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse5(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse5(cookie);
  return obj;
};

// node_modules/hono/dist/http-exception.js
var HTTPException2 = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException2(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException2(400, { message });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v]) => {
          return v.length === 1 ? [k, v[0]] : [k, v];
        }));
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    await next();
  };
};

// node_modules/@hono/zod-validator/dist/index.js
var zValidator = (target, schema, hook, options) => validator(target, async (value, c) => {
  let validatorValue = value;
  if (target === "header" && "_def" in schema || target === "header" && "_zod" in schema) {
    const schemaKeys = Object.keys(schema.shape);
    const caseInsensitiveKeymap = Object.fromEntries(schemaKeys.map((key) => [key.toLowerCase(), key]));
    validatorValue = Object.fromEntries(Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2]));
  }
  const result = options && options.validationFunction ? await options.validationFunction(schema, validatorValue) : await schema.safeParseAsync(validatorValue);
  if (hook) {
    const hookResult = await hook({ data: validatorValue, ...result, target }, c);
    if (hookResult) {
      if (hookResult instanceof Response) {
        return hookResult;
      }
      if ("response" in hookResult) {
        return hookResult.response;
      }
    }
  }
  if (!result.success) {
    return c.json(result, 400);
  }
  return result.data;
});

// src/features/ingest/validation.js
var schema = exports_external.object({
  utcdatetime: exports_external.string().datetime(),
  value: exports_external.number(),
  status: exports_external.number().int().optional()
});
var validation = zValidator("json", schema, (result, c) => {
  if (!result.success) {
    throw result.error;
  }
});
var validation_default = validation;

// src/lib/kafka.js
var import_config = __toESM(require_config(), 1);
var import_kafkajs = __toESM(require_kafkajs(), 1);
var { KAFKA_CLIENT_ID = "timepush-ingest-api", KAFKA_BROKER = "localhost:9092", KAFKA_CONN_TIMEOUT = "1000", KAFKA_REQ_TIMEOUT = "3000", KAFKA_RETRIES = "0", KAFKA_DATA_TOPIC, KAFKA_ERROR_TOPIC } = process.env;
var kafka = new import_kafkajs.Kafka({
  clientId: KAFKA_CLIENT_ID,
  brokers: [KAFKA_BROKER],
  connectionTimeout: Number(KAFKA_CONN_TIMEOUT),
  requestTimeout: Number(KAFKA_REQ_TIMEOUT),
  retry: { retries: Number(KAFKA_RETRIES) },
  logLevel: import_kafkajs.logLevel.ERROR
});
var producer = kafka.producer();
var isProducerConnected = false;
async function connectProducer() {
  if (isProducerConnected)
    return;
  try {
    await Promise.race([producer.connect(), new Promise((_, reject) => setTimeout(() => reject(new Error("Kafka producer connect timeout")), 1000))]);
    isProducerConnected = true;
  } catch (err) {
    throw new Error("Kafka producer unavailable");
  }
}
async function sendMessage(topic, payload) {
  await connectProducer();
  return producer.send({
    topic,
    messages: [{ value: JSON.stringify(payload) }]
  });
}
async function sendToData(payload) {
  if (!KAFKA_DATA_TOPIC)
    throw new Error("KAFKA_DATA_TOPIC is not defined");
  return sendMessage(KAFKA_DATA_TOPIC, payload);
}
async function sendToError(payload) {
  if (!KAFKA_ERROR_TOPIC)
    throw new Error("KAFKA_ERROR_TOPIC is not defined");
  return sendMessage(KAFKA_ERROR_TOPIC, payload);
}

// src/features/ingest/index.js
var import_config2 = __toESM(require_config(), 1);
var ingestRoute = new Hono2;
ingestRoute.post("/raw", validation_default, async (c) => {
  const payload = await c.req.json();
  const datasourceId = c.get("datasource_id");
  if (!datasourceId) {
    throw new HTTPException(500, { message: "Missing datasource context client_id" });
  }
  const message = {
    datasource_id: datasourceId,
    ...payload
  };
  await sendToData(message);
  console.log("Data sent to timepush-data topic");
  return c.json({ message: "Data sent to timepush-data topic successfully" });
});
var ingest_default = ingestRoute;

// src/middlewares/authMiddleware.js
import { createHash } from "crypto";

// node_modules/bcryptjs/index.js
import nodeCrypto from "crypto";
var randomFallback = null;
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {}
  try {
    return nodeCrypto.randomBytes(len);
  } catch {}
  if (!randomFallback) {
    throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
  }
  return randomFallback(len);
}
function setRandomFallback(random) {
  randomFallback = random;
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error("Illegal arguments: " + typeof rounds + ", " + typeof seed_length);
  if (rounds < 4)
    rounds = 4;
  else if (rounds > 31)
    rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10)
    salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = undefined;
  if (typeof rounds === "function")
    callback = rounds, rounds = undefined;
  if (typeof rounds === "undefined")
    rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function hashSync(password, salt) {
  if (typeof salt === "undefined")
    salt = GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof salt === "number")
    salt = genSaltSync(salt);
  if (typeof password !== "string" || typeof salt !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof salt);
  return _hash(password, salt);
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof salt)));
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function safeStringCompare(known, unknown2) {
  var diff = known.length ^ unknown2.length;
  for (var i = 0;i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown2.charCodeAt(i);
  }
  return diff === 0;
}
function compareSync(password, hash2) {
  if (typeof password !== "string" || typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof hash2);
  if (hash2.length !== 60)
    return false;
  return safeStringCompare(hashSync(password, hash2.substring(0, hash2.length - 31)), hash2);
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(callback2.bind(this, Error("Illegal arguments: " + typeof password + ", " + typeof hashValue)));
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(password, hashValue.substring(0, 29), function(err, comp) {
      if (err)
        callback2(err);
      else
        callback2(null, safeStringCompare(comp, hashValue));
    }, progressCallback);
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve(res);
      });
    });
}
function getRounds(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  return parseInt(hash2.split("$")[2], 10);
}
function getSalt(hash2) {
  if (typeof hash2 !== "string")
    throw Error("Illegal arguments: " + typeof hash2);
  if (hash2.length !== 60)
    throw Error("Illegal hash length: " + hash2.length + " != 60");
  return hash2.substring(0, 29);
}
function truncates(password) {
  if (typeof password !== "string")
    throw Error("Illegal arguments: " + typeof password);
  return utf8Length(password) > 72;
}
var nextTick = typeof process !== "undefined" && process && typeof process.nextTick === "function" ? typeof setImmediate === "function" ? setImmediate : process.nextTick : setTimeout;
function utf8Length(string4) {
  var len = 0, c = 0;
  for (var i = 0;i < string4.length; ++i) {
    c = string4.charCodeAt(i);
    if (c < 128)
      len += 1;
    else if (c < 2048)
      len += 2;
    else if ((c & 64512) === 55296 && (string4.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
}
function utf8Array(string4) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string4));
  for (var i = 0, k = string4.length;i < k; ++i) {
    c1 = string4.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string4.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
var BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
var BASE64_INDEX = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  -1,
  -1,
  -1,
  -1,
  -1
];
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length)
    throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s, len) {
  var off = 0, slen = s.length, olen = 0, rs = [], c1, c2, c3, c4, o, code;
  if (len <= 0)
    throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1)
      break;
    o = c1 << 2 >>> 0;
    o |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1)
      break;
    o = (c2 & 15) << 4 >>> 0;
    o |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o));
    if (++olen >= len || off >= slen)
      break;
    code = s.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o = (c3 & 3) << 6 >>> 0;
    o |= c4;
    rs.push(String.fromCharCode(o));
    ++olen;
  }
  var res = [];
  for (off = 0;off < olen; off++)
    res.push(rs[off].charCodeAt(0));
  return res;
}
var BCRYPT_SALT_LEN = 16;
var GENSALT_DEFAULT_LOG2_ROUNDS = 10;
var BLOWFISH_NUM_ROUNDS = 16;
var MAX_EXECUTION_TIME = 100;
var P_ORIG = [
  608135816,
  2242054355,
  320440878,
  57701188,
  2752067618,
  698298832,
  137296536,
  3964562569,
  1160258022,
  953160567,
  3193202383,
  887688300,
  3232508343,
  3380367581,
  1065670069,
  3041331479,
  2450970073,
  2306472731
];
var S_ORIG = [
  3509652390,
  2564797868,
  805139163,
  3491422135,
  3101798381,
  1780907670,
  3128725573,
  4046225305,
  614570311,
  3012652279,
  134345442,
  2240740374,
  1667834072,
  1901547113,
  2757295779,
  4103290238,
  227898511,
  1921955416,
  1904987480,
  2182433518,
  2069144605,
  3260701109,
  2620446009,
  720527379,
  3318853667,
  677414384,
  3393288472,
  3101374703,
  2390351024,
  1614419982,
  1822297739,
  2954791486,
  3608508353,
  3174124327,
  2024746970,
  1432378464,
  3864339955,
  2857741204,
  1464375394,
  1676153920,
  1439316330,
  715854006,
  3033291828,
  289532110,
  2706671279,
  2087905683,
  3018724369,
  1668267050,
  732546397,
  1947742710,
  3462151702,
  2609353502,
  2950085171,
  1814351708,
  2050118529,
  680887927,
  999245976,
  1800124847,
  3300911131,
  1713906067,
  1641548236,
  4213287313,
  1216130144,
  1575780402,
  4018429277,
  3917837745,
  3693486850,
  3949271944,
  596196993,
  3549867205,
  258830323,
  2213823033,
  772490370,
  2760122372,
  1774776394,
  2652871518,
  566650946,
  4142492826,
  1728879713,
  2882767088,
  1783734482,
  3629395816,
  2517608232,
  2874225571,
  1861159788,
  326777828,
  3124490320,
  2130389656,
  2716951837,
  967770486,
  1724537150,
  2185432712,
  2364442137,
  1164943284,
  2105845187,
  998989502,
  3765401048,
  2244026483,
  1075463327,
  1455516326,
  1322494562,
  910128902,
  469688178,
  1117454909,
  936433444,
  3490320968,
  3675253459,
  1240580251,
  122909385,
  2157517691,
  634681816,
  4142456567,
  3825094682,
  3061402683,
  2540495037,
  79693498,
  3249098678,
  1084186820,
  1583128258,
  426386531,
  1761308591,
  1047286709,
  322548459,
  995290223,
  1845252383,
  2603652396,
  3431023940,
  2942221577,
  3202600964,
  3727903485,
  1712269319,
  422464435,
  3234572375,
  1170764815,
  3523960633,
  3117677531,
  1434042557,
  442511882,
  3600875718,
  1076654713,
  1738483198,
  4213154764,
  2393238008,
  3677496056,
  1014306527,
  4251020053,
  793779912,
  2902807211,
  842905082,
  4246964064,
  1395751752,
  1040244610,
  2656851899,
  3396308128,
  445077038,
  3742853595,
  3577915638,
  679411651,
  2892444358,
  2354009459,
  1767581616,
  3150600392,
  3791627101,
  3102740896,
  284835224,
  4246832056,
  1258075500,
  768725851,
  2589189241,
  3069724005,
  3532540348,
  1274779536,
  3789419226,
  2764799539,
  1660621633,
  3471099624,
  4011903706,
  913787905,
  3497959166,
  737222580,
  2514213453,
  2928710040,
  3937242737,
  1804850592,
  3499020752,
  2949064160,
  2386320175,
  2390070455,
  2415321851,
  4061277028,
  2290661394,
  2416832540,
  1336762016,
  1754252060,
  3520065937,
  3014181293,
  791618072,
  3188594551,
  3933548030,
  2332172193,
  3852520463,
  3043980520,
  413987798,
  3465142937,
  3030929376,
  4245938359,
  2093235073,
  3534596313,
  375366246,
  2157278981,
  2479649556,
  555357303,
  3870105701,
  2008414854,
  3344188149,
  4221384143,
  3956125452,
  2067696032,
  3594591187,
  2921233993,
  2428461,
  544322398,
  577241275,
  1471733935,
  610547355,
  4027169054,
  1432588573,
  1507829418,
  2025931657,
  3646575487,
  545086370,
  48609733,
  2200306550,
  1653985193,
  298326376,
  1316178497,
  3007786442,
  2064951626,
  458293330,
  2589141269,
  3591329599,
  3164325604,
  727753846,
  2179363840,
  146436021,
  1461446943,
  4069977195,
  705550613,
  3059967265,
  3887724982,
  4281599278,
  3313849956,
  1404054877,
  2845806497,
  146425753,
  1854211946,
  1266315497,
  3048417604,
  3681880366,
  3289982499,
  2909710000,
  1235738493,
  2632868024,
  2414719590,
  3970600049,
  1771706367,
  1449415276,
  3266420449,
  422970021,
  1963543593,
  2690192192,
  3826793022,
  1062508698,
  1531092325,
  1804592342,
  2583117782,
  2714934279,
  4024971509,
  1294809318,
  4028980673,
  1289560198,
  2221992742,
  1669523910,
  35572830,
  157838143,
  1052438473,
  1016535060,
  1802137761,
  1753167236,
  1386275462,
  3080475397,
  2857371447,
  1040679964,
  2145300060,
  2390574316,
  1461121720,
  2956646967,
  4031777805,
  4028374788,
  33600511,
  2920084762,
  1018524850,
  629373528,
  3691585981,
  3515945977,
  2091462646,
  2486323059,
  586499841,
  988145025,
  935516892,
  3367335476,
  2599673255,
  2839830854,
  265290510,
  3972581182,
  2759138881,
  3795373465,
  1005194799,
  847297441,
  406762289,
  1314163512,
  1332590856,
  1866599683,
  4127851711,
  750260880,
  613907577,
  1450815602,
  3165620655,
  3734664991,
  3650291728,
  3012275730,
  3704569646,
  1427272223,
  778793252,
  1343938022,
  2676280711,
  2052605720,
  1946737175,
  3164576444,
  3914038668,
  3967478842,
  3682934266,
  1661551462,
  3294938066,
  4011595847,
  840292616,
  3712170807,
  616741398,
  312560963,
  711312465,
  1351876610,
  322626781,
  1910503582,
  271666773,
  2175563734,
  1594956187,
  70604529,
  3617834859,
  1007753275,
  1495573769,
  4069517037,
  2549218298,
  2663038764,
  504708206,
  2263041392,
  3941167025,
  2249088522,
  1514023603,
  1998579484,
  1312622330,
  694541497,
  2582060303,
  2151582166,
  1382467621,
  776784248,
  2618340202,
  3323268794,
  2497899128,
  2784771155,
  503983604,
  4076293799,
  907881277,
  423175695,
  432175456,
  1378068232,
  4145222326,
  3954048622,
  3938656102,
  3820766613,
  2793130115,
  2977904593,
  26017576,
  3274890735,
  3194772133,
  1700274565,
  1756076034,
  4006520079,
  3677328699,
  720338349,
  1533947780,
  354530856,
  688349552,
  3973924725,
  1637815568,
  332179504,
  3949051286,
  53804574,
  2852348879,
  3044236432,
  1282449977,
  3583942155,
  3416972820,
  4006381244,
  1617046695,
  2628476075,
  3002303598,
  1686838959,
  431878346,
  2686675385,
  1700445008,
  1080580658,
  1009431731,
  832498133,
  3223435511,
  2605976345,
  2271191193,
  2516031870,
  1648197032,
  4164389018,
  2548247927,
  300782431,
  375919233,
  238389289,
  3353747414,
  2531188641,
  2019080857,
  1475708069,
  455242339,
  2609103871,
  448939670,
  3451063019,
  1395535956,
  2413381860,
  1841049896,
  1491858159,
  885456874,
  4264095073,
  4001119347,
  1565136089,
  3898914787,
  1108368660,
  540939232,
  1173283510,
  2745871338,
  3681308437,
  4207628240,
  3343053890,
  4016749493,
  1699691293,
  1103962373,
  3625875870,
  2256883143,
  3830138730,
  1031889488,
  3479347698,
  1535977030,
  4236805024,
  3251091107,
  2132092099,
  1774941330,
  1199868427,
  1452454533,
  157007616,
  2904115357,
  342012276,
  595725824,
  1480756522,
  206960106,
  497939518,
  591360097,
  863170706,
  2375253569,
  3596610801,
  1814182875,
  2094937945,
  3421402208,
  1082520231,
  3463918190,
  2785509508,
  435703966,
  3908032597,
  1641649973,
  2842273706,
  3305899714,
  1510255612,
  2148256476,
  2655287854,
  3276092548,
  4258621189,
  236887753,
  3681803219,
  274041037,
  1734335097,
  3815195456,
  3317970021,
  1899903192,
  1026095262,
  4050517792,
  356393447,
  2410691914,
  3873677099,
  3682840055,
  3913112168,
  2491498743,
  4132185628,
  2489919796,
  1091903735,
  1979897079,
  3170134830,
  3567386728,
  3557303409,
  857797738,
  1136121015,
  1342202287,
  507115054,
  2535736646,
  337727348,
  3213592640,
  1301675037,
  2528481711,
  1895095763,
  1721773893,
  3216771564,
  62756741,
  2142006736,
  835421444,
  2531993523,
  1442658625,
  3659876326,
  2882144922,
  676362277,
  1392781812,
  170690266,
  3921047035,
  1759253602,
  3611846912,
  1745797284,
  664899054,
  1329594018,
  3901205900,
  3045908486,
  2062866102,
  2865634940,
  3543621612,
  3464012697,
  1080764994,
  553557557,
  3656615353,
  3996768171,
  991055499,
  499776247,
  1265440854,
  648242737,
  3940784050,
  980351604,
  3713745714,
  1749149687,
  3396870395,
  4211799374,
  3640570775,
  1161844396,
  3125318951,
  1431517754,
  545492359,
  4268468663,
  3499529547,
  1437099964,
  2702547544,
  3433638243,
  2581715763,
  2787789398,
  1060185593,
  1593081372,
  2418618748,
  4260947970,
  69676912,
  2159744348,
  86519011,
  2512459080,
  3838209314,
  1220612927,
  3339683548,
  133810670,
  1090789135,
  1078426020,
  1569222167,
  845107691,
  3583754449,
  4072456591,
  1091646820,
  628848692,
  1613405280,
  3757631651,
  526609435,
  236106946,
  48312990,
  2942717905,
  3402727701,
  1797494240,
  859738849,
  992217954,
  4005476642,
  2243076622,
  3870952857,
  3732016268,
  765654824,
  3490871365,
  2511836413,
  1685915746,
  3888969200,
  1414112111,
  2273134842,
  3281911079,
  4080962846,
  172450625,
  2569994100,
  980381355,
  4109958455,
  2819808352,
  2716589560,
  2568741196,
  3681446669,
  3329971472,
  1835478071,
  660984891,
  3704678404,
  4045999559,
  3422617507,
  3040415634,
  1762651403,
  1719377915,
  3470491036,
  2693910283,
  3642056355,
  3138596744,
  1364962596,
  2073328063,
  1983633131,
  926494387,
  3423689081,
  2150032023,
  4096667949,
  1749200295,
  3328846651,
  309677260,
  2016342300,
  1779581495,
  3079819751,
  111262694,
  1274766160,
  443224088,
  298511866,
  1025883608,
  3806446537,
  1145181785,
  168956806,
  3641502830,
  3584813610,
  1689216846,
  3666258015,
  3200248200,
  1692713982,
  2646376535,
  4042768518,
  1618508792,
  1610833997,
  3523052358,
  4130873264,
  2001055236,
  3610705100,
  2202168115,
  4028541809,
  2961195399,
  1006657119,
  2006996926,
  3186142756,
  1430667929,
  3210227297,
  1314452623,
  4074634658,
  4101304120,
  2273951170,
  1399257539,
  3367210612,
  3027628629,
  1190975929,
  2062231137,
  2333990788,
  2221543033,
  2438960610,
  1181637006,
  548689776,
  2362791313,
  3372408396,
  3104550113,
  3145860560,
  296247880,
  1970579870,
  3078560182,
  3769228297,
  1714227617,
  3291629107,
  3898220290,
  166772364,
  1251581989,
  493813264,
  448347421,
  195405023,
  2709975567,
  677966185,
  3703036547,
  1463355134,
  2715995803,
  1338867538,
  1343315457,
  2802222074,
  2684532164,
  233230375,
  2599980071,
  2000651841,
  3277868038,
  1638401717,
  4028070440,
  3237316320,
  6314154,
  819756386,
  300326615,
  590932579,
  1405279636,
  3267499572,
  3150704214,
  2428286686,
  3959192993,
  3461946742,
  1862657033,
  1266418056,
  963775037,
  2089974820,
  2263052895,
  1917689273,
  448879540,
  3550394620,
  3981727096,
  150775221,
  3627908307,
  1303187396,
  508620638,
  2975983352,
  2726630617,
  1817252668,
  1876281319,
  1457606340,
  908771278,
  3720792119,
  3617206836,
  2455994898,
  1729034894,
  1080033504,
  976866871,
  3556439503,
  2881648439,
  1522871579,
  1555064734,
  1336096578,
  3548522304,
  2579274686,
  3574697629,
  3205460757,
  3593280638,
  3338716283,
  3079412587,
  564236357,
  2993598910,
  1781952180,
  1464380207,
  3163844217,
  3332601554,
  1699332808,
  1393555694,
  1183702653,
  3581086237,
  1288719814,
  691649499,
  2847557200,
  2895455976,
  3193889540,
  2717570544,
  1781354906,
  1676643554,
  2592534050,
  3230253752,
  1126444790,
  2770207658,
  2633158820,
  2210423226,
  2615765581,
  2414155088,
  3127139286,
  673620729,
  2805611233,
  1269405062,
  4015350505,
  3341807571,
  4149409754,
  1057255273,
  2012875353,
  2162469141,
  2276492801,
  2601117357,
  993977747,
  3918593370,
  2654263191,
  753973209,
  36408145,
  2530585658,
  25011837,
  3520020182,
  2088578344,
  530523599,
  2918365339,
  1524020338,
  1518925132,
  3760827505,
  3759777254,
  1202760957,
  3985898139,
  3906192525,
  674977740,
  4174734889,
  2031300136,
  2019492241,
  3983892565,
  4153806404,
  3822280332,
  352677332,
  2297720250,
  60907813,
  90501309,
  3286998549,
  1016092578,
  2535922412,
  2839152426,
  457141659,
  509813237,
  4120667899,
  652014361,
  1966332200,
  2975202805,
  55981186,
  2327461051,
  676427537,
  3255491064,
  2882294119,
  3433927263,
  1307055953,
  942726286,
  933058658,
  2468411793,
  3933900994,
  4215176142,
  1361170020,
  2001714738,
  2830558078,
  3274259782,
  1222529897,
  1679025792,
  2729314320,
  3714953764,
  1770335741,
  151462246,
  3013232138,
  1682292957,
  1483529935,
  471910574,
  1539241949,
  458788160,
  3436315007,
  1807016891,
  3718408830,
  978976581,
  1043663428,
  3165965781,
  1927990952,
  4200891579,
  2372276910,
  3208408903,
  3533431907,
  1412390302,
  2931980059,
  4132332400,
  1947078029,
  3881505623,
  4168226417,
  2941484381,
  1077988104,
  1320477388,
  886195818,
  18198404,
  3786409000,
  2509781533,
  112762804,
  3463356488,
  1866414978,
  891333506,
  18488651,
  661792760,
  1628790961,
  3885187036,
  3141171499,
  876946877,
  2693282273,
  1372485963,
  791857591,
  2686433993,
  3759982718,
  3167212022,
  3472953795,
  2716379847,
  445679433,
  3561995674,
  3504004811,
  3574258232,
  54117162,
  3331405415,
  2381918588,
  3769707343,
  4154350007,
  1140177722,
  4074052095,
  668550556,
  3214352940,
  367459370,
  261225585,
  2610173221,
  4209349473,
  3468074219,
  3265815641,
  314222801,
  3066103646,
  3808782860,
  282218597,
  3406013506,
  3773591054,
  379116347,
  1285071038,
  846784868,
  2669647154,
  3771962079,
  3550491691,
  2305946142,
  453669953,
  1268987020,
  3317592352,
  3279303384,
  3744833421,
  2610507566,
  3859509063,
  266596637,
  3847019092,
  517658769,
  3462560207,
  3443424879,
  370717030,
  4247526661,
  2224018117,
  4143653529,
  4112773975,
  2788324899,
  2477274417,
  1456262402,
  2901442914,
  1517677493,
  1846949527,
  2295493580,
  3734397586,
  2176403920,
  1280348187,
  1908823572,
  3871786941,
  846861322,
  1172426758,
  3287448474,
  3383383037,
  1655181056,
  3139813346,
  901632758,
  1897031941,
  2986607138,
  3066810236,
  3447102507,
  1393639104,
  373351379,
  950779232,
  625454576,
  3124240540,
  4148612726,
  2007998917,
  544563296,
  2244738638,
  2330496472,
  2058025392,
  1291430526,
  424198748,
  50039436,
  29584100,
  3605783033,
  2429876329,
  2791104160,
  1057563949,
  3255363231,
  3075367218,
  3463963227,
  1469046755,
  985887462
];
var C_ORIG = [
  1332899944,
  1700884034,
  1701343084,
  1684370003,
  1668446532,
  1869963892
];
function _encipher(lr, off, P, S) {
  var n, l = lr[off], r = lr[off + 1];
  l ^= P[0];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[1];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[2];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[3];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[4];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[5];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[6];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[7];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[8];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[9];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[10];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[11];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[12];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[13];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[14];
  n = S[l >>> 24];
  n += S[256 | l >> 16 & 255];
  n ^= S[512 | l >> 8 & 255];
  n += S[768 | l & 255];
  r ^= n ^ P[15];
  n = S[r >>> 24];
  n += S[256 | r >> 16 & 255];
  n ^= S[512 | r >> 8 & 255];
  n += S[768 | r & 255];
  l ^= n ^ P[16];
  lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0;i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0;i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0;i < plen; i++)
    sw = _streamtoword(key, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0;i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0;i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error("Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback)
      progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (;i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME)
          break;
      }
    } else {
      for (i = 0;i < 64; i++)
        for (j = 0;j < clen >> 1; j++)
          _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0;i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else
        return ret;
    }
    if (callback)
      nextTick(next);
  }
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true)
      if (typeof (res = next()) !== "undefined")
        return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.charAt(2) === "$")
    minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else
        throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r2 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r2, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\x00" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a")
      res.push(minor);
    res.push("$");
    if (rounds < 10)
      res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(passwordb, saltb, rounds, function(err2, bytes) {
      if (err2)
        callback(err2, null);
      else
        callback(null, finish(bytes));
    }, progressCallback);
  }
}
function encodeBase64(bytes, length) {
  return base64_encode(bytes, length);
}
function decodeBase64(string4, length) {
  return base64_decode(string4, length);
}
var bcryptjs_default = {
  setRandomFallback,
  genSaltSync,
  genSalt,
  hashSync,
  hash,
  compareSync,
  compare,
  getRounds,
  getSalt,
  truncates,
  encodeBase64,
  decodeBase64
};

// src/middlewares/authMiddleware.js
var import_config5 = __toESM(require_config(), 1);

// src/lib/db.js
var import_config3 = __toESM(require_config(), 1);
var {SQL } = globalThis.Bun;
var sql = SQL({
  url: process.env.DATABASE_URL,
  max: 20,
  idleTimeout: 30,
  connectTimeout: 5
});
var db_default = sql;

// src/lib/redis.js
var import_redis = __toESM(require_dist2(), 1);
var import_config4 = __toESM(require_config(), 1);
var client = null;
var isReady = false;
async function getRedisClient() {
  if (client && isReady)
    return client;
  client = import_redis.createClient({
    socket: {
      host: process.env.REDIS_HOST || "127.0.0.1",
      port: parseInt(process.env.REDIS_PORT, 10) || 6379,
      reconnectStrategy: () => new Error("No reconnect: fail fast on disconnect")
    }
  });
  client.on("error", () => {
    isReady = false;
  });
  client.on("ready", () => {
    isReady = true;
  });
  try {
    await client.connect();
    isReady = true;
    return client;
  } catch {
    isReady = false;
    throw new Error("Redis connection failed");
  }
}

// src/middlewares/authMiddleware.js
var authMiddleware = async (c, next) => {
  const client2 = await getRedisClient();
  const authHeader = c.req.header("Authorization") || "";
  const clientId = c.req.header("X-Client-ID");
  if (!authHeader.startsWith("Bearer ") || !clientId) {
    throw new HTTPException2(400, { message: "Missing Authorization or X-Client-ID header" });
  }
  const rawSecret = authHeader.slice(7).trim();
  const fp = createHash("sha256").update(rawSecret, "utf8").digest("hex");
  const cacheKey = `ds:client:${clientId}:fp:${fp}`;
  let datasourceId = await client2.get(cacheKey);
  if (!datasourceId) {
    const rows = await db_default`
        SELECT id, client_secret_hash
        FROM data_sources
        WHERE client_id = ${clientId}
    `;
    if (rows.length === 0) {
      throw new HTTPException2(401, { message: "Invalid client_id" });
    }
    const { id, client_secret_hash } = rows[0];
    const ok = await bcryptjs_default.compare(rawSecret, client_secret_hash);
    if (!ok) {
      throw new HTTPException2(401, { message: "Invalid client_secret" });
    }
    datasourceId = id.toString();
    await client2.set(cacheKey, datasourceId, { EX: 3600 });
  }
  c.set("datasource_id", datasourceId);
  return next();
};

// src/router.js
var ApiRouter = new Hono2;
ApiRouter.use("/ingest/*", authMiddleware);
ApiRouter.route("/ingest", ingest_default);
var router_default = ApiRouter;

// src/lib/errorHandler.js
async function handleError(err, c) {
  let errorMessage = err.message;
  if (err.name === "ZodError" && err.message) {
    try {
      const parsed = JSON.parse(err.message);
      if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].message) {
        errorMessage = parsed[0].message;
      }
    } catch (_) {}
  }
  try {
    var payload = await c.req.json();
    await sendToError({
      error_descr: errorMessage,
      raw_message: JSON.stringify(payload || null),
      error_time: new Date().toISOString(),
      datasource_id: c.get("datasource_id") || null
    });
  } catch (kafkaErr) {
    console.error("Failed to send error to Kafka:", kafkaErr);
  }
  if (err instanceof HTTPException2) {
    return c.json({ status: err.status, ok: false, message: errorMessage }, err.status);
  }
  return c.json({ status: 500, ok: false, message: errorMessage }, 500);
}

// src/lib/connections.js
var testConnections = async () => {
  try {
    await db_default`SELECT 1`;
    console.log("[Startup] Postgres client ready");
  } catch (err) {
    throw new Error("Postgres unavailable");
  }
  try {
    const client2 = await getRedisClient();
    if (!client2.isOpen)
      throw new Error("Redis client is not open after connect");
    console.log("[Startup] Redis client ready");
  } catch (err) {
    throw new Error("Redis unavailable");
  }
  try {
    await connectProducer();
    console.log("[Startup] Kafka producer ready");
  } catch (err) {
    throw new Error("Kafka unavailable");
  }
};

// src/index.js
var app = new Hono2({ strict: false });
app.use(logger());
app.use("*", cors({ origin: "*" }));
app.onError(handleError);
app.route("", router_default);
app.notFound((c) => c.json({ status: 404, ok: false, message: "Not Found" }));
await testConnections();
var src_default = {
  port: 3000,
  fetch: app.fetch
};
export {
  src_default as default
};
